<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - mapserver.info - mapserver/mappostgis.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">mapserver</a> - mappostgis.c<span style="font-size: 80%;"> (source / <a href="mappostgis.c.func.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">mapserver.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">857</td>
            <td class="headerCovTableEntry">1512</td>
            <td class="headerCovTableEntryLo">56.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">XXXX-XX-XX</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">43</td>
            <td class="headerCovTableEntry">60</td>
            <td class="headerCovTableEntryLo">71.7 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /******************************************************************************</a>
<span class="lineNum">       2 </span>            :  * $Id$
<span class="lineNum">       3 </span>            :  *
<span class="lineNum">       4 </span>            :  * Project:  MapServer
<span class="lineNum">       5 </span>            :  * Purpose:  PostGIS CONNECTIONTYPE support.
<span class="lineNum">       6 </span>            :  * Author:   Paul Ramsey &lt;pramsey@cleverelephant.ca&gt;
<span class="lineNum">       7 </span>            :  *           Dave Blasby &lt;dblasby@gmail.com&gt;
<span class="lineNum">       8 </span>            :  *
<span class="lineNum">       9 </span>            :  ******************************************************************************
<span class="lineNum">      10 </span>            :  * Copyright (c) 2010 Paul Ramsey
<span class="lineNum">      11 </span>            :  * Copyright (c) 2002 Refractions Research
<span class="lineNum">      12 </span>            :  *
<span class="lineNum">      13 </span>            :  * Permission is hereby granted, free of charge, to any person obtaining a
<span class="lineNum">      14 </span>            :  * copy of this software and associated documentation files (the &quot;Software&quot;),
<span class="lineNum">      15 </span>            :  * to deal in the Software without restriction, including without limitation
<span class="lineNum">      16 </span>            :  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
<span class="lineNum">      17 </span>            :  * and/or sell copies of the Software, and to permit persons to whom the
<span class="lineNum">      18 </span>            :  * Software is furnished to do so, subject to the following conditions:
<span class="lineNum">      19 </span>            :  *
<span class="lineNum">      20 </span>            :  * The above copyright notice and this permission notice shall be included in
<span class="lineNum">      21 </span>            :  * all copies of this Software or works derived from this Software.
<span class="lineNum">      22 </span>            :  *
<span class="lineNum">      23 </span>            :  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
<span class="lineNum">      24 </span>            :  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<span class="lineNum">      25 </span>            :  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
<span class="lineNum">      26 </span>            :  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
<span class="lineNum">      27 </span>            :  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
<span class="lineNum">      28 </span>            :  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
<span class="lineNum">      29 </span>            :  * DEALINGS IN THE SOFTWARE.
<span class="lineNum">      30 </span>            :  ****************************************************************************/
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : /*
<span class="lineNum">      33 </span>            : ** Some theory of operation:
<span class="lineNum">      34 </span>            : **
<span class="lineNum">      35 </span>            : ** Build SQL from DATA statement and LAYER state. SQL is always of the form:
<span class="lineNum">      36 </span>            : **
<span class="lineNum">      37 </span>            : **    SELECT [this, that, other], geometry, uid
<span class="lineNum">      38 </span>            : **      FROM [table|(subquery) as sub]
<span class="lineNum">      39 </span>            : **      WHERE [box] AND [filter]
<span class="lineNum">      40 </span>            : **
<span class="lineNum">      41 </span>            : ** So the geometry always resides at layer-&gt;numitems and the uid always
<span class="lineNum">      42 </span>            : ** resides at layer-&gt;numitems + 1
<span class="lineNum">      43 </span>            : **
<span class="lineNum">      44 </span>            : ** Geometry is requested as Hex encoded WKB. The endian is always requested
<span class="lineNum">      45 </span>            : ** as the client endianness.
<span class="lineNum">      46 </span>            : **
<span class="lineNum">      47 </span>            : ** msPostGISLayerWhichShapes creates SQL based on DATA and LAYER state,
<span class="lineNum">      48 </span>            : ** executes it, and places the un-read PGresult handle in the layerinfo-&gt;pgresult,
<span class="lineNum">      49 </span>            : ** setting the layerinfo-&gt;rownum to 0.
<span class="lineNum">      50 </span>            : **
<span class="lineNum">      51 </span>            : ** msPostGISNextShape reads a row, increments layerinfo-&gt;rownum, and returns
<span class="lineNum">      52 </span>            : ** MS_SUCCESS, until rownum reaches ntuples, and it returns MS_DONE instead.
<span class="lineNum">      53 </span>            : **
<span class="lineNum">      54 </span>            : */
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : /* GNU needs this for strcasestr */
<span class="lineNum">      57 </span>            : #define _GNU_SOURCE
<span class="lineNum">      58 </span>            : /* required for MSVC */
<span class="lineNum">      59 </span>            : #define _USE_MATH_DEFINES
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : #include &lt;assert.h&gt;
<span class="lineNum">      62 </span>            : #include &lt;string.h&gt;
<span class="lineNum">      63 </span>            : #include &lt;math.h&gt;
<span class="lineNum">      64 </span>            : #include &quot;mapserver.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;maptime.h&quot;
<span class="lineNum">      66 </span>            : #include &quot;mappostgis.h&quot;
<span class="lineNum">      67 </span>            : #include &quot;mapows.h&quot;
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            : #define FP_EPSILON 1e-12
<span class="lineNum">      70 </span>            : #define FP_EQ(a, b) (fabs((a)-(b)) &lt; FP_EPSILON)
<span class="lineNum">      71 </span>            : #define FP_LEFT -1
<span class="lineNum">      72 </span>            : #define FP_RIGHT 1
<span class="lineNum">      73 </span>            : #define FP_COLINEAR 0
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : #define SEGMENT_ANGLE 10.0
<span class="lineNum">      76 </span>            : #define SEGMENT_MINPOINTS 10
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : #define WKBZOFFSET_NONISO 0x80000000
<span class="lineNum">      79 </span>            : #define WKBMOFFSET_NONISO 0x40000000
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : #define HAS_Z   0x1
<span class="lineNum">      82 </span>            : #define HAS_M   0x2
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            : #if TRANSFER_ENCODING == 256
<span class="lineNum">      85 </span>            : #define RESULTSET_TYPE 1
<span class="lineNum">      86 </span>            : #else
<span class="lineNum">      87 </span>            : #define RESULTSET_TYPE 0
<span class="lineNum">      88 </span>            : #endif
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : /*
<span class="lineNum">      95 </span>            : ** msPostGISCloseConnection()
<span class="lineNum">      96 </span>            : **
<span class="lineNum">      97 </span>            : ** Handler registered witih msConnPoolRegister so that Mapserver
<a name="98"><span class="lineNum">      98 </span>            : ** can clean up open connections during a shutdown.</a>
<span class="lineNum">      99 </span>            : */
<span class="lineNum">     100 </span><span class="lineCov">          1 : void msPostGISCloseConnection(void *pgconn)</span>
<span class="lineNum">     101 </span>            : {
<span class="lineNum">     102 </span><span class="lineCov">          1 :   PQfinish((PGconn*)pgconn);</span>
<span class="lineNum">     103 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : /*
<a name="106"><span class="lineNum">     106 </span>            : ** msPostGISCreateLayerInfo()</a>
<span class="lineNum">     107 </span>            : */
<span class="lineNum">     108 </span><span class="lineCov">          1 : msPostGISLayerInfo *msPostGISCreateLayerInfo(void)</span>
<span class="lineNum">     109 </span>            : {
<span class="lineNum">     110 </span><span class="lineCov">          1 :   msPostGISLayerInfo *layerinfo = msSmallMalloc(sizeof(msPostGISLayerInfo));</span>
<span class="lineNum">     111 </span><span class="lineCov">          1 :   layerinfo-&gt;sql = NULL;</span>
<span class="lineNum">     112 </span><span class="lineCov">          1 :   layerinfo-&gt;srid = NULL;</span>
<span class="lineNum">     113 </span><span class="lineCov">          1 :   layerinfo-&gt;uid = NULL;</span>
<span class="lineNum">     114 </span><span class="lineCov">          1 :   layerinfo-&gt;pgconn = NULL;</span>
<span class="lineNum">     115 </span><span class="lineCov">          1 :   layerinfo-&gt;pgresult = NULL;</span>
<span class="lineNum">     116 </span><span class="lineCov">          1 :   layerinfo-&gt;geomcolumn = NULL;</span>
<span class="lineNum">     117 </span><span class="lineCov">          1 :   layerinfo-&gt;fromsource = NULL;</span>
<span class="lineNum">     118 </span><span class="lineCov">          1 :   layerinfo-&gt;endian = 0;</span>
<span class="lineNum">     119 </span><span class="lineCov">          1 :   layerinfo-&gt;rownum = 0;</span>
<span class="lineNum">     120 </span><span class="lineCov">          1 :   layerinfo-&gt;version = 0;</span>
<span class="lineNum">     121 </span><span class="lineCov">          1 :   layerinfo-&gt;paging = MS_TRUE;</span>
<span class="lineNum">     122 </span>            : #ifdef USE_POINT_Z_M
<span class="lineNum">     123 </span><span class="lineCov">          1 :   layerinfo-&gt;force2d = MS_FALSE;</span>
<span class="lineNum">     124 </span>            : #else
<span class="lineNum">     125 </span>            :   layerinfo-&gt;force2d = MS_TRUE;
<span class="lineNum">     126 </span>            : #endif
<span class="lineNum">     127 </span><span class="lineCov">          1 :   return layerinfo;</span>
<span class="lineNum">     128 </span>            : }
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            : /*
<a name="131"><span class="lineNum">     131 </span>            : ** msPostGISFreeLayerInfo()</a>
<span class="lineNum">     132 </span>            : */
<span class="lineNum">     133 </span><span class="lineCov">          1 : void msPostGISFreeLayerInfo(layerObj *layer)</span>
<span class="lineNum">     134 </span>            : {
<span class="lineNum">     135 </span>            :   msPostGISLayerInfo *layerinfo = NULL;
<span class="lineNum">     136 </span><span class="lineCov">          1 :   layerinfo = (msPostGISLayerInfo*)layer-&gt;layerinfo;</span>
<span class="lineNum">     137 </span><span class="lineCov">          1 :   if ( layerinfo-&gt;sql ) free(layerinfo-&gt;sql);</span>
<span class="lineNum">     138 </span><span class="lineCov">          1 :   if ( layerinfo-&gt;uid ) free(layerinfo-&gt;uid);</span>
<span class="lineNum">     139 </span><span class="lineCov">          1 :   if ( layerinfo-&gt;srid ) free(layerinfo-&gt;srid);</span>
<span class="lineNum">     140 </span><span class="lineCov">          1 :   if ( layerinfo-&gt;geomcolumn ) free(layerinfo-&gt;geomcolumn);</span>
<span class="lineNum">     141 </span><span class="lineCov">          1 :   if ( layerinfo-&gt;fromsource ) free(layerinfo-&gt;fromsource);</span>
<span class="lineNum">     142 </span><span class="lineCov">          1 :   if ( layerinfo-&gt;pgresult ) PQclear(layerinfo-&gt;pgresult);</span>
<span class="lineNum">     143 </span><span class="lineCov">          1 :   if ( layerinfo-&gt;pgconn ) msConnPoolRelease(layer, layerinfo-&gt;pgconn);</span>
<span class="lineNum">     144 </span><span class="lineCov">          1 :   free(layerinfo);</span>
<span class="lineNum">     145 </span><span class="lineCov">          1 :   layer-&gt;layerinfo = NULL;</span>
<span class="lineNum">     146 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            : /*
<span class="lineNum">     150 </span>            : ** postgresqlNoticeHandler()
<span class="lineNum">     151 </span>            : **
<span class="lineNum">     152 </span>            : ** Propagate messages from the database to the Mapserver log,
<a name="153"><span class="lineNum">     153 </span>            : ** set in PQsetNoticeProcessor during layer open.</a>
<span class="lineNum">     154 </span>            : */
<span class="lineNum">     155 </span><span class="lineNoCov">          0 : void postresqlNoticeHandler(void *arg, const char *message)</span>
<span class="lineNum">     156 </span>            : {
<span class="lineNum">     157 </span>            :   layerObj *lp;
<span class="lineNum">     158 </span>            :   lp = (layerObj*)arg;
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :   if (lp-&gt;debug) {</span>
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :     msDebug(&quot;%s\n&quot;, message);</span>
<span class="lineNum">     162 </span>            :   }
<span class="lineNum">     163 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : /*
<span class="lineNum">     167 </span>            : ** Expandable pointObj array. The lineObj unfortunately
<span class="lineNum">     168 </span>            : ** is not useful for this purpose, so we have this one.
<a name="169"><span class="lineNum">     169 </span>            : */</a>
<span class="lineNum">     170 </span>            : pointArrayObj*
<span class="lineNum">     171 </span><span class="lineNoCov">          0 : pointArrayNew(int maxpoints)</span>
<span class="lineNum">     172 </span>            : {
<span class="lineNum">     173 </span><span class="lineNoCov">          0 :   pointArrayObj *d = msSmallMalloc(sizeof(pointArrayObj));</span>
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   if ( maxpoints &lt; 1 ) maxpoints = 1; /* Avoid a degenerate case */</span>
<span class="lineNum">     175 </span><span class="lineNoCov">          0 :   d-&gt;maxpoints = maxpoints;</span>
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   d-&gt;data = msSmallMalloc(maxpoints * sizeof(pointObj));</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :   d-&gt;npoints = 0;</span>
<span class="lineNum">     178 </span><span class="lineNoCov">          0 :   return d;</span>
<span class="lineNum">     179 </span>            : }
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            : /*
<span class="lineNum">     182 </span>            : ** Utility function to creal up the pointArrayObj
<a name="183"><span class="lineNum">     183 </span>            : */</a>
<span class="lineNum">     184 </span>            : void
<span class="lineNum">     185 </span><span class="lineNoCov">          0 : pointArrayFree(pointArrayObj *d)</span>
<span class="lineNum">     186 </span>            : {
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   if ( ! d ) return;</span>
<span class="lineNum">     188 </span><span class="lineNoCov">          0 :   if ( d-&gt;data ) free(d-&gt;data);</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :   free(d);</span>
<span class="lineNum">     190 </span>            : }
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : /*
<span class="lineNum">     193 </span>            : ** Add a pointObj to the pointObjArray, allocating
<span class="lineNum">     194 </span>            : ** extra storage space if we've used up our existing
<span class="lineNum">     195 </span>            : ** buffer.
<a name="196"><span class="lineNum">     196 </span>            : */</a>
<span class="lineNum">     197 </span>            : static int
<span class="lineNum">     198 </span><span class="lineNoCov">          0 : pointArrayAddPoint(pointArrayObj *d, const pointObj *p)</span>
<span class="lineNum">     199 </span>            : {
<span class="lineNum">     200 </span><span class="lineNoCov">          0 :   if ( !p || !d ) return MS_FAILURE;</span>
<span class="lineNum">     201 </span>            :   /* Avoid overwriting memory buffer */
<span class="lineNum">     202 </span><span class="lineNoCov">          0 :   if ( d-&gt;maxpoints - d-&gt;npoints == 0 ) {</span>
<span class="lineNum">     203 </span><span class="lineNoCov">          0 :     d-&gt;maxpoints *= 2;</span>
<span class="lineNum">     204 </span><span class="lineNoCov">          0 :     d-&gt;data = realloc(d-&gt;data, d-&gt;maxpoints * sizeof(pointObj));</span>
<span class="lineNum">     205 </span>            :   }
<span class="lineNum">     206 </span><span class="lineNoCov">          0 :   d-&gt;data[d-&gt;npoints] = *p;</span>
<span class="lineNum">     207 </span><span class="lineNoCov">          0 :   d-&gt;npoints++;</span>
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :   return MS_SUCCESS;</span>
<span class="lineNum">     209 </span>            : }
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            : /*
<span class="lineNum">     212 </span>            : ** Pass an input type number through the PostGIS version
<span class="lineNum">     213 </span>            : ** type map array to handle the pre-2.0 incorrect WKB types
<span class="lineNum">     214 </span>            : */
<a name="215"><span class="lineNum">     215 </span>            : </a>
<span class="lineNum">     216 </span>            : static int
<span class="lineNum">     217 </span><span class="lineCov">          1 : wkbTypeMap(wkbObj *w, int type, int* pnZMFlag)</span>
<span class="lineNum">     218 </span>            : {
<span class="lineNum">     219 </span><span class="lineCov">          1 :   *pnZMFlag = 0;</span>
<span class="lineNum">     220 </span>            :   /* PostGIS &gt;= 2 : ISO SQL/MM style Z types ? */
<span class="lineNum">     221 </span><span class="lineCov">          1 :   if( type &gt;= 1000 &amp;&amp; type &lt; 2000 )</span>
<span class="lineNum">     222 </span>            :   {
<span class="lineNum">     223 </span><span class="lineCov">          1 :     type -= 1000;</span>
<span class="lineNum">     224 </span><span class="lineCov">          1 :     *pnZMFlag = HAS_Z;</span>
<span class="lineNum">     225 </span>            :   }
<span class="lineNum">     226 </span>            :   /* PostGIS &gt;= 2 : ISO SQL/MM style M types ? */
<span class="lineNum">     227 </span><span class="lineCov">          1 :   else if( type &gt;= 2000 &amp;&amp; type &lt; 3000 )</span>
<span class="lineNum">     228 </span>            :   {
<span class="lineNum">     229 </span><span class="lineNoCov">          0 :     type -= 2000;</span>
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :     *pnZMFlag = HAS_M;</span>
<span class="lineNum">     231 </span>            :   }
<span class="lineNum">     232 </span>            :   /* PostGIS &gt;= 2 : ISO SQL/MM style ZM types ? */
<span class="lineNum">     233 </span><span class="lineCov">          1 :   else if( type &gt;= 3000 &amp;&amp; type &lt; 4000 )</span>
<span class="lineNum">     234 </span>            :   {
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :     type -= 3000;</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :     *pnZMFlag = HAS_Z | HAS_M;</span>
<span class="lineNum">     237 </span>            :   }
<span class="lineNum">     238 </span>            :   /* PostGIS 1.X EWKB : Extended WKB Z or ZM ? */
<span class="lineNum">     239 </span><span class="lineCov">          1 :   else if( (type &amp; WKBZOFFSET_NONISO) != 0 )</span>
<span class="lineNum">     240 </span>            :   {
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :     if( (type &amp; WKBMOFFSET_NONISO) != 0 )</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :         *pnZMFlag = HAS_Z | HAS_M;</span>
<span class="lineNum">     243 </span>            :     else
<span class="lineNum">     244 </span><span class="lineNoCov">          0 :         *pnZMFlag = HAS_Z;</span>
<span class="lineNum">     245 </span><span class="lineNoCov">          0 :     type &amp;= 0x00FFFFFF;</span>
<span class="lineNum">     246 </span>            :   }
<span class="lineNum">     247 </span>            :   /* PostGIS 1.X EWKB: Extended WKB M ? */
<span class="lineNum">     248 </span><span class="lineCov">          1 :   else if( (type &amp; WKBMOFFSET_NONISO) != 0 )</span>
<span class="lineNum">     249 </span>            :   {
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :     *pnZMFlag = HAS_M;</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :     type &amp;= 0x00FFFFFF;</span>
<span class="lineNum">     252 </span>            :   }
<span class="lineNum">     253 </span><span class="lineCov">          1 :   if ( type &gt;= 0 &amp;&amp; type &lt; WKB_TYPE_COUNT )</span>
<span class="lineNum">     254 </span><span class="lineCov">          1 :     return w-&gt;typemap[type];</span>
<span class="lineNum">     255 </span>            :   else
<span class="lineNum">     256 </span>            :     return 0;
<span class="lineNum">     257 </span>            : }
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : /*
<span class="lineNum">     260 </span>            : ** Read the WKB type number from a wkbObj without
<span class="lineNum">     261 </span>            : ** advancing the read pointer.
<span class="lineNum">     262 </span>            : */
<span class="lineNum">     263 </span>            : static int
<span class="lineNum">     264 </span>            : wkbType(wkbObj *w, int* pnZMFlag)
<a name="265"><span class="lineNum">     265 </span>            : {</a>
<span class="lineNum">     266 </span>            :   int t;
<span class="lineNum">     267 </span><span class="lineCov">          1 :   memcpy(&amp;t, (w-&gt;ptr + 1), sizeof(int));</span>
<span class="lineNum">     268 </span><span class="lineCov">          1 :   return wkbTypeMap(w,t, pnZMFlag);</span>
<span class="lineNum">     269 </span>            : }
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            : /*
<span class="lineNum">     272 </span>            : ** Read the type number of the first element of a
<span class="lineNum">     273 </span>            : ** collection without advancing the read pointer.
<span class="lineNum">     274 </span>            : */
<span class="lineNum">     275 </span>            : static int
<span class="lineNum">     276 </span>            : wkbCollectionSubType(wkbObj *w, int* pnZMFlag)
<span class="lineNum">     277 </span>            : {
<span class="lineNum">     278 </span>            :   int t;
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :   memcpy(&amp;t, (w-&gt;ptr + 1 + 4 + 4 + 1), sizeof(int));</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :   return wkbTypeMap(w,t, pnZMFlag);</span>
<span class="lineNum">     281 </span>            : }
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            : /*
<span class="lineNum">     284 </span>            : ** Read one byte from the WKB and advance the read pointer
<span class="lineNum">     285 </span>            : */
<span class="lineNum">     286 </span>            : static char
<span class="lineNum">     287 </span>            : wkbReadChar(wkbObj *w)
<a name="288"><span class="lineNum">     288 </span>            : {</a>
<span class="lineNum">     289 </span>            :   char c;
<span class="lineNum">     290 </span><span class="lineCov">          1 :   memcpy(&amp;c, w-&gt;ptr, sizeof(char));</span>
<span class="lineNum">     291 </span><span class="lineCov">          1 :   w-&gt;ptr += sizeof(char);</span>
<span class="lineNum">     292 </span>            :   return c;
<span class="lineNum">     293 </span>            : }
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            : /*
<span class="lineNum">     296 </span>            : ** Read one integer from the WKB and advance the read pointer.
<span class="lineNum">     297 </span>            : ** We assume the endianess of the WKB is the same as this machine.
<span class="lineNum">     298 </span>            : */
<span class="lineNum">     299 </span>            : static inline int
<span class="lineNum">     300 </span>            : wkbReadInt(wkbObj *w)
<a name="301"><span class="lineNum">     301 </span>            : {</a>
<span class="lineNum">     302 </span>            :   int i;
<span class="lineNum">     303 </span><span class="lineCov">          1 :   memcpy(&amp;i, w-&gt;ptr, sizeof(int));</span>
<span class="lineNum">     304 </span><span class="lineCov">          1 :   w-&gt;ptr += sizeof(int);</span>
<span class="lineNum">     305 </span>            :   return i;
<span class="lineNum">     306 </span>            : }
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            : /*
<span class="lineNum">     309 </span>            : ** Read one double from the WKB and advance the read pointer.
<span class="lineNum">     310 </span>            : ** We assume the endianess of the WKB is the same as this machine.
<span class="lineNum">     311 </span>            : */
<span class="lineNum">     312 </span>            : static inline double
<span class="lineNum">     313 </span>            : wkbReadDouble(wkbObj *w)
<span class="lineNum">     314 </span>            : {
<span class="lineNum">     315 </span>            :   double d;
<span class="lineNum">     316 </span>            :   memcpy(&amp;d, w-&gt;ptr, sizeof(double));
<span class="lineNum">     317 </span>            :   w-&gt;ptr += sizeof(double);
<span class="lineNum">     318 </span>            :   return d;
<span class="lineNum">     319 </span>            : }
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            : /*
<span class="lineNum">     322 </span>            : ** Read one pointObj (two doubles) from the WKB and advance the read pointer.
<span class="lineNum">     323 </span>            : ** We assume the endianess of the WKB is the same as this machine.
<a name="324"><span class="lineNum">     324 </span>            : */</a>
<span class="lineNum">     325 </span>            : static inline void
<span class="lineNum">     326 </span><span class="lineCov">          1 : wkbReadPointP(wkbObj *w, pointObj *p, int nZMFlag)</span>
<span class="lineNum">     327 </span>            : {
<span class="lineNum">     328 </span><span class="lineCov">          1 :   memcpy(&amp;(p-&gt;x), w-&gt;ptr, sizeof(double));</span>
<span class="lineNum">     329 </span><span class="lineCov">          1 :   w-&gt;ptr += sizeof(double);</span>
<span class="lineNum">     330 </span><span class="lineCov">          1 :   memcpy(&amp;(p-&gt;y), w-&gt;ptr, sizeof(double));</span>
<span class="lineNum">     331 </span><span class="lineCov">          1 :   w-&gt;ptr += sizeof(double);</span>
<span class="lineNum">     332 </span><span class="lineCov">          1 :   if( nZMFlag &amp; HAS_Z )</span>
<span class="lineNum">     333 </span>            :   {
<span class="lineNum">     334 </span>            : #ifdef USE_POINT_Z_M
<span class="lineNum">     335 </span><span class="lineCov">          1 :       memcpy(&amp;(p-&gt;z), w-&gt;ptr, sizeof(double));</span>
<span class="lineNum">     336 </span>            : #endif
<span class="lineNum">     337 </span><span class="lineCov">          1 :       w-&gt;ptr += sizeof(double);</span>
<span class="lineNum">     338 </span>            :   }
<span class="lineNum">     339 </span>            : #ifdef USE_POINT_Z_M
<span class="lineNum">     340 </span>            :   else
<span class="lineNum">     341 </span>            :   {
<span class="lineNum">     342 </span><span class="lineCov">          1 :       p-&gt;z = 0;</span>
<span class="lineNum">     343 </span>            :   }
<span class="lineNum">     344 </span>            : #endif
<span class="lineNum">     345 </span><span class="lineCov">          1 :   if( nZMFlag &amp; HAS_M )</span>
<span class="lineNum">     346 </span>            :   {
<span class="lineNum">     347 </span>            : #ifdef USE_POINT_Z_M
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :       memcpy(&amp;(p-&gt;m), w-&gt;ptr, sizeof(double));</span>
<span class="lineNum">     349 </span>            : #endif
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :       w-&gt;ptr += sizeof(double);</span>
<span class="lineNum">     351 </span>            :   }
<span class="lineNum">     352 </span>            : #ifdef USE_POINT_Z_M
<span class="lineNum">     353 </span>            :   else
<span class="lineNum">     354 </span>            :   {
<span class="lineNum">     355 </span><span class="lineCov">          1 :       p-&gt;m = 0;</span>
<span class="lineNum">     356 </span>            :   }
<span class="lineNum">     357 </span>            : #endif
<span class="lineNum">     358 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            : /*
<span class="lineNum">     361 </span>            : ** Read one pointObj (two doubles) from the WKB and advance the read pointer.
<span class="lineNum">     362 </span>            : ** We assume the endianess of the WKB is the same as this machine.
<span class="lineNum">     363 </span>            : */
<span class="lineNum">     364 </span>            : static inline pointObj
<span class="lineNum">     365 </span>            : wkbReadPoint(wkbObj *w, int nZMFlag)
<span class="lineNum">     366 </span>            : {
<span class="lineNum">     367 </span>            :   pointObj p;
<span class="lineNum">     368 </span><span class="lineCov">          1 :   wkbReadPointP(w, &amp;p, nZMFlag);</span>
<span class="lineNum">     369 </span><span class="lineCov">          1 :   return p;</span>
<span class="lineNum">     370 </span>            : }
<span class="lineNum">     371 </span>            : 
<span class="lineNum">     372 </span>            : /*
<span class="lineNum">     373 </span>            : ** Read a &quot;point array&quot; and return an allocated lineObj.
<span class="lineNum">     374 </span>            : ** A point array is a WKB fragment that starts with a
<span class="lineNum">     375 </span>            : ** point count, which is followed by that number of doubles * 2.
<span class="lineNum">     376 </span>            : ** Linestrings, circular strings, polygon rings, all show this
<span class="lineNum">     377 </span>            : ** form.
<span class="lineNum">     378 </span>            : */
<span class="lineNum">     379 </span>            : static void
<span class="lineNum">     380 </span><span class="lineCov">          1 : wkbReadLine(wkbObj *w, lineObj *line, int nZMFlag)</span>
<span class="lineNum">     381 </span>            : {
<span class="lineNum">     382 </span>            :   int i;
<span class="lineNum">     383 </span>            :   pointObj p;
<span class="lineNum">     384 </span>            :   int npoints = wkbReadInt(w);
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span><span class="lineCov">          1 :   line-&gt;numpoints = npoints;</span>
<span class="lineNum">     387 </span><span class="lineCov">          1 :   line-&gt;point = msSmallMalloc(npoints * sizeof(pointObj));</span>
<span class="lineNum">     388 </span><span class="lineCov">          1 :   for ( i = 0; i &lt; npoints; i++ ) {</span>
<span class="lineNum">     389 </span><span class="lineCov">          1 :     wkbReadPointP(w, &amp;p, nZMFlag);</span>
<span class="lineNum">     390 </span><span class="lineCov">          1 :     line-&gt;point[i] = p;</span>
<span class="lineNum">     391 </span>            :   }
<span class="lineNum">     392 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span>            : /*
<span class="lineNum">     395 </span>            : ** Advance the read pointer past a geometry without returning any
<span class="lineNum">     396 </span>            : ** values. Used for skipping un-drawable elements in a collection.
<span class="lineNum">     397 </span>            : */
<span class="lineNum">     398 </span>            : static void
<span class="lineNum">     399 </span><span class="lineNoCov">          0 : wkbSkipGeometry(wkbObj *w)</span>
<span class="lineNum">     400 </span>            : {
<span class="lineNum">     401 </span>            :   int type, npoints, nrings, ngeoms, i;
<span class="lineNum">     402 </span>            :   int nZMFlag;
<span class="lineNum">     403 </span>            :   int nCoordDim;
<span class="lineNum">     404 </span>            :   /*endian = */wkbReadChar(w);
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   type = wkbTypeMap(w,wkbReadInt(w), &amp;nZMFlag);</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :   nCoordDim = 2 + (((nZMFlag &amp; HAS_Z) != 0) ? 1 : 0) + (((nZMFlag &amp; HAS_M) != 0) ? 1 : 0);</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   switch(type) {</span>
<span class="lineNum">     408 </span>            :     case WKB_POINT:
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :       w-&gt;ptr += nCoordDim * sizeof(double);</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     411 </span>            :     case WKB_CIRCULARSTRING:
<span class="lineNum">     412 </span>            :     case WKB_LINESTRING:
<span class="lineNum">     413 </span>            :       npoints = wkbReadInt(w);
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :       w-&gt;ptr += npoints * nCoordDim * sizeof(double);</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     416 </span>            :     case WKB_POLYGON:
<span class="lineNum">     417 </span>            :       nrings = wkbReadInt(w);
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :       for ( i = 0; i &lt; nrings; i++ ) {</span>
<span class="lineNum">     419 </span>            :         npoints = wkbReadInt(w);
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :         w-&gt;ptr += npoints * nCoordDim * sizeof(double);</span>
<span class="lineNum">     421 </span>            :       }
<span class="lineNum">     422 </span>            :       break;
<span class="lineNum">     423 </span>            :     case WKB_MULTIPOINT:
<span class="lineNum">     424 </span>            :     case WKB_MULTILINESTRING:
<span class="lineNum">     425 </span>            :     case WKB_MULTIPOLYGON:
<span class="lineNum">     426 </span>            :     case WKB_GEOMETRYCOLLECTION:
<span class="lineNum">     427 </span>            :     case WKB_COMPOUNDCURVE:
<span class="lineNum">     428 </span>            :     case WKB_CURVEPOLYGON:
<span class="lineNum">     429 </span>            :     case WKB_MULTICURVE:
<span class="lineNum">     430 </span>            :     case WKB_MULTISURFACE:
<span class="lineNum">     431 </span>            :       ngeoms = wkbReadInt(w);
<span class="lineNum">     432 </span><span class="lineNoCov">          0 :       for ( i = 0; i &lt; ngeoms; i++ ) {</span>
<span class="lineNum">     433 </span><span class="lineNoCov">          0 :         wkbSkipGeometry(w);</span>
<span class="lineNum">     434 </span>            :       }
<span class="lineNum">     435 </span>            :   }
<span class="lineNum">     436 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            : /*
<span class="lineNum">     439 </span>            : ** Convert a WKB point to a shapeObj, advancing the read pointer as we go.
<span class="lineNum">     440 </span>            : */
<span class="lineNum">     441 </span>            : static int
<span class="lineNum">     442 </span><span class="lineCov">          1 : wkbConvPointToShape(wkbObj *w, shapeObj *shape)</span>
<span class="lineNum">     443 </span>            : {
<span class="lineNum">     444 </span>            :   int type;
<span class="lineNum">     445 </span>            :   lineObj line;
<span class="lineNum">     446 </span>            :   int nZMFlag;
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            :   /*endian = */wkbReadChar(w);
<span class="lineNum">     449 </span><span class="lineCov">          1 :   type = wkbTypeMap(w,wkbReadInt(w),&amp;nZMFlag);</span>
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span><span class="lineCov">          1 :   if( type != WKB_POINT ) return MS_FAILURE;</span>
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span><span class="lineCov">          1 :   if( ! (shape-&gt;type == MS_SHAPE_POINT) ) return MS_FAILURE;</span>
<span class="lineNum">     454 </span><span class="lineCov">          1 :   line.numpoints = 1;</span>
<span class="lineNum">     455 </span><span class="lineCov">          1 :   line.point = msSmallMalloc(sizeof(pointObj));</span>
<span class="lineNum">     456 </span><span class="lineCov">          1 :   line.point[0] = wkbReadPoint(w, nZMFlag);</span>
<span class="lineNum">     457 </span><span class="lineCov">          1 :   msAddLineDirectly(shape, &amp;line);</span>
<span class="lineNum">     458 </span><span class="lineCov">          1 :   return MS_SUCCESS;</span>
<span class="lineNum">     459 </span>            : }
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            : /*
<span class="lineNum">     462 </span>            : ** Convert a WKB line string to a shapeObj, advancing the read pointer as we go.
<span class="lineNum">     463 </span>            : */
<span class="lineNum">     464 </span>            : static int
<span class="lineNum">     465 </span><span class="lineCov">          1 : wkbConvLineStringToShape(wkbObj *w, shapeObj *shape)</span>
<span class="lineNum">     466 </span>            : {
<span class="lineNum">     467 </span>            :   int type;
<span class="lineNum">     468 </span>            :   lineObj line;
<span class="lineNum">     469 </span>            :   int nZMFlag;
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            :   /*endian = */wkbReadChar(w);
<span class="lineNum">     472 </span><span class="lineCov">          1 :   type = wkbTypeMap(w,wkbReadInt(w), &amp;nZMFlag);</span>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span><span class="lineCov">          1 :   if( type != WKB_LINESTRING ) return MS_FAILURE;</span>
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span><span class="lineCov">          1 :   wkbReadLine(w,&amp;line, nZMFlag);</span>
<span class="lineNum">     477 </span><span class="lineCov">          1 :   msAddLineDirectly(shape, &amp;line);</span>
<span class="lineNum">     478 </span>            : 
<span class="lineNum">     479 </span><span class="lineCov">          1 :   return MS_SUCCESS;</span>
<span class="lineNum">     480 </span>            : }
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            : /*
<span class="lineNum">     483 </span>            : ** Convert a WKB polygon to a shapeObj, advancing the read pointer as we go.
<span class="lineNum">     484 </span>            : */
<span class="lineNum">     485 </span>            : static int
<span class="lineNum">     486 </span><span class="lineCov">          1 : wkbConvPolygonToShape(wkbObj *w, shapeObj *shape)</span>
<span class="lineNum">     487 </span>            : {
<span class="lineNum">     488 </span>            :   int type;
<span class="lineNum">     489 </span>            :   int i, nrings;
<span class="lineNum">     490 </span>            :   lineObj line;
<span class="lineNum">     491 </span>            :   int nZMFlag;
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            :   /*endian = */wkbReadChar(w);
<span class="lineNum">     494 </span><span class="lineCov">          1 :   type = wkbTypeMap(w,wkbReadInt(w), &amp;nZMFlag);</span>
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span><span class="lineCov">          1 :   if( type != WKB_POLYGON ) return MS_FAILURE;</span>
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            :   /* How many rings? */
<span class="lineNum">     499 </span>            :   nrings = wkbReadInt(w);
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            :   /* Add each ring to the shape */
<span class="lineNum">     502 </span><span class="lineCov">          1 :   for( i = 0; i &lt; nrings; i++ ) {</span>
<span class="lineNum">     503 </span><span class="lineCov">          1 :     wkbReadLine(w,&amp;line, nZMFlag);</span>
<span class="lineNum">     504 </span><span class="lineCov">          1 :     msAddLineDirectly(shape, &amp;line);</span>
<span class="lineNum">     505 </span>            :   }
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            :   return MS_SUCCESS;
<span class="lineNum">     508 </span>            : }
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span>            : /*
<span class="lineNum">     511 </span>            : ** Convert a WKB curve polygon to a shapeObj, advancing the read pointer as we go.
<span class="lineNum">     512 </span>            : ** The arc portions of the rings will be stroked to linestrings as they
<span class="lineNum">     513 </span>            : ** are read by the underlying circular string handling.
<span class="lineNum">     514 </span>            : */
<span class="lineNum">     515 </span>            : static int
<span class="lineNum">     516 </span><span class="lineNoCov">          0 : wkbConvCurvePolygonToShape(wkbObj *w, shapeObj *shape)</span>
<span class="lineNum">     517 </span>            : {
<span class="lineNum">     518 </span>            :   int type, i, ncomponents;
<span class="lineNum">     519 </span>            :   int failures = 0;
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :   int was_poly = ( shape-&gt;type == MS_SHAPE_POLYGON );</span>
<span class="lineNum">     521 </span>            :   int nZMFlag;
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            :   /*endian = */wkbReadChar(w);
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :   type = wkbTypeMap(w,wkbReadInt(w), &amp;nZMFlag);</span>
<span class="lineNum">     525 </span>            :   ncomponents = wkbReadInt(w);
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :   if( type != WKB_CURVEPOLYGON ) return MS_FAILURE;</span>
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span>            :   /* Lower the allowed dimensionality so we can
<span class="lineNum">     530 </span>            :   *  catch the linear ring components */
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :   shape-&gt;type = MS_SHAPE_LINE;</span>
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :   for ( i = 0; i &lt; ncomponents; i++ ) {</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :     if ( wkbConvGeometryToShape(w, shape) == MS_FAILURE ) {</span>
<span class="lineNum">     535 </span><span class="lineNoCov">          0 :       wkbSkipGeometry(w);</span>
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :       failures++;</span>
<span class="lineNum">     537 </span>            :     }
<span class="lineNum">     538 </span>            :   }
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            :   /* Go back to expected dimensionality */
<span class="lineNum">     541 </span><span class="lineNoCov">          0 :   if ( was_poly) shape-&gt;type = MS_SHAPE_POLYGON;</span>
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :   if ( failures == ncomponents )</span>
<span class="lineNum">     544 </span>            :     return MS_FAILURE;
<span class="lineNum">     545 </span>            :   else
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :     return MS_SUCCESS;</span>
<span class="lineNum">     547 </span>            : }
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            : /*
<span class="lineNum">     550 </span>            : ** Convert a WKB circular string to a shapeObj, advancing the read pointer as we go.
<span class="lineNum">     551 </span>            : ** Arcs will be stroked to linestrings.
<span class="lineNum">     552 </span>            : */
<span class="lineNum">     553 </span>            : static int
<span class="lineNum">     554 </span><span class="lineNoCov">          0 : wkbConvCircularStringToShape(wkbObj *w, shapeObj *shape)</span>
<span class="lineNum">     555 </span>            : {
<span class="lineNum">     556 </span>            :   int type;
<span class="lineNum">     557 </span>            :   int nZMFlag;
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :   lineObj line = {0, NULL};</span>
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            :   /*endian = */wkbReadChar(w);
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :   type = wkbTypeMap(w,wkbReadInt(w), &amp;nZMFlag);</span>
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :   if( type != WKB_CIRCULARSTRING ) return MS_FAILURE;</span>
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span>            :   /* Stroke the string into a point array */
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :   if ( arcStrokeCircularString(w, SEGMENT_ANGLE, &amp;line, nZMFlag) == MS_FAILURE ) {</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :     if(line.point) free(line.point);</span>
<span class="lineNum">     568 </span>            :     return MS_FAILURE;
<span class="lineNum">     569 </span>            :   }
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            :   /* Fill in the lineObj */
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :   if ( line.numpoints &gt; 0 ) {</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :     msAddLine(shape, &amp;line);</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :     if(line.point) free(line.point);</span>
<span class="lineNum">     575 </span>            :   }
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            :   return MS_SUCCESS;
<span class="lineNum">     578 </span>            : }
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span>            : /*
<span class="lineNum">     581 </span>            : ** Compound curves need special handling. First we load
<span class="lineNum">     582 </span>            : ** each component of the curve on the a lineObj in a shape.
<span class="lineNum">     583 </span>            : ** Then we merge those lineObjs into a single lineObj. This
<span class="lineNum">     584 </span>            : ** allows compound curves to serve as closed rings in
<span class="lineNum">     585 </span>            : ** curve polygons.
<span class="lineNum">     586 </span>            : */
<span class="lineNum">     587 </span>            : static int
<span class="lineNum">     588 </span><span class="lineNoCov">          0 : wkbConvCompoundCurveToShape(wkbObj *w, shapeObj *shape)</span>
<span class="lineNum">     589 </span>            : {
<span class="lineNum">     590 </span>            :   int npoints = 0;
<span class="lineNum">     591 </span>            :   int type, ncomponents, i, j;
<span class="lineNum">     592 </span>            :   lineObj line;
<span class="lineNum">     593 </span>            :   shapeObj shapebuf;
<span class="lineNum">     594 </span>            :   int nZMFlag;
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span>            :   /*endian = */wkbReadChar(w);
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :   type = wkbTypeMap(w,wkbReadInt(w), &amp;nZMFlag);</span>
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span>            :   /* Init our shape buffer */
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :   msInitShape(&amp;shapebuf);</span>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span><span class="lineNoCov">          0 :   if( type != WKB_COMPOUNDCURVE ) return MS_FAILURE;</span>
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span>            :   /* How many components in the compound curve? */
<span class="lineNum">     605 </span>            :   ncomponents = wkbReadInt(w);
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span>            :   /* We'll load each component onto a line in a shape */
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :   for( i = 0; i &lt; ncomponents; i++ )</span>
<span class="lineNum">     609 </span><span class="lineNoCov">          0 :     wkbConvGeometryToShape(w, &amp;shapebuf);</span>
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            :   /* Do nothing on empty */
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :   if ( shapebuf.numlines == 0 )</span>
<span class="lineNum">     613 </span>            :     return MS_FAILURE;
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span>            :   /* Count the total number of points */
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :   for( i = 0; i &lt; shapebuf.numlines; i++ )</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :     npoints += shapebuf.line[i].numpoints;</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            :   /* Do nothing on empty */
<span class="lineNum">     620 </span><span class="lineNoCov">          0 :   if ( npoints == 0 )</span>
<span class="lineNum">     621 </span>            :     return MS_FAILURE;
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   line.numpoints = npoints;</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :   line.point = msSmallMalloc(sizeof(pointObj) * npoints);</span>
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            :   /* Copy in the points */
<span class="lineNum">     627 </span>            :   npoints = 0;
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :   for ( i = 0; i &lt; shapebuf.numlines; i++ ) {</span>
<span class="lineNum">     629 </span><span class="lineNoCov">          0 :     for ( j = 0; j &lt; shapebuf.line[i].numpoints; j++ ) {</span>
<span class="lineNum">     630 </span>            :       /* Don't add a start point that duplicates an endpoint */
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :       if( j == 0 &amp;&amp; i &gt; 0 &amp;&amp;</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :           memcmp(&amp;(line.point[npoints - 1]),&amp;(shapebuf.line[i].point[j]),sizeof(pointObj)) == 0 ) {</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     634 </span>            :       }
<span class="lineNum">     635 </span><span class="lineNoCov">          0 :       line.point[npoints++] = shapebuf.line[i].point[j];</span>
<span class="lineNum">     636 </span>            :     }
<span class="lineNum">     637 </span>            :   }
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :   line.numpoints = npoints;</span>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            :   /* Clean up */
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :   msFreeShape(&amp;shapebuf);</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            :   /* Fill in the lineObj */
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :   msAddLineDirectly(shape, &amp;line);</span>
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :   return MS_SUCCESS;</span>
<span class="lineNum">     647 </span>            : }
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span>            : /*
<span class="lineNum">     650 </span>            : ** Convert a WKB collection string to a shapeObj, advancing the read pointer as we go.
<span class="lineNum">     651 </span>            : ** Many WKB types (MultiPoint, MultiLineString, MultiPolygon, MultiSurface,
<span class="lineNum">     652 </span>            : ** MultiCurve, GeometryCollection) can be treated identically as collections
<span class="lineNum">     653 </span>            : ** (they start with endian, type number and count of sub-elements, then provide the
<span class="lineNum">     654 </span>            : ** subelements as WKB) so are handled with this one function.
<span class="lineNum">     655 </span>            : */
<span class="lineNum">     656 </span>            : static int
<span class="lineNum">     657 </span><span class="lineCov">          1 : wkbConvCollectionToShape(wkbObj *w, shapeObj *shape)</span>
<span class="lineNum">     658 </span>            : {
<span class="lineNum">     659 </span>            :   int i, ncomponents;
<span class="lineNum">     660 </span>            :   int failures = 0;
<span class="lineNum">     661 </span>            :   int nZMFlag;
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span>            :   /*endian = */wkbReadChar(w);
<span class="lineNum">     664 </span><span class="lineCov">          1 :   /*type = */wkbTypeMap(w,wkbReadInt(w), &amp;nZMFlag);</span>
<span class="lineNum">     665 </span>            :   ncomponents = wkbReadInt(w);
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            :   /*
<span class="lineNum">     668 </span>            :   * If we can draw any portion of the collection, we will,
<span class="lineNum">     669 </span>            :   * but if all the components fail, we will draw nothing.
<span class="lineNum">     670 </span>            :   */
<span class="lineNum">     671 </span><span class="lineCov">          1 :   for ( i = 0; i &lt; ncomponents; i++ ) {</span>
<span class="lineNum">     672 </span><span class="lineCov">          1 :     if ( wkbConvGeometryToShape(w, shape) == MS_FAILURE ) {</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :       wkbSkipGeometry(w);</span>
<span class="lineNum">     674 </span><span class="lineNoCov">          0 :       failures++;</span>
<span class="lineNum">     675 </span>            :     }
<span class="lineNum">     676 </span>            :   }
<span class="lineNum">     677 </span><span class="lineCov">          1 :   if ( failures == ncomponents || ncomponents == 0)</span>
<span class="lineNum">     678 </span>            :     return MS_FAILURE;
<span class="lineNum">     679 </span>            :   else
<span class="lineNum">     680 </span><span class="lineCov">          1 :     return MS_SUCCESS;</span>
<span class="lineNum">     681 </span>            : }
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            : /*
<span class="lineNum">     684 </span>            : ** Generic handler to switch to the appropriate function for the WKB type.
<span class="lineNum">     685 </span>            : ** Note that we also handle switching here to avoid processing shapes
<span class="lineNum">     686 </span>            : ** we will be unable to draw. Example: we can't draw point features as
<span class="lineNum">     687 </span>            : ** a MS_SHAPE_LINE layer, so if the type is WKB_POINT and the layer is
<span class="lineNum">     688 </span>            : ** MS_SHAPE_LINE, we exit before converting.
<span class="lineNum">     689 </span>            : */
<span class="lineNum">     690 </span>            : int
<span class="lineNum">     691 </span><span class="lineCov">          1 : wkbConvGeometryToShape(wkbObj *w, shapeObj *shape)</span>
<span class="lineNum">     692 </span>            : {
<span class="lineNum">     693 </span>            :   int nZMFlag;
<span class="lineNum">     694 </span>            :   int wkbtype = wkbType(w, &amp;nZMFlag); /* Peak at the type number */
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span><span class="lineCov">          1 :   switch(wkbtype) {</span>
<span class="lineNum">     697 </span>            :       /* Recurse into anonymous collections */
<span class="lineNum">     698 </span>            :     case WKB_GEOMETRYCOLLECTION:
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :       return wkbConvCollectionToShape(w, shape);</span>
<span class="lineNum">     700 </span>            :       /* Handle area types */
<span class="lineNum">     701 </span>            :     case WKB_POLYGON:
<span class="lineNum">     702 </span><span class="lineCov">          1 :       return wkbConvPolygonToShape(w, shape);</span>
<span class="lineNum">     703 </span>            :     case WKB_MULTIPOLYGON:
<span class="lineNum">     704 </span><span class="lineCov">          1 :       return wkbConvCollectionToShape(w, shape);</span>
<span class="lineNum">     705 </span>            :     case WKB_CURVEPOLYGON:
<span class="lineNum">     706 </span><span class="lineNoCov">          0 :       return wkbConvCurvePolygonToShape(w, shape);</span>
<span class="lineNum">     707 </span>            :     case WKB_MULTISURFACE:
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :       return wkbConvCollectionToShape(w, shape);</span>
<span class="lineNum">     709 </span>            :   }
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span>            :   /* We can't convert any of the following types into polygons */
<span class="lineNum">     712 </span><span class="lineCov">          1 :   if ( shape-&gt;type == MS_SHAPE_POLYGON ) return MS_FAILURE;</span>
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span>            :   /* Handle linear types */
<span class="lineNum">     715 </span><span class="lineCov">          1 :   switch(wkbtype) {</span>
<span class="lineNum">     716 </span>            :     case WKB_LINESTRING:
<span class="lineNum">     717 </span><span class="lineCov">          1 :       return wkbConvLineStringToShape(w, shape);</span>
<span class="lineNum">     718 </span>            :     case WKB_CIRCULARSTRING:
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :       return wkbConvCircularStringToShape(w, shape);</span>
<span class="lineNum">     720 </span>            :     case WKB_COMPOUNDCURVE:
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :       return wkbConvCompoundCurveToShape(w, shape);</span>
<span class="lineNum">     722 </span>            :     case WKB_MULTILINESTRING:
<span class="lineNum">     723 </span><span class="lineCov">          1 :       return wkbConvCollectionToShape(w, shape);</span>
<span class="lineNum">     724 </span>            :     case WKB_MULTICURVE:
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :       return wkbConvCollectionToShape(w, shape);</span>
<span class="lineNum">     726 </span>            :   }
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span>            :   /* We can't convert any of the following types into lines */
<span class="lineNum">     729 </span><span class="lineCov">          1 :   if ( shape-&gt;type == MS_SHAPE_LINE ) return MS_FAILURE;</span>
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            :   /* Handle point types */
<span class="lineNum">     732 </span><span class="lineCov">          1 :   switch(wkbtype) {</span>
<span class="lineNum">     733 </span>            :     case WKB_POINT:
<span class="lineNum">     734 </span><span class="lineCov">          1 :       return wkbConvPointToShape(w, shape);</span>
<span class="lineNum">     735 </span>            :     case WKB_MULTIPOINT:
<span class="lineNum">     736 </span><span class="lineCov">          1 :       return wkbConvCollectionToShape(w, shape);</span>
<span class="lineNum">     737 </span>            :   }
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            :   /* This is a WKB type we don't know about! */
<span class="lineNum">     740 </span>            :   return MS_FAILURE;
<span class="lineNum">     741 </span>            : }
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span>            : /*
<span class="lineNum">     745 </span>            : ** Calculate determinant of a 3x3 matrix. Handy for
<span class="lineNum">     746 </span>            : ** the circle center calculation.
<span class="lineNum">     747 </span>            : */
<span class="lineNum">     748 </span>            : static inline double
<span class="lineNum">     749 </span>            : arcDeterminant3x3(double *m)
<span class="lineNum">     750 </span>            : {
<span class="lineNum">     751 </span>            :   /* This had better be a 3x3 matrix or we'll fall to bits */
<span class="lineNum">     752 </span>            :   return m[0] * ( m[4] * m[8] - m[7] * m[5] ) -
<span class="lineNum">     753 </span>            :          m[3] * ( m[1] * m[8] - m[7] * m[2] ) +
<span class="lineNum">     754 </span>            :          m[6] * ( m[1] * m[5] - m[4] * m[2] );
<span class="lineNum">     755 </span>            : }
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span>            : /*
<span class="lineNum">     758 </span>            : ** What side of p1-&gt;p2 is q on?
<span class="lineNum">     759 </span>            : */
<span class="lineNum">     760 </span>            : static inline int
<a name="761"><span class="lineNum">     761 </span>            : arcSegmentSide(const pointObj *p1, const pointObj *p2, const pointObj *q)</a>
<span class="lineNum">     762 </span>            : {
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :   double side = ( (q-&gt;x - p1-&gt;x) * (p2-&gt;y - p1-&gt;y) - (p2-&gt;x - p1-&gt;x) * (q-&gt;y - p1-&gt;y) );</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :   if ( FP_EQ(side,0.0) ) {</span>
<span class="lineNum">     765 </span>            :     return FP_COLINEAR;
<span class="lineNum">     766 </span>            :   } else {
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :     if ( side &lt; 0.0 )</span>
<span class="lineNum">     768 </span>            :       return FP_LEFT;
<span class="lineNum">     769 </span>            :     else
<span class="lineNum">     770 </span>            :       return FP_RIGHT;
<span class="lineNum">     771 </span>            :   }
<span class="lineNum">     772 </span>            : }
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            : /*
<span class="lineNum">     775 </span>            : ** Calculate the center of the circle defined by three points.
<span class="lineNum">     776 </span>            : ** Using matrix approach from http://mathforum.org/library/drmath/view/55239.html
<span class="lineNum">     777 </span>            : */
<span class="lineNum">     778 </span>            : int
<span class="lineNum">     779 </span><span class="lineNoCov">          0 : arcCircleCenter(const pointObj *p1, const pointObj *p2, const pointObj *p3, pointObj *center, double *radius)</span>
<span class="lineNum">     780 </span>            : {
<span class="lineNum">     781 </span>            :   pointObj c;
<span class="lineNum">     782 </span>            :   double dx21, dy21, dx31, dy31, h21, h31, d, r;
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span>            :   /* Circle is closed, so p2 must be opposite p1 &amp; p3. */
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :   if ((fabs(p1-&gt;x - p3-&gt;x) &lt; FP_EPSILON) &amp;&amp; (fabs(p1-&gt;y-p3-&gt;y) &lt; FP_EPSILON)) {</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :     c.x = p1-&gt;x + (p2-&gt;x - p1-&gt;x) / 2.0;</span>
<span class="lineNum">     787 </span><span class="lineNoCov">          0 :     c.y = p1-&gt;y + (p2-&gt;y - p1-&gt;y) / 2.0;</span>
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :     r = sqrt(pow(c.x - p1-&gt;x, 2.0) + pow(c.y - p1-&gt;y, 2.0));</span>
<span class="lineNum">     789 </span>            :   }
<span class="lineNum">     790 </span>            :   /* There is no circle here, the points are actually co-linear */
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :   else if ( arcSegmentSide(p1, p3, p2) == FP_COLINEAR ) {</span>
<span class="lineNum">     792 </span>            :     return MS_FAILURE;
<span class="lineNum">     793 </span>            :   }
<span class="lineNum">     794 </span>            :   /* Calculate the center and radius. */
<span class="lineNum">     795 </span>            :   else {
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            :     /* Radius */
<span class="lineNum">     798 </span>            :     dx21 = p2-&gt;x - p1-&gt;x;
<span class="lineNum">     799 </span>            :     dy21 = p2-&gt;y - p1-&gt;y;
<span class="lineNum">     800 </span>            :     dx31 = p3-&gt;x - p1-&gt;x;
<span class="lineNum">     801 </span>            :     dy31 = p3-&gt;y - p1-&gt;y;
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :     h21 = pow(dx21, 2.0) + pow(dy21, 2.0);</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :     h31 = pow(dx31, 2.0) + pow(dy31, 2.0);</span>
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span>            :     /* 2 * |Cross product|, d&lt;0 means clockwise and d&gt;0 counterclockwise sweeping angle */
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     d = 2 * (dx21 * dy31 - dx31 * dy21);</span>
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :     c.x = p1-&gt;x + (h21 * dy31 - h31 * dy21) / d;</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     c.y = p1-&gt;y - (h21 * dx31 - h31 * dx21) / d;</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     r = sqrt(pow(c.x - p1-&gt;x, 2) + pow(c.y - p1-&gt;y, 2));</span>
<span class="lineNum">     812 </span>            :   }
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :   if ( radius ) *radius = r;</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :   if ( center ) *center = c;</span>
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            :   return MS_SUCCESS;
<span class="lineNum">     818 </span>            : }
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            : /*
<span class="lineNum">     821 </span>            : ** Write a stroked version of the circle defined by three points into a
<span class="lineNum">     822 </span>            : ** point buffer. The segment_angle (degrees) is the coverage of each stroke segment,
<span class="lineNum">     823 </span>            : ** and depending on whether this is the first arc in a circularstring,
<span class="lineNum">     824 </span>            : ** you might want to include_first
<span class="lineNum">     825 </span>            : */
<span class="lineNum">     826 </span>            : int
<span class="lineNum">     827 </span><span class="lineNoCov">          0 : arcStrokeCircle(const pointObj *p1, const pointObj *p2, const pointObj *p3,</span>
<span class="lineNum">     828 </span>            :                 double segment_angle, int include_first, pointArrayObj *pa)
<span class="lineNum">     829 </span>            : {
<span class="lineNum">     830 </span>            :   pointObj center; /* Center of our circular arc */
<span class="lineNum">     831 </span>            :   double radius; /* Radius of our circular arc */
<span class="lineNum">     832 </span>            :   double sweep_angle_r; /* Total angular size of our circular arc in radians */
<span class="lineNum">     833 </span>            :   double segment_angle_r; /* Segment angle in radians */
<span class="lineNum">     834 </span>            :   double a1, /*a2,*/ a3; /* Angles represented by p1, p2, p3 relative to center */
<span class="lineNum">     835 </span>            :   int side = arcSegmentSide(p1, p3, p2); /* What side of p1,p3 is the middle point? */
<span class="lineNum">     836 </span>            :   int num_edges; /* How many edges we will be generating */
<span class="lineNum">     837 </span>            :   double current_angle_r; /* What angle are we generating now (radians)? */
<span class="lineNum">     838 </span>            :   int i; /* Counter */
<span class="lineNum">     839 </span>            :   pointObj p; /* Temporary point */
<span class="lineNum">     840 </span>            :   int is_closed = MS_FALSE;
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            :   /* We need to know if we're dealing with a circle early */
<span class="lineNum">     843 </span><span class="lineNoCov">          0 :   if ( FP_EQ(p1-&gt;x, p3-&gt;x) &amp;&amp; FP_EQ(p1-&gt;y, p3-&gt;y) )</span>
<span class="lineNum">     844 </span>            :     is_closed = MS_TRUE;
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            :   /* Check if the &quot;arc&quot; is actually straight */
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :   if ( ! is_closed &amp;&amp; side == FP_COLINEAR ) {</span>
<span class="lineNum">     848 </span>            :     /* We just need to write in the end points */
<span class="lineNum">     849 </span><span class="lineNoCov">          0 :     if ( include_first )</span>
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :       pointArrayAddPoint(pa, p1);</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :     pointArrayAddPoint(pa, p3);</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :     return MS_SUCCESS;</span>
<span class="lineNum">     853 </span>            :   }
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            :   /* We should always be able to find the center of a non-linear arc */
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :   if ( arcCircleCenter(p1, p2, p3, &amp;center, &amp;radius) == MS_FAILURE )</span>
<span class="lineNum">     857 </span>            :     return MS_FAILURE;
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span>            :   /* Calculate the angles that our three points represent */
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :   a1 = atan2(p1-&gt;y - center.y, p1-&gt;x - center.x);</span>
<span class="lineNum">     861 </span>            :   /* UNUSED
<span class="lineNum">     862 </span>            :   a2 = atan2(p2-&gt;y - center.y, p2-&gt;x - center.x);
<span class="lineNum">     863 </span>            :    */
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :   a3 = atan2(p3-&gt;y - center.y, p3-&gt;x - center.x);</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :   segment_angle_r = M_PI * segment_angle / 180.0;</span>
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span>            :   /* Closed-circle case, we sweep the whole circle! */
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :   if ( is_closed ) {</span>
<span class="lineNum">     869 </span>            :     sweep_angle_r = 2.0 * M_PI;
<span class="lineNum">     870 </span>            :   }
<span class="lineNum">     871 </span>            :   /* Clockwise sweep direction */
<span class="lineNum">     872 </span><span class="lineNoCov">          0 :   else if ( side == FP_LEFT ) {</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :     if ( a3 &gt; a1 ) /* Wrapping past 180? */</span>
<span class="lineNum">     874 </span><span class="lineNoCov">          0 :       sweep_angle_r = a1 + (2.0 * M_PI - a3);</span>
<span class="lineNum">     875 </span>            :     else
<span class="lineNum">     876 </span><span class="lineNoCov">          0 :       sweep_angle_r = a1 - a3;</span>
<span class="lineNum">     877 </span>            :   }
<span class="lineNum">     878 </span>            :   /* Counter-clockwise sweep direction */
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :   else if ( side == FP_RIGHT ) {</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :     if ( a3 &gt; a1 ) /* Wrapping past 180? */</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :       sweep_angle_r = a3 - a1;</span>
<span class="lineNum">     882 </span>            :     else
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :       sweep_angle_r = a3 + (2.0 * M_PI - a1);</span>
<span class="lineNum">     884 </span>            :   } else
<span class="lineNum">     885 </span>            :     sweep_angle_r = 0.0;
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span>            :   /* We don't have enough resolution, let's invert our strategy. */
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :   if ( (sweep_angle_r / segment_angle_r) &lt; SEGMENT_MINPOINTS ) {</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :     segment_angle_r = sweep_angle_r / (SEGMENT_MINPOINTS + 1);</span>
<span class="lineNum">     890 </span>            :   }
<span class="lineNum">     891 </span>            : 
<span class="lineNum">     892 </span>            :   /* We don't have enough resolution to stroke this arc,
<span class="lineNum">     893 </span>            :   *  so just join the start to the end. */
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :   if ( sweep_angle_r &lt; segment_angle_r ) {</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :     if ( include_first )</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :       pointArrayAddPoint(pa, p1);</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :     pointArrayAddPoint(pa, p3);</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :     return MS_SUCCESS;</span>
<span class="lineNum">     899 </span>            :   }
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span>            :   /* How many edges to generate (we add the final edge
<span class="lineNum">     902 </span>            :   *  by sticking on the last point */
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :   num_edges = floor(sweep_angle_r / fabs(segment_angle_r));</span>
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span>            :   /* Go backwards (negative angular steps) if we are stroking clockwise */
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :   if ( side == FP_LEFT )</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :     segment_angle_r *= -1;</span>
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            :   /* What point should we start with? */
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :   if( include_first ) {</span>
<span class="lineNum">     911 </span>            :     current_angle_r = a1;
<span class="lineNum">     912 </span>            :   } else {
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :     current_angle_r = a1 + segment_angle_r;</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :     num_edges--;</span>
<span class="lineNum">     915 </span>            :   }
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            :   /* For each edge, increment or decrement by our segment angle */
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :   for( i = 0; i &lt; num_edges; i++ ) {</span>
<span class="lineNum">     919 </span><span class="lineNoCov">          0 :     if (segment_angle_r &gt; 0.0 &amp;&amp; current_angle_r &gt; M_PI)</span>
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :       current_angle_r -= 2*M_PI;</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :     if (segment_angle_r &lt; 0.0 &amp;&amp; current_angle_r &lt; -1*M_PI)</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :       current_angle_r -= 2*M_PI;</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :     p.x = center.x + radius*cos(current_angle_r);</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :     p.y = center.y + radius*sin(current_angle_r);</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :     pointArrayAddPoint(pa, &amp;p);</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :     current_angle_r += segment_angle_r;</span>
<span class="lineNum">     927 </span>            :   }
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span>            :   /* Add the last point */
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :   pointArrayAddPoint(pa, p3);</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :   return MS_SUCCESS;</span>
<span class="lineNum">     932 </span>            : }
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            : /*
<span class="lineNum">     935 </span>            : ** This function does not actually take WKB as input, it takes the
<span class="lineNum">     936 </span>            : ** WKB starting from the numpoints integer. Each three-point edge
<span class="lineNum">     937 </span>            : ** is stroked into a linestring and appended into the lineObj
<span class="lineNum">     938 </span>            : ** argument.
<span class="lineNum">     939 </span>            : */
<span class="lineNum">     940 </span>            : int
<span class="lineNum">     941 </span><span class="lineNoCov">          0 : arcStrokeCircularString(wkbObj *w, double segment_angle, lineObj *line, int nZMFlag)</span>
<span class="lineNum">     942 </span>            : {
<span class="lineNum">     943 </span>            :   pointObj p1, p2, p3;
<span class="lineNum">     944 </span>            :   int npoints, nedges;
<span class="lineNum">     945 </span>            :   int edge = 0;
<span class="lineNum">     946 </span>            :   pointArrayObj *pa;
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :   if ( ! w || ! line ) return MS_FAILURE;</span>
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span>            :   npoints = wkbReadInt(w);
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :   nedges = npoints / 2;</span>
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span>            :   /* All CircularStrings have an odd number of points */
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :   if ( npoints &lt; 3 || npoints % 2 != 1 )</span>
<span class="lineNum">     955 </span>            :     return MS_FAILURE;
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span>            :   /* Make a large guess at how much space we'll need */
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :   pa = pointArrayNew(nedges * 180 / segment_angle);</span>
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :   wkbReadPointP(w,&amp;p3,nZMFlag);</span>
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span>            :   /* Fill out the point array with stroked arcs */
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :   while( edge &lt; nedges ) {</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :     p1 = p3;</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :     wkbReadPointP(w,&amp;p2,nZMFlag);</span>
<span class="lineNum">     966 </span><span class="lineNoCov">          0 :     wkbReadPointP(w,&amp;p3,nZMFlag);</span>
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :     if ( arcStrokeCircle(&amp;p1, &amp;p2, &amp;p3, segment_angle, edge ? 0 : 1, pa) == MS_FAILURE ) {</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :       pointArrayFree(pa);</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :       return MS_FAILURE;</span>
<span class="lineNum">     970 </span>            :     }
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :     edge++;</span>
<span class="lineNum">     972 </span>            :   }
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span>            :   /* Copy the point array into the line */
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :   line-&gt;numpoints = pa-&gt;npoints;</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :   line-&gt;point = msSmallMalloc(line-&gt;numpoints * sizeof(pointObj));</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :   memcpy(line-&gt;point, pa-&gt;data, line-&gt;numpoints * sizeof(pointObj));</span>
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span>            :   /* Clean up */
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :   pointArrayFree(pa);</span>
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :   return MS_SUCCESS;</span>
<span class="lineNum">     983 </span>            : }
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span>            : /*
<span class="lineNum">     987 </span>            : ** For LAYER types that are not the usual ones (charts,
<span class="lineNum">     988 </span>            : ** annotations, etc) we will convert to a shape type
<span class="lineNum">     989 </span>            : ** that &quot;makes sense&quot; given the WKB input. We do this
<span class="lineNum">     990 </span>            : ** by peaking at the type number of the first collection
<span class="lineNum">     991 </span>            : ** sub-element.
<span class="lineNum">     992 </span>            : */
<span class="lineNum">     993 </span>            : static int
<span class="lineNum">     994 </span><span class="lineNoCov">          0 : msPostGISFindBestType(wkbObj *w, shapeObj *shape)</span>
<span class="lineNum">     995 </span>            : {
<span class="lineNum">     996 </span>            :   int wkbtype;
<span class="lineNum">     997 </span>            :   int nZMFlag;
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span>            :   /* What kind of geometry is this? */
<span class="lineNum">    1000 </span>            :   wkbtype = wkbType(w, &amp;nZMFlag);
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span>            :   /* Generic collection, we need to look a little deeper. */
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :   if ( wkbtype == WKB_GEOMETRYCOLLECTION )</span>
<span class="lineNum">    1004 </span>            :     wkbtype = wkbCollectionSubType(w, &amp;nZMFlag);
<span class="lineNum">    1005 </span>            : 
<span class="lineNum">    1006 </span>            :   switch ( wkbtype ) {
<span class="lineNum">    1007 </span>            :     case WKB_POLYGON:
<span class="lineNum">    1008 </span>            :     case WKB_CURVEPOLYGON:
<span class="lineNum">    1009 </span>            :     case WKB_MULTIPOLYGON:
<span class="lineNum">    1010 </span><span class="lineNoCov">          0 :       shape-&gt;type = MS_SHAPE_POLYGON;</span>
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1012 </span>            :     case WKB_LINESTRING:
<span class="lineNum">    1013 </span>            :     case WKB_CIRCULARSTRING:
<span class="lineNum">    1014 </span>            :     case WKB_COMPOUNDCURVE:
<span class="lineNum">    1015 </span>            :     case WKB_MULTICURVE:
<span class="lineNum">    1016 </span>            :     case WKB_MULTILINESTRING:
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :       shape-&gt;type = MS_SHAPE_LINE;</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1019 </span>            :     case WKB_POINT:
<span class="lineNum">    1020 </span>            :     case WKB_MULTIPOINT:
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :       shape-&gt;type = MS_SHAPE_POINT;</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1023 </span>            :     default:
<span class="lineNum">    1024 </span>            :       return MS_FAILURE;
<span class="lineNum">    1025 </span>            :   }
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :   return wkbConvGeometryToShape(w, shape);</span>
<span class="lineNum">    1028 </span>            : }
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span>            : /*
<span class="lineNum">    1031 </span>            : ** Recent versions of PgSQL provide the version as an int in a
<span class="lineNum">    1032 </span>            : ** simple call to the connection handle. For earlier ones we have
<span class="lineNum">    1033 </span>            : ** to parse the version string into a usable number.
<span class="lineNum">    1034 </span>            : */
<span class="lineNum">    1035 </span>            : static int
<span class="lineNum">    1036 </span>            : msPostGISRetrievePgVersion(PGconn *pgconn)
<span class="lineNum">    1037 </span>            : {
<span class="lineNum">    1038 </span>            : #ifndef POSTGIS_HAS_SERVER_VERSION
<span class="lineNum">    1039 </span>            :   int pgVersion = 0;
<span class="lineNum">    1040 </span>            :   char *strVersion = NULL;
<span class="lineNum">    1041 </span>            :   char *strParts[3] = { NULL, NULL, NULL };
<span class="lineNum">    1042 </span>            :   int i = 0, j = 0, len = 0;
<span class="lineNum">    1043 </span>            :   int factor = 10000;
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span>            :   if (pgconn == NULL) {
<span class="lineNum">    1046 </span>            :     msSetError(MS_QUERYERR, &quot;Layer does not have a postgis connection.&quot;, &quot;msPostGISRetrievePgVersion()&quot;);
<span class="lineNum">    1047 </span>            :     return MS_FAILURE;
<span class="lineNum">    1048 </span>            :   }
<span class="lineNum">    1049 </span>            : 
<span class="lineNum">    1050 </span>            :   if (! PQparameterStatus(pgconn, &quot;server_version&quot;) )
<span class="lineNum">    1051 </span>            :     return MS_FAILURE;
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span>            :   strVersion = msStrdup(PQparameterStatus(pgconn, &quot;server_version&quot;));
<span class="lineNum">    1054 </span>            :   if( ! strVersion )
<span class="lineNum">    1055 </span>            :     return MS_FAILURE;
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span>            :   strParts[j] = strVersion;
<span class="lineNum">    1058 </span>            :   j++;
<span class="lineNum">    1059 </span>            :   len = strlen(strVersion);
<span class="lineNum">    1060 </span>            :   for( i = 0; i &lt; len; i++ ) {
<span class="lineNum">    1061 </span>            :     if( strVersion[i] == '.' ) {
<span class="lineNum">    1062 </span>            :       strVersion[i] = '\0';
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span>            :       if( j &lt; 3 ) {
<span class="lineNum">    1065 </span>            :         strParts[j] = strVersion + i + 1;
<span class="lineNum">    1066 </span>            :         j++;
<span class="lineNum">    1067 </span>            :       } else {
<span class="lineNum">    1068 </span>            :         free(strVersion);
<span class="lineNum">    1069 </span>            :         msSetError(MS_QUERYERR, &quot;Too many parts in version string.&quot;, &quot;msPostGISRetrievePgVersion()&quot;);
<span class="lineNum">    1070 </span>            :         return MS_FAILURE;
<span class="lineNum">    1071 </span>            :       }
<span class="lineNum">    1072 </span>            :     }
<span class="lineNum">    1073 </span>            :   }
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            :   for( j = 0; j &lt; 3 &amp;&amp; strParts[j]; j++ ) {
<span class="lineNum">    1076 </span>            :     pgVersion += factor * atoi(strParts[j]);
<span class="lineNum">    1077 </span>            :     factor = factor / 100;
<span class="lineNum">    1078 </span>            :   }
<span class="lineNum">    1079 </span>            :   free(strVersion);
<a name="1080"><span class="lineNum">    1080 </span>            :   return pgVersion;</a>
<span class="lineNum">    1081 </span>            : #else
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :   return PQserverVersion(pgconn);</span>
<span class="lineNum">    1083 </span>            : #endif
<span class="lineNum">    1084 </span>            : }
<span class="lineNum">    1085 </span>            : 
<span class="lineNum">    1086 </span>            : /*
<span class="lineNum">    1087 </span>            : ** Get the PostGIS version number from the database as integer.
<span class="lineNum">    1088 </span>            : ** Versions are multiplied out as with PgSQL: 1.5.2 -&gt; 10502, 2.0.0 -&gt; 20000.
<a name="1089"><span class="lineNum">    1089 </span>            : */</a>
<span class="lineNum">    1090 </span>            : static int
<span class="lineNum">    1091 </span><span class="lineCov">          1 : msPostGISRetrieveVersion(PGconn *pgconn)</span>
<span class="lineNum">    1092 </span>            : {
<span class="lineNum">    1093 </span>            :   static char* sql = &quot;SELECT postgis_version()&quot;;
<span class="lineNum">    1094 </span>            :   int version = 0;
<span class="lineNum">    1095 </span>            :   size_t strSize;
<span class="lineNum">    1096 </span>            :   char *strVersion = NULL;
<span class="lineNum">    1097 </span>            :   char *ptr;
<span class="lineNum">    1098 </span><span class="lineCov">          1 :   char *strParts[3] = { NULL, NULL, NULL };</span>
<span class="lineNum">    1099 </span>            :   int i = 0, j = 0;
<span class="lineNum">    1100 </span>            :   int factor = 10000;
<span class="lineNum">    1101 </span>            :   PGresult *pgresult = NULL;
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span><span class="lineCov">          1 :   if ( ! pgconn ) {</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR, &quot;No open connection.&quot;, &quot;msPostGISRetrieveVersion()&quot;);</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    1106 </span>            :   }
<span class="lineNum">    1107 </span>            : 
<span class="lineNum">    1108 </span><span class="lineCov">          1 :   pgresult = PQexecParams(pgconn, sql,0, NULL, NULL, NULL, NULL, 0);</span>
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span><span class="lineCov">          1 :   if ( !pgresult || PQresultStatus(pgresult) != PGRES_TUPLES_OK) {</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :     msDebug(&quot;Error executing SQL: (%s) in msPostGISRetrieveVersion()&quot;, sql);</span>
<span class="lineNum">    1112 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR, &quot;Error executing SQL. check server logs.&quot;, &quot;msPostGISRetrieveVersion()&quot;);</span>
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    1114 </span>            :   }
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span><span class="lineCov">          1 :   if (PQgetisnull(pgresult, 0, 0)) {</span>
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :     PQclear(pgresult);</span>
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR,&quot;Null result returned.&quot;,&quot;msPostGISRetrieveVersion()&quot;);</span>
<span class="lineNum">    1119 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    1120 </span>            :   }
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span><span class="lineCov">          1 :   strSize = PQgetlength(pgresult, 0, 0) + 1;</span>
<span class="lineNum">    1123 </span><span class="lineCov">          1 :   strVersion = (char*)msSmallMalloc(strSize);</span>
<span class="lineNum">    1124 </span><span class="lineCov">          1 :   strlcpy(strVersion, PQgetvalue(pgresult, 0, 0), strSize);</span>
<span class="lineNum">    1125 </span><span class="lineCov">          1 :   PQclear(pgresult);</span>
<span class="lineNum">    1126 </span>            : 
<span class="lineNum">    1127 </span>            :   ptr = strVersion;
<span class="lineNum">    1128 </span><span class="lineCov">          1 :   strParts[j++] = strVersion;</span>
<span class="lineNum">    1129 </span><span class="lineCov">          1 :   while( *ptr != '\0' &amp;&amp; j &lt; 3 ) {</span>
<span class="lineNum">    1130 </span><span class="lineCov">          1 :     if ( *ptr == '.' ) {</span>
<span class="lineNum">    1131 </span><span class="lineCov">          1 :       *ptr = '\0';</span>
<span class="lineNum">    1132 </span><span class="lineCov">          1 :       strParts[j++] = ptr + 1;</span>
<span class="lineNum">    1133 </span>            :     }
<span class="lineNum">    1134 </span><span class="lineCov">          1 :     if ( *ptr == ' ' ) {</span>
<span class="lineNum">    1135 </span><span class="lineCov">          1 :       *ptr = '\0';</span>
<span class="lineNum">    1136 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    1137 </span>            :     }
<span class="lineNum">    1138 </span><span class="lineCov">          1 :     ptr++;</span>
<span class="lineNum">    1139 </span>            :   }
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span><span class="lineCov">          1 :   for( i = 0; i &lt; j; i++ ) {</span>
<span class="lineNum">    1142 </span><span class="lineCov">          1 :     version += factor * atoi(strParts[i]);</span>
<span class="lineNum">    1143 </span><span class="lineCov">          1 :     factor = factor / 100;</span>
<span class="lineNum">    1144 </span>            :   }
<span class="lineNum">    1145 </span><span class="lineCov">          1 :   free(strVersion);</span>
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span><span class="lineCov">          1 :   return version;</span>
<span class="lineNum">    1148 </span>            : }
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span>            : /*
<span class="lineNum">    1151 </span>            : ** msPostGISRetrievePK()
<span class="lineNum">    1152 </span>            : **
<span class="lineNum">    1153 </span>            : ** Find out that the primary key is for this layer.
<span class="lineNum">    1154 </span>            : ** The layerinfo-&gt;fromsource must already be populated and
<span class="lineNum">    1155 </span>            : ** must not be a subquery.
<span class="lineNum">    1156 </span>            : */
<span class="lineNum">    1157 </span>            : static int
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 : msPostGISRetrievePK(layerObj *layer)</span>
<span class="lineNum">    1159 </span>            : {
<span class="lineNum">    1160 </span>            :   PGresult *pgresult = NULL;
<span class="lineNum">    1161 </span>            :   char *sql = 0;
<span class="lineNum">    1162 </span>            :   size_t size;
<span class="lineNum">    1163 </span>            :   msPostGISLayerInfo *layerinfo = 0;
<span class="lineNum">    1164 </span>            :   int length;
<span class="lineNum">    1165 </span>            :   int pgVersion;
<span class="lineNum">    1166 </span>            : 
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISRetrievePK called.\n&quot;);</span>
<span class="lineNum">    1169 </span>            :   }
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :   layerinfo = (msPostGISLayerInfo *) layer-&gt;layerinfo;</span>
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span>            : 
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :   if (layerinfo-&gt;pgconn == NULL) {</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR, &quot;Layer does not have a postgis connection.&quot;, &quot;msPostGISRetrievePK()&quot;);</span>
<span class="lineNum">    1176 </span>            :     return MS_FAILURE;
<span class="lineNum">    1177 </span>            :   }
<span class="lineNum">    1178 </span>            :   pgVersion = msPostGISRetrievePgVersion(layerinfo-&gt;pgconn);
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :   if (pgVersion &lt; 70000) {</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :     if (layer-&gt;debug) {</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISRetrievePK(): Major version below 7.\n&quot;);</span>
<span class="lineNum">    1183 </span>            :     }
<span class="lineNum">    1184 </span>            :     return MS_FAILURE;
<span class="lineNum">    1185 </span>            :   }
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :   if (pgVersion &lt; 70200) {</span>
<span class="lineNum">    1187 </span><span class="lineNoCov">          0 :     if (layer-&gt;debug) {</span>
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISRetrievePK(): Version below 7.2.\n&quot;);</span>
<span class="lineNum">    1189 </span>            :     }
<span class="lineNum">    1190 </span>            :     return MS_FAILURE;
<span class="lineNum">    1191 </span>            :   }
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :   if (pgVersion &lt; 70300) {</span>
<span class="lineNum">    1193 </span>            :     /*
<span class="lineNum">    1194 </span>            :     ** PostgreSQL v7.2 has a different representation of primary keys that
<span class="lineNum">    1195 </span>            :     ** later versions.  This currently does not explicitly exclude
<span class="lineNum">    1196 </span>            :     ** multicolumn primary keys.
<span class="lineNum">    1197 </span>            :     */
<span class="lineNum">    1198 </span>            :     static char *v72sql = &quot;select b.attname from pg_class as a, pg_attribute as b, (select oid from pg_class where relname = '%s') as c, pg_index as d where d.indexrelid = a.oid and d.indrelid = c.oid and d.indisprimary and b.attrelid = a.oid and a.relnatts = 1&quot;;
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :     sql = msSmallMalloc(strlen(layerinfo-&gt;fromsource) + strlen(v72sql) + 1);</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :     sprintf(sql, v72sql, layerinfo-&gt;fromsource);</span>
<span class="lineNum">    1201 </span>            :   } else {
<span class="lineNum">    1202 </span>            :     /* Attempt to separate fromsource into schema.table */
<span class="lineNum">    1203 </span>            :     char *pos_sep;
<span class="lineNum">    1204 </span>            :     char *schema = NULL;
<span class="lineNum">    1205 </span>            :     char *table = NULL;
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 :     pos_sep = strstr(layerinfo-&gt;fromsource, &quot;.&quot;);</span>
<span class="lineNum">    1207 </span><span class="lineNoCov">          0 :     if (pos_sep) {</span>
<span class="lineNum">    1208 </span><span class="lineNoCov">          0 :       length = strlen(layerinfo-&gt;fromsource) - strlen(pos_sep) + 1;</span>
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :       schema = (char*)msSmallMalloc(length);</span>
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :       strlcpy(schema, layerinfo-&gt;fromsource, length);</span>
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 :       length = strlen(pos_sep) + 1;</span>
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :       table = (char*)msSmallMalloc(length);</span>
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :       strlcpy(table, pos_sep + 1, length);</span>
<span class="lineNum">    1215 </span>            : 
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :       if (layer-&gt;debug) {</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :         msDebug(&quot;msPostGISRetrievePK(): Found schema %s, table %s.\n&quot;, schema, table);</span>
<span class="lineNum">    1218 </span>            :       }
<span class="lineNum">    1219 </span>            :     }
<span class="lineNum">    1220 </span>            :     /*
<span class="lineNum">    1221 </span>            :     ** PostgreSQL v7.3 and later treat primary keys as constraints.
<span class="lineNum">    1222 </span>            :     ** We only support single column primary keys, so multicolumn
<span class="lineNum">    1223 </span>            :     ** pks are explicitly excluded from the query.
<span class="lineNum">    1224 </span>            :     */
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :     if (schema &amp;&amp; table) {</span>
<span class="lineNum">    1226 </span>            :       static char *v73sql = &quot;select attname from pg_attribute, pg_constraint, pg_class, pg_namespace where pg_constraint.conrelid = pg_class.oid and pg_class.oid = pg_attribute.attrelid and pg_constraint.contype = 'p' and pg_constraint.conkey[1] = pg_attribute.attnum and pg_class.relname = '%s' and pg_class.relnamespace = pg_namespace.oid and pg_namespace.nspname = '%s' and pg_constraint.conkey[2] is null&quot;;
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :       sql = msSmallMalloc(strlen(schema) + strlen(table) + strlen(v73sql) + 1);</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :       sprintf(sql, v73sql, table, schema);</span>
<span class="lineNum">    1229 </span>            :     } else {
<span class="lineNum">    1230 </span>            :       static char *v73sql = &quot;select attname from pg_attribute, pg_constraint, pg_class where pg_constraint.conrelid = pg_class.oid and pg_class.oid = pg_attribute.attrelid and pg_constraint.contype = 'p' and pg_constraint.conkey[1] = pg_attribute.attnum and pg_class.relname = '%s' and pg_table_is_visible(pg_class.oid) and pg_constraint.conkey[2] is null&quot;;
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :       sql = msSmallMalloc(strlen(layerinfo-&gt;fromsource) + strlen(v73sql) + 1);</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :       sprintf(sql, v73sql, layerinfo-&gt;fromsource);</span>
<span class="lineNum">    1233 </span>            :     }
<span class="lineNum">    1234 </span><span class="lineNoCov">          0 :     free(table);</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :     free(schema);</span>
<span class="lineNum">    1236 </span>            :   }
<span class="lineNum">    1237 </span>            : 
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :   if (layer-&gt;debug &gt; 1) {</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISRetrievePK: %s\n&quot;, sql);</span>
<span class="lineNum">    1240 </span>            :   }
<span class="lineNum">    1241 </span>            : 
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 :   layerinfo = (msPostGISLayerInfo *) layer-&gt;layerinfo;</span>
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 :   if (layerinfo-&gt;pgconn == NULL) {</span>
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR, &quot;Layer does not have a postgis connection.&quot;, &quot;msPostGISRetrievePK()&quot;);</span>
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :     free(sql);</span>
<span class="lineNum">    1247 </span>            :     return MS_FAILURE;
<span class="lineNum">    1248 </span>            :   }
<span class="lineNum">    1249 </span>            : 
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :   pgresult = PQexecParams(layerinfo-&gt;pgconn, sql, 0, NULL, NULL, NULL, NULL, 0);</span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :   if ( !pgresult || PQresultStatus(pgresult) != PGRES_TUPLES_OK) {</span>
<span class="lineNum">    1252 </span>            :     static char *tmp1 = &quot;Error executing SQL: &quot;;
<span class="lineNum">    1253 </span>            :     char *tmp2 = NULL;
<span class="lineNum">    1254 </span>            :     size_t size2;
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :     size2 = sizeof(char)*(strlen(tmp1) + strlen(sql) + 1);</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :     tmp2 = (char*)msSmallMalloc(size2);</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :     strlcpy(tmp2, tmp1, size2);</span>
<span class="lineNum">    1259 </span><span class="lineNoCov">          0 :     strlcat(tmp2, sql, size2);</span>
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR, &quot;%s&quot;, &quot;msPostGISRetrievePK()&quot;, tmp2);</span>
<span class="lineNum">    1261 </span><span class="lineNoCov">          0 :     free(tmp2);</span>
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :     free(sql);</span>
<span class="lineNum">    1263 </span>            :     return MS_FAILURE;
<span class="lineNum">    1264 </span>            :   }
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :   if (PQntuples(pgresult) &lt; 1) {</span>
<span class="lineNum">    1267 </span><span class="lineNoCov">          0 :     if (layer-&gt;debug) {</span>
<span class="lineNum">    1268 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISRetrievePK: No results found.\n&quot;);</span>
<span class="lineNum">    1269 </span>            :     }
<span class="lineNum">    1270 </span><span class="lineNoCov">          0 :     PQclear(pgresult);</span>
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :     free(sql);</span>
<span class="lineNum">    1272 </span>            :     return MS_FAILURE;
<span class="lineNum">    1273 </span>            :   }
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :   if (PQntuples(pgresult) &gt; 1) {</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :     if (layer-&gt;debug) {</span>
<span class="lineNum">    1276 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISRetrievePK: Multiple results found.\n&quot;);</span>
<span class="lineNum">    1277 </span>            :     }
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :     PQclear(pgresult);</span>
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :     free(sql);</span>
<span class="lineNum">    1280 </span>            :     return MS_FAILURE;
<span class="lineNum">    1281 </span>            :   }
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :   if (PQgetisnull(pgresult, 0, 0)) {</span>
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :     if (layer-&gt;debug) {</span>
<span class="lineNum">    1285 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISRetrievePK: Null result returned.\n&quot;);</span>
<span class="lineNum">    1286 </span>            :     }
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :     PQclear(pgresult);</span>
<span class="lineNum">    1288 </span><span class="lineNoCov">          0 :     free(sql);</span>
<span class="lineNum">    1289 </span>            :     return MS_FAILURE;
<span class="lineNum">    1290 </span>            :   }
<span class="lineNum">    1291 </span>            : 
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :   size = PQgetlength(pgresult, 0, 0) + 1;</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :   layerinfo-&gt;uid = (char*)msSmallMalloc(size);</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :   strlcpy(layerinfo-&gt;uid, PQgetvalue(pgresult, 0, 0), size);</span>
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :   PQclear(pgresult);</span>
<span class="lineNum">    1297 </span><span class="lineNoCov">          0 :   free(sql);</span>
<span class="lineNum">    1298 </span>            :   return MS_SUCCESS;
<span class="lineNum">    1299 </span>            : }
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span>            : 
<span class="lineNum">    1302 </span>            : /*
<span class="lineNum">    1303 </span>            : ** msPostGISParseData()
<span class="lineNum">    1304 </span>            : **
<span class="lineNum">    1305 </span>            : ** Parse the DATA string for geometry column name, table name,
<a name="1306"><span class="lineNum">    1306 </span>            : ** unique id column, srid, and SQL string.</a>
<span class="lineNum">    1307 </span>            : */
<span class="lineNum">    1308 </span><span class="lineCov">          1 : int msPostGISParseData(layerObj *layer)</span>
<span class="lineNum">    1309 </span>            : {
<span class="lineNum">    1310 </span>            :   char *pos_opt, *pos_scn, *tmp, *pos_srid, *pos_uid, *pos_geom, *data;
<span class="lineNum">    1311 </span>            :   int slength;
<span class="lineNum">    1312 </span>            :   msPostGISLayerInfo *layerinfo;
<span class="lineNum">    1313 </span>            : 
<span class="lineNum">    1314 </span>            :   assert(layer != NULL);
<span class="lineNum">    1315 </span>            :   assert(layer-&gt;layerinfo != NULL);
<span class="lineNum">    1316 </span>            : 
<span class="lineNum">    1317 </span><span class="lineCov">          1 :   layerinfo = (msPostGISLayerInfo*)(layer-&gt;layerinfo);</span>
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISParseData called.\n&quot;);</span>
<span class="lineNum">    1321 </span>            :   }
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span><span class="lineCov">          1 :   if (!layer-&gt;data) {</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR, &quot;Missing DATA clause. DATA statement must contain 'geometry_column from table_name' or 'geometry_column from (sub-query) as sub'.&quot;, &quot;msPostGISParseData()&quot;);</span>
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    1326 </span>            :   }
<span class="lineNum">    1327 </span>            :   data = layer-&gt;data;
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span>            :   /*
<span class="lineNum">    1330 </span>            :   ** Clean up any existing strings first, as we will be populating these fields.
<span class="lineNum">    1331 </span>            :   */
<span class="lineNum">    1332 </span><span class="lineCov">          1 :   if( layerinfo-&gt;srid ) {</span>
<span class="lineNum">    1333 </span><span class="lineCov">          1 :     free(layerinfo-&gt;srid);</span>
<span class="lineNum">    1334 </span><span class="lineCov">          1 :     layerinfo-&gt;srid = NULL;</span>
<span class="lineNum">    1335 </span>            :   }
<span class="lineNum">    1336 </span><span class="lineCov">          1 :   if( layerinfo-&gt;uid ) {</span>
<span class="lineNum">    1337 </span><span class="lineCov">          1 :     free(layerinfo-&gt;uid);</span>
<span class="lineNum">    1338 </span><span class="lineCov">          1 :     layerinfo-&gt;uid = NULL;</span>
<span class="lineNum">    1339 </span>            :   }
<span class="lineNum">    1340 </span><span class="lineCov">          1 :   if( layerinfo-&gt;geomcolumn ) {</span>
<span class="lineNum">    1341 </span><span class="lineCov">          1 :     free(layerinfo-&gt;geomcolumn);</span>
<span class="lineNum">    1342 </span><span class="lineCov">          1 :     layerinfo-&gt;geomcolumn = NULL;</span>
<span class="lineNum">    1343 </span>            :   }
<span class="lineNum">    1344 </span><span class="lineCov">          1 :   if( layerinfo-&gt;fromsource ) {</span>
<span class="lineNum">    1345 </span><span class="lineCov">          1 :     free(layerinfo-&gt;fromsource);</span>
<span class="lineNum">    1346 </span><span class="lineCov">          1 :     layerinfo-&gt;fromsource = NULL;</span>
<span class="lineNum">    1347 </span>            :   }
<span class="lineNum">    1348 </span>            : 
<span class="lineNum">    1349 </span>            :   /*
<span class="lineNum">    1350 </span>            :   ** Look for the optional ' using unique ID' string first.
<span class="lineNum">    1351 </span>            :   */
<span class="lineNum">    1352 </span><span class="lineCov">          1 :   pos_uid = strcasestr(data, &quot; using unique &quot;);</span>
<span class="lineNum">    1353 </span><span class="lineCov">          1 :   if (pos_uid) {</span>
<span class="lineNum">    1354 </span>            :     /* Find the end of this case 'using unique ftab_id using srid=33' */
<span class="lineNum">    1355 </span><span class="lineCov">          1 :     tmp = strstr(pos_uid + 14, &quot; &quot;);</span>
<span class="lineNum">    1356 </span>            :     /* Find the end of this case 'using srid=33 using unique ftab_id' */
<span class="lineNum">    1357 </span><span class="lineCov">          1 :     if (!tmp) {</span>
<span class="lineNum">    1358 </span><span class="lineCov">          1 :       tmp = pos_uid + strlen(pos_uid);</span>
<span class="lineNum">    1359 </span>            :     }
<span class="lineNum">    1360 </span><span class="lineCov">          1 :     layerinfo-&gt;uid = (char*) msSmallMalloc((tmp - (pos_uid + 14)) + 1);</span>
<span class="lineNum">    1361 </span><span class="lineCov">          1 :     strlcpy(layerinfo-&gt;uid, pos_uid + 14, tmp - (pos_uid + 14)+1);</span>
<span class="lineNum">    1362 </span><span class="lineCov">          1 :     msStringTrim(layerinfo-&gt;uid);</span>
<span class="lineNum">    1363 </span>            :   }
<span class="lineNum">    1364 </span>            : 
<span class="lineNum">    1365 </span>            :   /*
<span class="lineNum">    1366 </span>            :   ** Look for the optional ' using srid=333 ' string next.
<span class="lineNum">    1367 </span>            :   */
<span class="lineNum">    1368 </span><span class="lineCov">          1 :   pos_srid = strcasestr(data, &quot; using srid=&quot;);</span>
<span class="lineNum">    1369 </span><span class="lineCov">          1 :   if (!pos_srid) {</span>
<span class="lineNum">    1370 </span><span class="lineCov">          1 :     layerinfo-&gt;srid = (char*) msSmallMalloc(1);</span>
<span class="lineNum">    1371 </span><span class="lineCov">          1 :     (layerinfo-&gt;srid)[0] = '\0'; /* no SRID, so return just null terminator*/</span>
<span class="lineNum">    1372 </span>            :   } else {
<span class="lineNum">    1373 </span><span class="lineCov">          1 :     slength = strspn(pos_srid + 12, &quot;-0123456789&quot;);</span>
<span class="lineNum">    1374 </span><span class="lineCov">          1 :     if (!slength) {</span>
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :       msSetError(MS_QUERYERR, &quot;Error parsing PostGIS DATA variable. You specified 'USING SRID' but didn't have any numbers! %s&quot;, &quot;msPostGISParseData()&quot;, data);</span>
<span class="lineNum">    1376 </span><span class="lineNoCov">          0 :       return MS_FAILURE;</span>
<span class="lineNum">    1377 </span>            :     } else {
<span class="lineNum">    1378 </span><span class="lineCov">          1 :       layerinfo-&gt;srid = (char*) msSmallMalloc(slength + 1);</span>
<span class="lineNum">    1379 </span><span class="lineCov">          1 :       strlcpy(layerinfo-&gt;srid, pos_srid + 12, slength+1);</span>
<span class="lineNum">    1380 </span><span class="lineCov">          1 :       msStringTrim(layerinfo-&gt;srid);</span>
<span class="lineNum">    1381 </span>            :     }
<span class="lineNum">    1382 </span>            :   }
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span>            :   /*
<span class="lineNum">    1385 </span>            :   ** This is a little hack so the rest of the code works.
<span class="lineNum">    1386 </span>            :   ** pos_opt should point to the start of the optional blocks.
<span class="lineNum">    1387 </span>            :   **
<span class="lineNum">    1388 </span>            :   ** If they are both set, return the smaller one.
<span class="lineNum">    1389 </span>            :   */
<span class="lineNum">    1390 </span><span class="lineCov">          1 :   if (pos_srid &amp;&amp; pos_uid) {</span>
<span class="lineNum">    1391 </span><span class="lineCov">          1 :     pos_opt = (pos_srid &gt; pos_uid) ? pos_uid : pos_srid;</span>
<span class="lineNum">    1392 </span>            :   }
<span class="lineNum">    1393 </span>            :   /* If one or none is set, return the larger one. */
<span class="lineNum">    1394 </span>            :   else {
<span class="lineNum">    1395 </span><span class="lineCov">          1 :     pos_opt = (pos_srid &gt; pos_uid) ? pos_srid : pos_uid;</span>
<span class="lineNum">    1396 </span>            :   }
<span class="lineNum">    1397 </span>            :   /* No pos_opt? Move it to the end of the string. */
<span class="lineNum">    1398 </span><span class="lineCov">          1 :   if (!pos_opt) {</span>
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :     pos_opt = data + strlen(data);</span>
<span class="lineNum">    1400 </span>            :   }
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span>            :   /*
<span class="lineNum">    1403 </span>            :   ** Scan for the 'geometry from table' or 'geometry from () as foo' clause.
<span class="lineNum">    1404 </span>            :   */
<span class="lineNum">    1405 </span>            : 
<span class="lineNum">    1406 </span>            :   /* Find the first non-white character to start from */
<span class="lineNum">    1407 </span>            :   pos_geom = data;
<span class="lineNum">    1408 </span><span class="lineCov">          1 :   while( *pos_geom == ' ' || *pos_geom == '\t' || *pos_geom == '\n' || *pos_geom == '\r' )</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :     pos_geom++;</span>
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span>            :   /* Find the end of the geom column name */
<span class="lineNum">    1412 </span><span class="lineCov">          1 :   pos_scn = strcasestr(data, &quot; from &quot;);</span>
<span class="lineNum">    1413 </span><span class="lineCov">          1 :   if (!pos_scn) {</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR, &quot;Error parsing PostGIS DATA variable. Must contain 'geometry from table' or 'geometry from (subselect) as foo'. %s&quot;, &quot;msPostGISParseData()&quot;, data);</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    1416 </span>            :   }
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span>            :   /* Copy the geometry column name */
<span class="lineNum">    1419 </span><span class="lineCov">          1 :   layerinfo-&gt;geomcolumn = (char*) msSmallMalloc((pos_scn - pos_geom) + 1);</span>
<span class="lineNum">    1420 </span><span class="lineCov">          1 :   strlcpy(layerinfo-&gt;geomcolumn, pos_geom, pos_scn - pos_geom+1);</span>
<span class="lineNum">    1421 </span><span class="lineCov">          1 :   msStringTrim(layerinfo-&gt;geomcolumn);</span>
<span class="lineNum">    1422 </span>            : 
<span class="lineNum">    1423 </span>            :   /* Copy the table name or sub-select clause */
<span class="lineNum">    1424 </span><span class="lineCov">          1 :   layerinfo-&gt;fromsource = (char*) msSmallMalloc((pos_opt - (pos_scn + 6)) + 1);</span>
<span class="lineNum">    1425 </span><span class="lineCov">          1 :   strlcpy(layerinfo-&gt;fromsource, pos_scn + 6, pos_opt - (pos_scn + 6)+1);</span>
<span class="lineNum">    1426 </span><span class="lineCov">          1 :   msStringTrim(layerinfo-&gt;fromsource);</span>
<span class="lineNum">    1427 </span>            : 
<span class="lineNum">    1428 </span>            :   /* Something is wrong, our goemetry column and table references are not there. */
<span class="lineNum">    1429 </span><span class="lineCov">          1 :   if (strlen(layerinfo-&gt;fromsource) &lt; 1 || strlen(layerinfo-&gt;geomcolumn) &lt; 1) {</span>
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR, &quot;Error parsing PostGIS DATA variable.  Must contain 'geometry from table' or 'geometry from (subselect) as foo'. %s&quot;, &quot;msPostGISParseData()&quot;, data);</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    1432 </span>            :   }
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span>            :   /*
<span class="lineNum">    1435 </span>            :   ** We didn't find a ' using unique ' in the DATA string so try and find a
<span class="lineNum">    1436 </span>            :   ** primary key on the table.
<span class="lineNum">    1437 </span>            :   */
<span class="lineNum">    1438 </span><span class="lineCov">          1 :   if ( ! (layerinfo-&gt;uid) ) {</span>
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :     if ( strstr(layerinfo-&gt;fromsource, &quot; &quot;) ) {</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :       msSetError(MS_QUERYERR, &quot;Error parsing PostGIS DATA variable.  You must specify 'using unique' when supplying a subselect in the data definition.&quot;, &quot;msPostGISParseData()&quot;);</span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :       return MS_FAILURE;</span>
<span class="lineNum">    1442 </span>            :     }
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :     if ( msPostGISRetrievePK(layer) != MS_SUCCESS ) {</span>
<span class="lineNum">    1444 </span>            :       /* No user specified unique id so we will use the PostgreSQL oid */
<span class="lineNum">    1445 </span>            :       /* TODO: Deprecate this, oids are deprecated in PostgreSQL */
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :       layerinfo-&gt;uid = msStrdup(&quot;oid&quot;);</span>
<span class="lineNum">    1447 </span>            :     }
<span class="lineNum">    1448 </span>            :   }
<span class="lineNum">    1449 </span>            : 
<span class="lineNum">    1450 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISParseData: unique_column=%s, srid=%s, geom_column_name=%s, table_name=%s\n&quot;, layerinfo-&gt;uid, layerinfo-&gt;srid, layerinfo-&gt;geomcolumn, layerinfo-&gt;fromsource);</span>
<span class="lineNum">    1452 </span>            :   }
<span class="lineNum">    1453 </span>            :   return MS_SUCCESS;
<span class="lineNum">    1454 </span>            : }
<span class="lineNum">    1455 </span>            : 
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span>            : /*
<span class="lineNum">    1459 </span>            : ** Decode a hex character.
<span class="lineNum">    1460 </span>            : */
<span class="lineNum">    1461 </span>            : static unsigned char msPostGISHexDecodeChar[256] = {
<span class="lineNum">    1462 </span>            :   /* not Hex characters */
<span class="lineNum">    1463 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1464 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1465 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1466 </span>            :   /* 0-9 */
<span class="lineNum">    1467 </span>            :   0,1,2,3,4,5,6,7,8,9,
<span class="lineNum">    1468 </span>            :   /* not Hex characters */
<span class="lineNum">    1469 </span>            :   64,64,64,64,64,64,64,
<span class="lineNum">    1470 </span>            :   /* A-F */
<span class="lineNum">    1471 </span>            :   10,11,12,13,14,15,
<span class="lineNum">    1472 </span>            :   /* not Hex characters */
<span class="lineNum">    1473 </span>            :   64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1474 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1475 </span>            :   64,
<span class="lineNum">    1476 </span>            :   /* a-f */
<span class="lineNum">    1477 </span>            :   10,11,12,13,14,15,
<span class="lineNum">    1478 </span>            :   64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1479 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1480 </span>            :   /* not Hex characters (upper 128 characters) */
<span class="lineNum">    1481 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1482 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1483 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1484 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1485 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1486 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1487 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1488 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64
<span class="lineNum">    1489 </span>            : };
<span class="lineNum">    1490 </span>            : 
<span class="lineNum">    1491 </span>            : /*
<span class="lineNum">    1492 </span>            : ** Decode hex string &quot;src&quot; (null terminated)
<span class="lineNum">    1493 </span>            : ** into &quot;dest&quot; (not null terminated).
<a name="1494"><span class="lineNum">    1494 </span>            : ** Returns length of decoded array or 0 on failure.</a>
<span class="lineNum">    1495 </span>            : */
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 : int msPostGISHexDecode(unsigned char *dest, const char *src, int srclen)</span>
<span class="lineNum">    1497 </span>            : {
<span class="lineNum">    1498 </span>            : 
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :   if (src &amp;&amp; *src &amp;&amp; (srclen % 2 == 0) ) {</span>
<span class="lineNum">    1500 </span>            : 
<span class="lineNum">    1501 </span>            :     unsigned char *p = dest;
<span class="lineNum">    1502 </span>            :     int i;
<span class="lineNum">    1503 </span>            : 
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :     for ( i=0; i&lt;srclen; i+=2 ) {</span>
<span class="lineNum">    1505 </span>            :       register unsigned char b1=0, b2=0;
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :       register unsigned char c1 = src[i];</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :       register unsigned char c2 = src[i + 1];</span>
<span class="lineNum">    1508 </span>            : 
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :       b1 = msPostGISHexDecodeChar[c1];</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :       b2 = msPostGISHexDecodeChar[c2];</span>
<span class="lineNum">    1511 </span>            : 
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :       *p++ = (b1 &lt;&lt; 4) | b2;</span>
<span class="lineNum">    1513 </span>            : 
<span class="lineNum">    1514 </span>            :     }
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :     return(p-dest);</span>
<span class="lineNum">    1516 </span>            :   }
<span class="lineNum">    1517 </span>            :   return 0;
<span class="lineNum">    1518 </span>            : }
<span class="lineNum">    1519 </span>            : 
<span class="lineNum">    1520 </span>            : /*
<span class="lineNum">    1521 </span>            : ** Decode a base64 character.
<span class="lineNum">    1522 </span>            : */
<span class="lineNum">    1523 </span>            : static unsigned char msPostGISBase64DecodeChar[256] = {
<span class="lineNum">    1524 </span>            :   /* not Base64 characters */
<span class="lineNum">    1525 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1526 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1527 </span>            :   64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1528 </span>            :   /*  +  */
<span class="lineNum">    1529 </span>            :   62,
<span class="lineNum">    1530 </span>            :   /* not Base64 characters */
<span class="lineNum">    1531 </span>            :   64,64,64,
<span class="lineNum">    1532 </span>            :   /*  /  */
<span class="lineNum">    1533 </span>            :   63,
<span class="lineNum">    1534 </span>            :   /* 0-9 */
<span class="lineNum">    1535 </span>            :   52,53,54,55,56,57,58,59,60,61,
<span class="lineNum">    1536 </span>            :   /* not Base64 characters */
<span class="lineNum">    1537 </span>            :   64,64,64,64,64,64,64,
<span class="lineNum">    1538 </span>            :   /* A-Z */
<span class="lineNum">    1539 </span>            :   0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,
<span class="lineNum">    1540 </span>            :   /* not Base64 characters */
<span class="lineNum">    1541 </span>            :   64,64,64,64,64,64,
<span class="lineNum">    1542 </span>            :   /* a-z */
<span class="lineNum">    1543 </span>            :   26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
<span class="lineNum">    1544 </span>            :   /* not Base64 characters */
<span class="lineNum">    1545 </span>            :   64,64,64,64,64,
<span class="lineNum">    1546 </span>            :   /* not Base64 characters (upper 128 characters) */
<span class="lineNum">    1547 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1548 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1549 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1550 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1551 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1552 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1553 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
<span class="lineNum">    1554 </span>            :   64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64
<span class="lineNum">    1555 </span>            : };
<span class="lineNum">    1556 </span>            : 
<span class="lineNum">    1557 </span>            : /*
<span class="lineNum">    1558 </span>            : ** Decode base64 string &quot;src&quot; (null terminated)
<span class="lineNum">    1559 </span>            : ** into &quot;dest&quot; (not null terminated).
<a name="1560"><span class="lineNum">    1560 </span>            : ** Returns length of decoded array or 0 on failure.</a>
<span class="lineNum">    1561 </span>            : */
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 : int msPostGISBase64Decode(unsigned char *dest, const char *src, int srclen)</span>
<span class="lineNum">    1563 </span>            : {
<span class="lineNum">    1564 </span>            : 
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :   if (src &amp;&amp; *src) {</span>
<span class="lineNum">    1566 </span>            : 
<span class="lineNum">    1567 </span>            :     unsigned char *p = dest;
<span class="lineNum">    1568 </span>            :     int i, j, k;
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :     unsigned char *buf = calloc(srclen + 1, sizeof(unsigned char));</span>
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span>            :     /* Drop illegal chars first */
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :     for (i=0, j=0; src[i]; i++) {</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :       unsigned char c = src[i];</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :       if ( (msPostGISBase64DecodeChar[c] != 64) || (c == '=') ) {</span>
<span class="lineNum">    1575 </span><span class="lineNoCov">          0 :         buf[j++] = c;</span>
<span class="lineNum">    1576 </span>            :       }
<span class="lineNum">    1577 </span>            :     }
<span class="lineNum">    1578 </span>            : 
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 :     for (k=0; k&lt;j; k+=4) {</span>
<span class="lineNum">    1580 </span>            :       register unsigned char c1='A', c2='A', c3='A', c4='A';
<span class="lineNum">    1581 </span>            :       register unsigned char b1=0, b2=0, b3=0, b4=0;
<span class="lineNum">    1582 </span>            : 
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :       c1 = buf[k];</span>
<span class="lineNum">    1584 </span>            : 
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :       if (k+1&lt;j) {</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :         c2 = buf[k+1];</span>
<span class="lineNum">    1587 </span>            :       }
<span class="lineNum">    1588 </span><span class="lineNoCov">          0 :       if (k+2&lt;j) {</span>
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :         c3 = buf[k+2];</span>
<span class="lineNum">    1590 </span>            :       }
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :       if (k+3&lt;j) {</span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :         c4 = buf[k+3];</span>
<span class="lineNum">    1593 </span>            :       }
<span class="lineNum">    1594 </span>            : 
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :       b1 = msPostGISBase64DecodeChar[c1];</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :       b2 = msPostGISBase64DecodeChar[c2];</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :       b3 = msPostGISBase64DecodeChar[c3];</span>
<span class="lineNum">    1598 </span><span class="lineNoCov">          0 :       b4 = msPostGISBase64DecodeChar[c4];</span>
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span><span class="lineNoCov">          0 :       *p++=((b1&lt;&lt;2)|(b2&gt;&gt;4) );</span>
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :       if (c3 != '=') {</span>
<span class="lineNum">    1602 </span><span class="lineNoCov">          0 :         *p++=(((b2&amp;0xf)&lt;&lt;4)|(b3&gt;&gt;2) );</span>
<span class="lineNum">    1603 </span>            :       }
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :       if (c4 != '=') {</span>
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :         *p++=(((b3&amp;0x3)&lt;&lt;6)|b4 );</span>
<span class="lineNum">    1606 </span>            :       }
<span class="lineNum">    1607 </span>            :     }
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :     free(buf);</span>
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :     return(p-dest);</span>
<span class="lineNum">    1610 </span>            :   }
<span class="lineNum">    1611 </span>            :   return 0;
<span class="lineNum">    1612 </span>            : }
<span class="lineNum">    1613 </span>            : 
<span class="lineNum">    1614 </span>            : /*
<span class="lineNum">    1615 </span>            : ** msPostGISBuildSQLBox()
<span class="lineNum">    1616 </span>            : **
<a name="1617"><span class="lineNum">    1617 </span>            : ** Returns malloc'ed char* that must be freed by caller.</a>
<span class="lineNum">    1618 </span>            : */
<span class="lineNum">    1619 </span><span class="lineCov">          1 : char *msPostGISBuildSQLBox(layerObj *layer, rectObj *rect, char *strSRID)</span>
<span class="lineNum">    1620 </span>            : {
<span class="lineNum">    1621 </span>            : 
<span class="lineNum">    1622 </span>            :   char *strBox = NULL;
<span class="lineNum">    1623 </span>            :   size_t sz;
<span class="lineNum">    1624 </span>            : 
<span class="lineNum">    1625 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISBuildSQLBox called.\n&quot;);</span>
<span class="lineNum">    1627 </span>            :   }
<span class="lineNum">    1628 </span>            : 
<span class="lineNum">    1629 </span><span class="lineCov">          1 :   if ( strSRID ) {</span>
<span class="lineNum">    1630 </span>            :     static char *strBoxTemplate = &quot;ST_GeomFromText('POLYGON((%.15g %.15g,%.15g %.15g,%.15g %.15g,%.15g %.15g,%.15g %.15g))',%s)&quot;;
<span class="lineNum">    1631 </span>            :     /* 10 doubles + 1 integer + template characters */
<span class="lineNum">    1632 </span><span class="lineCov">          1 :     sz = 10 * 22 + strlen(strSRID) + strlen(strBoxTemplate);</span>
<span class="lineNum">    1633 </span><span class="lineCov">          1 :     strBox = (char*)msSmallMalloc(sz+1); /* add space for terminating NULL */</span>
<span class="lineNum">    1634 </span><span class="lineCov">          1 :     if ( sz &lt;= snprintf(strBox, sz, strBoxTemplate,</span>
<span class="lineNum">    1635 </span>            :                         rect-&gt;minx, rect-&gt;miny,
<span class="lineNum">    1636 </span>            :                         rect-&gt;minx, rect-&gt;maxy,
<span class="lineNum">    1637 </span>            :                         rect-&gt;maxx, rect-&gt;maxy,
<span class="lineNum">    1638 </span>            :                         rect-&gt;maxx, rect-&gt;miny,
<span class="lineNum">    1639 </span>            :                         rect-&gt;minx, rect-&gt;miny,
<span class="lineNum">    1640 </span>            :                         strSRID)) {
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :       msSetError(MS_MISCERR,&quot;Bounding box digits truncated.&quot;,&quot;msPostGISBuildSQLBox&quot;);</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1643 </span>            :     }
<span class="lineNum">    1644 </span>            :   } else {
<span class="lineNum">    1645 </span>            :     static char *strBoxTemplate = &quot;ST_GeomFromText('POLYGON((%.15g %.15g,%.15g %.15g,%.15g %.15g,%.15g %.15g,%.15g %.15g))')&quot;;
<span class="lineNum">    1646 </span>            :     /* 10 doubles + template characters */
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :     sz = 10 * 22 + strlen(strBoxTemplate);</span>
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :     strBox = (char*)msSmallMalloc(sz+1); /* add space for terminating NULL */</span>
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :     if ( sz &lt;= snprintf(strBox, sz, strBoxTemplate,</span>
<span class="lineNum">    1650 </span>            :                         rect-&gt;minx, rect-&gt;miny,
<span class="lineNum">    1651 </span>            :                         rect-&gt;minx, rect-&gt;maxy,
<span class="lineNum">    1652 </span>            :                         rect-&gt;maxx, rect-&gt;maxy,
<span class="lineNum">    1653 </span>            :                         rect-&gt;maxx, rect-&gt;miny,
<span class="lineNum">    1654 </span>            :                         rect-&gt;minx, rect-&gt;miny) ) {
<span class="lineNum">    1655 </span><span class="lineNoCov">          0 :       msSetError(MS_MISCERR,&quot;Bounding box digits truncated.&quot;,&quot;msPostGISBuildSQLBox&quot;);</span>
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1657 </span>            :     }
<span class="lineNum">    1658 </span>            :   }
<span class="lineNum">    1659 </span>            : 
<span class="lineNum">    1660 </span><span class="lineCov">          1 :   return strBox;</span>
<span class="lineNum">    1661 </span>            : 
<span class="lineNum">    1662 </span>            : }
<span class="lineNum">    1663 </span>            : 
<span class="lineNum">    1664 </span>            : 
<span class="lineNum">    1665 </span>            : /*
<span class="lineNum">    1666 </span>            : ** msPostGISBuildSQLItems()
<span class="lineNum">    1667 </span>            : **
<a name="1668"><span class="lineNum">    1668 </span>            : ** Returns malloc'ed char* that must be freed by caller.</a>
<span class="lineNum">    1669 </span>            : */
<span class="lineNum">    1670 </span><span class="lineCov">          1 : char *msPostGISBuildSQLItems(layerObj *layer)</span>
<span class="lineNum">    1671 </span>            : {
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span>            :   char *strEndian = NULL;
<span class="lineNum">    1674 </span>            :   char *strGeom = NULL;
<span class="lineNum">    1675 </span>            :   char *strItems = NULL;
<span class="lineNum">    1676 </span>            :   msPostGISLayerInfo *layerinfo = NULL;
<span class="lineNum">    1677 </span>            : 
<span class="lineNum">    1678 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISBuildSQLItems called.\n&quot;);</span>
<span class="lineNum">    1680 </span>            :   }
<span class="lineNum">    1681 </span>            : 
<span class="lineNum">    1682 </span>            :   assert( layer-&gt;layerinfo != NULL);
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span><span class="lineCov">          1 :   layerinfo = (msPostGISLayerInfo *)layer-&gt;layerinfo;</span>
<span class="lineNum">    1685 </span>            : 
<span class="lineNum">    1686 </span><span class="lineCov">          1 :   if ( ! layerinfo-&gt;geomcolumn ) {</span>
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :     msSetError(MS_MISCERR, &quot;layerinfo-&gt;geomcolumn is not initialized.&quot;, &quot;msPostGISBuildSQLItems()&quot;);</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1689 </span>            :   }
<span class="lineNum">    1690 </span>            : 
<span class="lineNum">    1691 </span>            :   /*
<span class="lineNum">    1692 </span>            :   ** Get the server to transform the geometry into our
<span class="lineNum">    1693 </span>            :   ** native endian before transmitting it to us..
<span class="lineNum">    1694 </span>            :   */
<span class="lineNum">    1695 </span><span class="lineCov">          1 :   if (layerinfo-&gt;endian == LITTLE_ENDIAN) {</span>
<span class="lineNum">    1696 </span>            :     strEndian = &quot;NDR&quot;;
<span class="lineNum">    1697 </span>            :   } else {
<span class="lineNum">    1698 </span>            :     strEndian = &quot;XDR&quot;;
<span class="lineNum">    1699 </span>            :   }
<span class="lineNum">    1700 </span>            : 
<span class="lineNum">    1701 </span>            :   {
<span class="lineNum">    1702 </span>            :     /*
<span class="lineNum">    1703 </span>            :     ** We transfer the geometry from server to client as a
<span class="lineNum">    1704 </span>            :     ** hex or base64 encoded WKB byte-array. We will have to decode this
<span class="lineNum">    1705 </span>            :     ** data once we get it. Forcing to 2D (via the AsBinary function
<span class="lineNum">    1706 </span>            :     ** which includes a 2D force in it) removes ordinates we don't
<span class="lineNum">    1707 </span>            :     ** need, saving transfer and encode/decode time.
<span class="lineNum">    1708 </span>            :     */
<span class="lineNum">    1709 </span>            :     char *force2d = &quot;&quot;;
<span class="lineNum">    1710 </span>            : #if TRANSFER_ENCODING == 64
<span class="lineNum">    1711 </span>            :     const char *strGeomTemplate = &quot;encode(ST_AsBinary(%s(\&quot;%s\&quot;),'%s'),'base64') as geom,\&quot;%s\&quot;&quot;;
<span class="lineNum">    1712 </span>            : #elif TRANSFER_ENCODING == 256
<span class="lineNum">    1713 </span>            :     const char *strGeomTemplate = &quot;ST_AsBinary(%s(\&quot;%s\&quot;),'%s') as geom,\&quot;%s\&quot;::text&quot;;
<span class="lineNum">    1714 </span>            : #else
<span class="lineNum">    1715 </span>            :     const char *strGeomTemplate = &quot;encode(ST_AsBinary(%s(\&quot;%s\&quot;),'%s'),'hex') as geom,\&quot;%s\&quot;&quot;;
<span class="lineNum">    1716 </span>            : #endif
<span class="lineNum">    1717 </span><span class="lineCov">          1 :     if( layerinfo-&gt;force2d ) {</span>
<span class="lineNum">    1718 </span><span class="lineNoCov">          0 :       if( layerinfo-&gt;version &gt;= 20100 )</span>
<span class="lineNum">    1719 </span>            :         force2d = &quot;ST_Force2D&quot;;
<span class="lineNum">    1720 </span>            :       else
<span class="lineNum">    1721 </span>            :         force2d = &quot;ST_Force_2D&quot;;
<span class="lineNum">    1722 </span>            :     }
<span class="lineNum">    1723 </span><span class="lineCov">          1 :     else if( layerinfo-&gt;version &lt; 20000 )</span>
<span class="lineNum">    1724 </span>            :     {
<span class="lineNum">    1725 </span>            :         /* Use AsEWKB() to get 3D */
<span class="lineNum">    1726 </span>            : #if TRANSFER_ENCODING == 64
<span class="lineNum">    1727 </span>            :         strGeomTemplate = &quot;encode(AsEWKB(%s(\&quot;%s\&quot;),'%s'),'base64') as geom,\&quot;%s\&quot;&quot;;
<span class="lineNum">    1728 </span>            : #elif TRANSFER_ENCODING == 256
<span class="lineNum">    1729 </span>            :         strGeomTemplate = &quot;AsEWKB(%s(\&quot;%s\&quot;),'%s') as geom,\&quot;%s\&quot;::text&quot;;
<span class="lineNum">    1730 </span>            : #else
<span class="lineNum">    1731 </span>            :         strGeomTemplate = &quot;encode(AsEWKB(%s(\&quot;%s\&quot;),'%s'),'hex') as geom,\&quot;%s\&quot;&quot;;
<span class="lineNum">    1732 </span>            : #endif
<span class="lineNum">    1733 </span>            :     }
<span class="lineNum">    1734 </span><span class="lineCov">          1 :     strGeom = (char*)msSmallMalloc(strlen(strGeomTemplate) + strlen(force2d) + strlen(strEndian) + strlen(layerinfo-&gt;geomcolumn) + strlen(layerinfo-&gt;uid) + 1);</span>
<span class="lineNum">    1735 </span><span class="lineCov">          1 :     sprintf(strGeom, strGeomTemplate, force2d, layerinfo-&gt;geomcolumn, strEndian, layerinfo-&gt;uid);</span>
<span class="lineNum">    1736 </span>            :   }
<span class="lineNum">    1737 </span>            : 
<span class="lineNum">    1738 </span><span class="lineCov">          1 :   if( layer-&gt;debug &gt; 1 ) {</span>
<span class="lineNum">    1739 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISBuildSQLItems: %d items requested.\n&quot;,layer-&gt;numitems);</span>
<span class="lineNum">    1740 </span>            :   }
<span class="lineNum">    1741 </span>            : 
<span class="lineNum">    1742 </span>            :   /*
<span class="lineNum">    1743 </span>            :   ** Not requesting items? We just need geometry and unique id.
<span class="lineNum">    1744 </span>            :   */
<span class="lineNum">    1745 </span><span class="lineCov">          1 :   if (layer-&gt;numitems == 0) {</span>
<span class="lineNum">    1746 </span><span class="lineCov">          1 :     strItems = msStrdup(strGeom);</span>
<span class="lineNum">    1747 </span>            :   }
<span class="lineNum">    1748 </span>            :   /*
<span class="lineNum">    1749 </span>            :   ** Build SQL to pull all the items.
<span class="lineNum">    1750 </span>            :   */
<span class="lineNum">    1751 </span>            :   else {
<span class="lineNum">    1752 </span><span class="lineCov">          1 :     int length = strlen(strGeom) + 2;</span>
<span class="lineNum">    1753 </span>            :     int t;
<span class="lineNum">    1754 </span><span class="lineCov">          1 :     for ( t = 0; t &lt; layer-&gt;numitems; t++ ) {</span>
<span class="lineNum">    1755 </span><span class="lineCov">          1 :       length += strlen(layer-&gt;items[t]) + 3; /* itemname + &quot;&quot;, */</span>
<span class="lineNum">    1756 </span>            : #if TRANSFER_ENCODING == 256
<span class="lineNum">    1757 </span><span class="lineCov">          1 :       length +=6; /*add a ::text*/</span>
<span class="lineNum">    1758 </span>            : #endif
<span class="lineNum">    1759 </span>            :     }
<span class="lineNum">    1760 </span><span class="lineCov">          1 :     strItems = (char*)msSmallMalloc(length);</span>
<span class="lineNum">    1761 </span><span class="lineCov">          1 :     strItems[0] = '\0';</span>
<span class="lineNum">    1762 </span><span class="lineCov">          1 :     for ( t = 0; t &lt; layer-&gt;numitems; t++ ) {</span>
<span class="lineNum">    1763 </span><span class="lineCov">          1 :       strlcat(strItems, &quot;\&quot;&quot;, length);</span>
<span class="lineNum">    1764 </span><span class="lineCov">          1 :       strlcat(strItems, layer-&gt;items[t], length);</span>
<span class="lineNum">    1765 </span>            : #if TRANSFER_ENCODING == 256
<span class="lineNum">    1766 </span><span class="lineCov">          1 :       strlcat(strItems, &quot;\&quot;::text,&quot;, length);</span>
<span class="lineNum">    1767 </span>            : #else
<span class="lineNum">    1768 </span>            :       strlcat(strItems, &quot;\&quot;,&quot;, length);
<span class="lineNum">    1769 </span>            : #endif
<span class="lineNum">    1770 </span>            :     }
<span class="lineNum">    1771 </span><span class="lineCov">          1 :     strlcat(strItems, strGeom, length);</span>
<span class="lineNum">    1772 </span>            :   }
<span class="lineNum">    1773 </span>            : 
<span class="lineNum">    1774 </span><span class="lineCov">          1 :   free(strGeom);</span>
<span class="lineNum">    1775 </span><span class="lineCov">          1 :   return strItems;</span>
<span class="lineNum">    1776 </span>            : }
<span class="lineNum">    1777 </span>            : 
<span class="lineNum">    1778 </span>            : 
<span class="lineNum">    1779 </span>            : /*
<span class="lineNum">    1780 </span>            : ** msPostGISFindTableName()
<span class="lineNum">    1781 </span>            : **
<a name="1782"><span class="lineNum">    1782 </span>            : ** Returns malloc'ed char* that must be freed by caller.</a>
<span class="lineNum">    1783 </span>            : */
<span class="lineNum">    1784 </span><span class="lineCov">          1 : char *msPostGISFindTableName(char* fromsource)</span>
<span class="lineNum">    1785 </span>            : {
<span class="lineNum">    1786 </span>            :   char *f_table_name = NULL;
<span class="lineNum">    1787 </span><span class="lineCov">          1 :   char *pos = strstr(fromsource, &quot; &quot;);</span>
<span class="lineNum">    1788 </span>            :  
<span class="lineNum">    1789 </span><span class="lineCov">          1 :   if ( ! pos ) {</span>
<span class="lineNum">    1790 </span>            :     /* target table is one word */
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :     f_table_name = msStrdup(fromsource);</span>
<span class="lineNum">    1792 </span>            :   } else {
<span class="lineNum">    1793 </span>            :     /* target table is hiding in sub-select clause */
<span class="lineNum">    1794 </span><span class="lineCov">          1 :     pos = strcasestr(fromsource, &quot; from &quot;);</span>
<span class="lineNum">    1795 </span><span class="lineCov">          1 :     if ( pos ) {</span>
<span class="lineNum">    1796 </span>            :       char *pos_paren;
<span class="lineNum">    1797 </span>            :       char *pos_space;
<span class="lineNum">    1798 </span><span class="lineCov">          1 :       pos += 6; /* should be start of table name */</span>
<span class="lineNum">    1799 </span><span class="lineCov">          1 :       pos_paren = strstr(pos, &quot;)&quot;); /* first ) after table name */</span>
<span class="lineNum">    1800 </span><span class="lineCov">          1 :       pos_space = strstr(pos, &quot; &quot;); /* first space after table name */</span>
<span class="lineNum">    1801 </span><span class="lineCov">          1 :       if ( pos_space &lt; pos_paren ) {</span>
<span class="lineNum">    1802 </span>            :         /* found space first */
<span class="lineNum">    1803 </span><span class="lineCov">          1 :         f_table_name = (char*)msSmallMalloc(pos_space - pos + 1);</span>
<span class="lineNum">    1804 </span><span class="lineCov">          1 :         strlcpy(f_table_name, pos, pos_space - pos+1);</span>
<span class="lineNum">    1805 </span>            :       } else {
<span class="lineNum">    1806 </span>            :         /* found ) first */
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :         f_table_name = (char*)msSmallMalloc(pos_paren - pos + 1);</span>
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :         strlcpy(f_table_name, pos, pos_paren - pos+1);</span>
<span class="lineNum">    1809 </span>            :       }
<span class="lineNum">    1810 </span>            :     }
<span class="lineNum">    1811 </span>            :   }
<span class="lineNum">    1812 </span><span class="lineCov">          1 :   return f_table_name;</span>
<span class="lineNum">    1813 </span>            : }
<span class="lineNum">    1814 </span>            : 
<span class="lineNum">    1815 </span>            : 
<span class="lineNum">    1816 </span>            : /*
<span class="lineNum">    1817 </span>            : ** msPostGISBuildSQLSRID()
<span class="lineNum">    1818 </span>            : **
<a name="1819"><span class="lineNum">    1819 </span>            : ** Returns malloc'ed char* that must be freed by caller.</a>
<span class="lineNum">    1820 </span>            : */
<span class="lineNum">    1821 </span><span class="lineCov">          1 : char *msPostGISBuildSQLSRID(layerObj *layer)</span>
<span class="lineNum">    1822 </span>            : {
<span class="lineNum">    1823 </span>            : 
<span class="lineNum">    1824 </span>            :   char *strSRID = NULL;
<span class="lineNum">    1825 </span>            :   msPostGISLayerInfo *layerinfo = NULL;
<span class="lineNum">    1826 </span>            : 
<span class="lineNum">    1827 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISBuildSQLSRID called.\n&quot;);</span>
<span class="lineNum">    1829 </span>            :   }
<span class="lineNum">    1830 </span>            : 
<span class="lineNum">    1831 </span>            :   assert( layer-&gt;layerinfo != NULL);
<span class="lineNum">    1832 </span>            : 
<span class="lineNum">    1833 </span><span class="lineCov">          1 :   layerinfo = (msPostGISLayerInfo *)layer-&gt;layerinfo;</span>
<span class="lineNum">    1834 </span>            : 
<span class="lineNum">    1835 </span>            :   /* An SRID was already provided in the DATA line. */
<span class="lineNum">    1836 </span><span class="lineCov">          1 :   if ( layerinfo-&gt;srid &amp;&amp; (strlen(layerinfo-&gt;srid) &gt; 0) ) {</span>
<span class="lineNum">    1837 </span><span class="lineCov">          1 :     strSRID = msStrdup(layerinfo-&gt;srid);</span>
<span class="lineNum">    1838 </span><span class="lineCov">          1 :     if( layer-&gt;debug &gt; 1 ) {</span>
<span class="lineNum">    1839 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISBuildSQLSRID: SRID provided (%s)\n&quot;, strSRID);</span>
<span class="lineNum">    1840 </span>            :     }
<span class="lineNum">    1841 </span>            :   }
<span class="lineNum">    1842 </span>            :   /*
<span class="lineNum">    1843 </span>            :   ** No SRID in data line, so extract target table from the 'fromsource'.
<span class="lineNum">    1844 </span>            :   ** Either of form &quot;thetable&quot; (one word) or &quot;(select ... from thetable)&quot;
<span class="lineNum">    1845 </span>            :   ** or &quot;(select ... from thetable where ...)&quot;.
<span class="lineNum">    1846 </span>            :   */
<span class="lineNum">    1847 </span>            :   else {
<span class="lineNum">    1848 </span><span class="lineCov">          1 :     char *f_table_name = msPostGISFindTableName(layerinfo-&gt;fromsource);</span>
<span class="lineNum">    1849 </span>            :     char *strSRIDTemplate = &quot;find_srid('','%s','%s')&quot;;
<span class="lineNum">    1850 </span><span class="lineCov">          1 :     if( layer-&gt;debug &gt; 1 ) {</span>
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISBuildSQLSRID: Building find_srid line.\n&quot;);</span>
<span class="lineNum">    1852 </span>            :     }
<span class="lineNum">    1853 </span>            : 
<span class="lineNum">    1854 </span><span class="lineCov">          1 :     if (!f_table_name)</span>
<span class="lineNum">    1855 </span>            :       return NULL;  /* should not happen */
<span class="lineNum">    1856 </span>            : 
<span class="lineNum">    1857 </span><span class="lineCov">          1 :     strSRID = msSmallMalloc(strlen(strSRIDTemplate) + strlen(f_table_name) + strlen(layerinfo-&gt;geomcolumn) + 1);</span>
<span class="lineNum">    1858 </span><span class="lineCov">          1 :     sprintf(strSRID, strSRIDTemplate, f_table_name, layerinfo-&gt;geomcolumn);</span>
<span class="lineNum">    1859 </span><span class="lineCov">          1 :     free(f_table_name);</span>
<span class="lineNum">    1860 </span>            :   }
<span class="lineNum">    1861 </span><span class="lineCov">          1 :   return strSRID;</span>
<span class="lineNum">    1862 </span>            : }
<span class="lineNum">    1863 </span>            : 
<span class="lineNum">    1864 </span>            : 
<span class="lineNum">    1865 </span>            : /*
<span class="lineNum">    1866 </span>            : ** msPostGISReplaceBoxToken()
<span class="lineNum">    1867 </span>            : **
<span class="lineNum">    1868 </span>            : ** Convert a fromsource data statement into something usable by replacing the !BOX! token.
<span class="lineNum">    1869 </span>            : **
<a name="1870"><span class="lineNum">    1870 </span>            : ** Returns malloc'ed char* that must be freed by caller.</a>
<span class="lineNum">    1871 </span>            : */
<span class="lineNum">    1872 </span><span class="lineCov">          1 : static char *msPostGISReplaceBoxToken(layerObj *layer, rectObj *rect, const char *fromsource)</span>
<span class="lineNum">    1873 </span>            : {
<span class="lineNum">    1874 </span>            :   char *result = NULL;
<span class="lineNum">    1875 </span>            : 
<span class="lineNum">    1876 </span><span class="lineCov">          1 :   if ( strstr(fromsource, BOXTOKEN) &amp;&amp; rect ) {</span>
<span class="lineNum">    1877 </span>            :     char *strBox = NULL;
<span class="lineNum">    1878 </span>            :     char *strSRID = NULL;
<span class="lineNum">    1879 </span>            : 
<span class="lineNum">    1880 </span>            :     /* We see to set the SRID on the box, but to what SRID? */
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 :     strSRID = msPostGISBuildSQLSRID(layer);</span>
<span class="lineNum">    1882 </span><span class="lineNoCov">          0 :     if ( ! strSRID ) {</span>
<span class="lineNum">    1883 </span>            :       return NULL;
<span class="lineNum">    1884 </span>            :     }
<span class="lineNum">    1885 </span>            : 
<span class="lineNum">    1886 </span>            :     /* Create a suitable SQL string from the rectangle and SRID. */
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 :     strBox = msPostGISBuildSQLBox(layer, rect, strSRID);</span>
<span class="lineNum">    1888 </span><span class="lineNoCov">          0 :     if ( ! strBox ) {</span>
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :       msSetError(MS_MISCERR, &quot;Unable to build box SQL.&quot;, &quot;msPostGISReplaceBoxToken()&quot;);</span>
<span class="lineNum">    1890 </span><span class="lineNoCov">          0 :       if (strSRID) free(strSRID);</span>
<span class="lineNum">    1891 </span>            :       return NULL;
<span class="lineNum">    1892 </span>            :     }
<span class="lineNum">    1893 </span>            : 
<span class="lineNum">    1894 </span>            :     /* Do the substitution. */
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :     while ( strstr(fromsource, BOXTOKEN) ) {</span>
<span class="lineNum">    1896 </span>            :       char    *start, *end;
<span class="lineNum">    1897 </span>            :       char    *oldresult = result;
<span class="lineNum">    1898 </span>            :       size_t buffer_size = 0;
<span class="lineNum">    1899 </span>            :       start = strstr(fromsource, BOXTOKEN);
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :       end = start + BOXTOKENLENGTH;</span>
<span class="lineNum">    1901 </span>            : 
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :       buffer_size = (start - fromsource) + strlen(strBox) + strlen(end) +1;</span>
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :       result = (char*)msSmallMalloc(buffer_size);</span>
<span class="lineNum">    1904 </span>            : 
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :       strlcpy(result, fromsource, start - fromsource +1);</span>
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :       strlcpy(result + (start - fromsource), strBox, buffer_size-(start - fromsource));</span>
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :       strlcat(result, end, buffer_size);</span>
<span class="lineNum">    1908 </span>            : 
<span class="lineNum">    1909 </span>            :       fromsource = result;
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 :       if (oldresult != NULL)</span>
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :         free(oldresult);</span>
<span class="lineNum">    1912 </span>            :     }
<span class="lineNum">    1913 </span>            : 
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :     if (strSRID) free(strSRID);</span>
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :     if (strBox) free(strBox);</span>
<span class="lineNum">    1916 </span>            :   } else {
<span class="lineNum">    1917 </span><span class="lineCov">          1 :     result = msStrdup(fromsource);</span>
<span class="lineNum">    1918 </span>            :   }
<span class="lineNum">    1919 </span><span class="lineCov">          1 :   return result;</span>
<span class="lineNum">    1920 </span>            : 
<span class="lineNum">    1921 </span>            : }
<span class="lineNum">    1922 </span>            : 
<span class="lineNum">    1923 </span>            : /*
<span class="lineNum">    1924 </span>            : ** msPostGISBuildSQLFrom()
<span class="lineNum">    1925 </span>            : **
<a name="1926"><span class="lineNum">    1926 </span>            : ** Returns malloc'ed char* that must be freed by caller.</a>
<span class="lineNum">    1927 </span>            : */
<span class="lineNum">    1928 </span><span class="lineCov">          1 : char *msPostGISBuildSQLFrom(layerObj *layer, rectObj *rect)</span>
<span class="lineNum">    1929 </span>            : {
<span class="lineNum">    1930 </span>            :   char *strFrom = 0;
<span class="lineNum">    1931 </span>            :   msPostGISLayerInfo *layerinfo;
<span class="lineNum">    1932 </span>            : 
<span class="lineNum">    1933 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISBuildSQLFrom called.\n&quot;);</span>
<span class="lineNum">    1935 </span>            :   }
<span class="lineNum">    1936 </span>            : 
<span class="lineNum">    1937 </span>            :   assert( layer-&gt;layerinfo != NULL);
<span class="lineNum">    1938 </span>            : 
<span class="lineNum">    1939 </span><span class="lineCov">          1 :   layerinfo = (msPostGISLayerInfo *)layer-&gt;layerinfo;</span>
<span class="lineNum">    1940 </span>            : 
<span class="lineNum">    1941 </span><span class="lineCov">          1 :   if ( ! layerinfo-&gt;fromsource ) {</span>
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 :     msSetError(MS_MISCERR, &quot;Layerinfo-&gt;fromsource is not initialized.&quot;, &quot;msPostGISBuildSQLFrom()&quot;);</span>
<span class="lineNum">    1943 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1944 </span>            :   }
<span class="lineNum">    1945 </span>            : 
<span class="lineNum">    1946 </span>            :   /*
<span class="lineNum">    1947 </span>            :   ** If there's a '!BOX!' in our source we need to substitute the
<span class="lineNum">    1948 </span>            :   ** current rectangle for it...
<span class="lineNum">    1949 </span>            :   */
<span class="lineNum">    1950 </span><span class="lineCov">          1 :   strFrom = msPostGISReplaceBoxToken(layer, rect, layerinfo-&gt;fromsource);</span>
<span class="lineNum">    1951 </span>            : 
<span class="lineNum">    1952 </span><span class="lineCov">          1 :   return strFrom;</span>
<span class="lineNum">    1953 </span>            : }
<span class="lineNum">    1954 </span>            : 
<span class="lineNum">    1955 </span>            : /*
<span class="lineNum">    1956 </span>            : ** msPostGISBuildSQLWhere()
<span class="lineNum">    1957 </span>            : **
<a name="1958"><span class="lineNum">    1958 </span>            : ** Returns malloc'ed char* that must be freed by caller.</a>
<span class="lineNum">    1959 </span>            : */
<span class="lineNum">    1960 </span><span class="lineCov">          1 : char *msPostGISBuildSQLWhere(layerObj *layer, rectObj *rect, long *uid, rectObj *rectInOtherSRID, int otherSRID)</span>
<span class="lineNum">    1961 </span>            : {
<span class="lineNum">    1962 </span>            :   char *strRect = 0;
<span class="lineNum">    1963 </span>            :   char *strFilter1=0, *strFilter2=0;
<span class="lineNum">    1964 </span>            :   char *strUid = 0;
<span class="lineNum">    1965 </span>            :   char *strWhere = 0;
<span class="lineNum">    1966 </span>            :   char *strOrderBy = 0;
<span class="lineNum">    1967 </span>            :   char *strLimit = 0;
<span class="lineNum">    1968 </span>            :   char *strOffset = 0;
<span class="lineNum">    1969 </span>            :   size_t strRectLength = 0;
<span class="lineNum">    1970 </span>            :   size_t strFilterLength1=0, strFilterLength2=0;
<span class="lineNum">    1971 </span>            :   size_t strUidLength = 0;
<span class="lineNum">    1972 </span>            :   size_t strOrderByLength = 0;
<span class="lineNum">    1973 </span>            :   size_t strLimitLength = 0;
<span class="lineNum">    1974 </span>            :   size_t strOffsetLength = 0;
<span class="lineNum">    1975 </span>            :   size_t bufferSize = 0;
<span class="lineNum">    1976 </span>            :   int insert_and = 0;
<span class="lineNum">    1977 </span>            :   msPostGISLayerInfo *layerinfo;
<span class="lineNum">    1978 </span>            : 
<span class="lineNum">    1979 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISBuildSQLWhere called.\n&quot;);</span>
<span class="lineNum">    1981 </span>            :   }
<span class="lineNum">    1982 </span>            : 
<span class="lineNum">    1983 </span>            :   assert( layer-&gt;layerinfo != NULL);
<span class="lineNum">    1984 </span>            : 
<span class="lineNum">    1985 </span><span class="lineCov">          1 :   layerinfo = (msPostGISLayerInfo *)layer-&gt;layerinfo;</span>
<span class="lineNum">    1986 </span>            : 
<span class="lineNum">    1987 </span><span class="lineCov">          1 :   if ( ! layerinfo-&gt;fromsource ) {</span>
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :     msSetError(MS_MISCERR, &quot;Layerinfo-&gt;fromsource is not initialized.&quot;, &quot;msPostGISBuildSQLWhere()&quot;);</span>
<span class="lineNum">    1989 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1990 </span>            :   }
<span class="lineNum">    1991 </span>            : 
<span class="lineNum">    1992 </span>            :   /* Populate strLimit, if necessary. */
<span class="lineNum">    1993 </span><span class="lineCov">          1 :   if ( layerinfo-&gt;paging &amp;&amp; layer-&gt;maxfeatures &gt;= 0 ) {</span>
<span class="lineNum">    1994 </span>            :     static char *strLimitTemplate = &quot; limit %d&quot;;
<span class="lineNum">    1995 </span><span class="lineCov">          1 :     strLimit = msSmallMalloc(strlen(strLimitTemplate) + 12);</span>
<span class="lineNum">    1996 </span><span class="lineCov">          1 :     sprintf(strLimit, strLimitTemplate, layer-&gt;maxfeatures);</span>
<span class="lineNum">    1997 </span><span class="lineCov">          1 :     strLimitLength = strlen(strLimit);</span>
<span class="lineNum">    1998 </span>            :   }
<span class="lineNum">    1999 </span>            : 
<span class="lineNum">    2000 </span>            :   /* Populate strOffset, if necessary. */
<span class="lineNum">    2001 </span><span class="lineCov">          1 :   if ( layerinfo-&gt;paging &amp;&amp; layer-&gt;startindex &gt; 0 ) {</span>
<span class="lineNum">    2002 </span>            :     static char *strOffsetTemplate = &quot; offset %d&quot;;
<span class="lineNum">    2003 </span><span class="lineCov">          1 :     strOffset = msSmallMalloc(strlen(strOffsetTemplate) + 12);</span>
<span class="lineNum">    2004 </span><span class="lineCov">          1 :     sprintf(strOffset, strOffsetTemplate, layer-&gt;startindex-1);</span>
<span class="lineNum">    2005 </span><span class="lineCov">          1 :     strOffsetLength = strlen(strOffset);</span>
<span class="lineNum">    2006 </span>            :   }
<span class="lineNum">    2007 </span>            : 
<span class="lineNum">    2008 </span>            :   /* Populate strRect, if necessary. */
<span class="lineNum">    2009 </span><span class="lineCov">          1 :   if ( rect &amp;&amp; layerinfo-&gt;geomcolumn ) {</span>
<span class="lineNum">    2010 </span>            :     char *strBox = 0;
<span class="lineNum">    2011 </span>            :     char *strSRID = 0;
<span class="lineNum">    2012 </span>            :     size_t strBoxLength = 0;
<span class="lineNum">    2013 </span>            :     static const char *strRectTemplate = &quot;\&quot;%s\&quot; &amp;&amp; %s&quot;;
<span class="lineNum">    2014 </span>            : 
<span class="lineNum">    2015 </span>            :     /* We see to set the SRID on the box, but to what SRID? */
<span class="lineNum">    2016 </span><span class="lineCov">          1 :     strSRID = msPostGISBuildSQLSRID(layer);</span>
<span class="lineNum">    2017 </span><span class="lineCov">          1 :     if ( ! strSRID ) {</span>
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :       free( strLimit );</span>
<span class="lineNum">    2019 </span><span class="lineNoCov">          0 :       free( strOffset );</span>
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    2021 </span>            :     }
<span class="lineNum">    2022 </span>            : 
<span class="lineNum">    2023 </span><span class="lineCov">          1 :     strBox = msPostGISBuildSQLBox(layer, rect, strSRID);</span>
<span class="lineNum">    2024 </span><span class="lineCov">          1 :     msFree(strSRID);</span>
<span class="lineNum">    2025 </span><span class="lineCov">          1 :     if ( strBox ) {</span>
<span class="lineNum">    2026 </span><span class="lineCov">          1 :       strBoxLength = strlen(strBox);</span>
<span class="lineNum">    2027 </span>            :     } else {
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :       msSetError(MS_MISCERR, &quot;Unable to build box SQL.&quot;, &quot;msPostGISBuildSQLWhere()&quot;);</span>
<span class="lineNum">    2029 </span><span class="lineNoCov">          0 :       free( strLimit );</span>
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :       free( strOffset );</span>
<span class="lineNum">    2031 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    2032 </span>            :     }
<span class="lineNum">    2033 </span>            : 
<span class="lineNum">    2034 </span><span class="lineCov">          1 :     strRect = (char*)msSmallMalloc(strlen(strRectTemplate) + strBoxLength + strlen(layerinfo-&gt;geomcolumn) +1 );</span>
<span class="lineNum">    2035 </span><span class="lineCov">          1 :     sprintf(strRect, strRectTemplate, layerinfo-&gt;geomcolumn, strBox);</span>
<span class="lineNum">    2036 </span><span class="lineCov">          1 :     strRectLength = strlen(strRect);</span>
<span class="lineNum">    2037 </span><span class="lineCov">          1 :     free(strBox);</span>
<span class="lineNum">    2038 </span>            : 
<span class="lineNum">    2039 </span>            :     /* Combine with other rectangle  expressed in another SRS */
<span class="lineNum">    2040 </span>            :     /* (generally equivalent to the above in current code paths) */
<span class="lineNum">    2041 </span><span class="lineCov">          1 :     if( rectInOtherSRID != NULL &amp;&amp; otherSRID &gt; 0 )</span>
<span class="lineNum">    2042 </span>            :     {
<span class="lineNum">    2043 </span>            :       char* strRectOtherSRID;
<span class="lineNum">    2044 </span>            :       static const char *strRectOtherSRIDTemplate = &quot;NOT ST_Disjoint(ST_Transform(%s,%d),%s)&quot;;
<span class="lineNum">    2045 </span>            :       char szSRID[32];
<span class="lineNum">    2046 </span>            :       char* strTmp = NULL;
<span class="lineNum">    2047 </span>            : 
<span class="lineNum">    2048 </span>            :       sprintf(szSRID, &quot;%d&quot;, otherSRID);
<span class="lineNum">    2049 </span>            :  
<span class="lineNum">    2050 </span><span class="lineCov">          1 :       strBox = msPostGISBuildSQLBox(layer, rectInOtherSRID, szSRID);</span>
<span class="lineNum">    2051 </span><span class="lineCov">          1 :       if ( strBox ) {</span>
<span class="lineNum">    2052 </span><span class="lineCov">          1 :         strBoxLength = strlen(strBox);</span>
<span class="lineNum">    2053 </span>            :       } else {
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :         msSetError(MS_MISCERR, &quot;Unable to build box SQL.&quot;, &quot;msPostGISBuildSQLWhere()&quot;);</span>
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 :         free( strLimit );</span>
<span class="lineNum">    2056 </span><span class="lineNoCov">          0 :         free( strOffset );</span>
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    2058 </span>            :       }
<span class="lineNum">    2059 </span>            : 
<span class="lineNum">    2060 </span><span class="lineCov">          1 :       strRectOtherSRID = (char*)msSmallMalloc(strlen(strRectOtherSRIDTemplate) + strBoxLength + strlen(layerinfo-&gt;geomcolumn) +1 );</span>
<span class="lineNum">    2061 </span><span class="lineCov">          1 :       sprintf(strRectOtherSRID, strRectOtherSRIDTemplate, layerinfo-&gt;geomcolumn, otherSRID, strBox);</span>
<span class="lineNum">    2062 </span><span class="lineCov">          1 :       free(strBox);</span>
<span class="lineNum">    2063 </span>            : 
<span class="lineNum">    2064 </span><span class="lineCov">          1 :       strTmp = msStringConcatenate(strTmp, &quot;((&quot;);</span>
<span class="lineNum">    2065 </span><span class="lineCov">          1 :       strTmp = msStringConcatenate(strTmp, strRect);</span>
<span class="lineNum">    2066 </span><span class="lineCov">          1 :       strTmp = msStringConcatenate(strTmp, &quot;) AND &quot;);</span>
<span class="lineNum">    2067 </span><span class="lineCov">          1 :       strTmp = msStringConcatenate(strTmp, strRectOtherSRID);</span>
<span class="lineNum">    2068 </span><span class="lineCov">          1 :       strTmp = msStringConcatenate(strTmp, &quot;)&quot;);</span>
<span class="lineNum">    2069 </span>            : 
<span class="lineNum">    2070 </span><span class="lineCov">          1 :       msFree(strRect);</span>
<span class="lineNum">    2071 </span><span class="lineCov">          1 :       msFree(strRectOtherSRID);</span>
<span class="lineNum">    2072 </span>            :       strRect = strTmp;
<span class="lineNum">    2073 </span><span class="lineCov">          1 :       strRectLength = strlen(strRect);</span>
<span class="lineNum">    2074 </span>            :     }
<span class="lineNum">    2075 </span><span class="lineCov">          1 :     else if( rectInOtherSRID != NULL &amp;&amp; otherSRID &lt; 0 )</span>
<span class="lineNum">    2076 </span>            :     {
<span class="lineNum">    2077 </span>            :       char* strSRID;
<span class="lineNum">    2078 </span>            :       char* strRectOtherSRID;
<span class="lineNum">    2079 </span>            :       static const char *strRectOtherSRIDTemplate = &quot;NOT ST_Disjoint(%s,%s)&quot;;
<span class="lineNum">    2080 </span>            :       char* strTmp = NULL;
<span class="lineNum">    2081 </span>            : 
<span class="lineNum">    2082 </span><span class="lineCov">          1 :       strSRID = msPostGISBuildSQLSRID(layer);</span>
<span class="lineNum">    2083 </span><span class="lineCov">          1 :       if ( ! strSRID ) {</span>
<span class="lineNum">    2084 </span><span class="lineNoCov">          0 :         free( strLimit );</span>
<span class="lineNum">    2085 </span><span class="lineNoCov">          0 :         free( strOffset );</span>
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    2087 </span>            :       }
<span class="lineNum">    2088 </span><span class="lineCov">          1 :       strBox = msPostGISBuildSQLBox(layer, rectInOtherSRID, strSRID);</span>
<span class="lineNum">    2089 </span><span class="lineCov">          1 :       msFree(strSRID);</span>
<span class="lineNum">    2090 </span><span class="lineCov">          1 :       if ( strBox ) {</span>
<span class="lineNum">    2091 </span><span class="lineCov">          1 :         strBoxLength = strlen(strBox);</span>
<span class="lineNum">    2092 </span>            :       } else {
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :         msSetError(MS_MISCERR, &quot;Unable to build box SQL.&quot;, &quot;msPostGISBuildSQLWhere()&quot;);</span>
<span class="lineNum">    2094 </span><span class="lineNoCov">          0 :         free( strLimit );</span>
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :         free( strOffset );</span>
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">    2097 </span>            :       }
<span class="lineNum">    2098 </span>            : 
<span class="lineNum">    2099 </span><span class="lineCov">          1 :       strRectOtherSRID = (char*)msSmallMalloc(strlen(strRectOtherSRIDTemplate) + strBoxLength + strlen(layerinfo-&gt;geomcolumn) +1 );</span>
<span class="lineNum">    2100 </span><span class="lineCov">          1 :       sprintf(strRectOtherSRID, strRectOtherSRIDTemplate, layerinfo-&gt;geomcolumn, strBox);</span>
<span class="lineNum">    2101 </span><span class="lineCov">          1 :       free(strBox);</span>
<span class="lineNum">    2102 </span>            : 
<span class="lineNum">    2103 </span><span class="lineCov">          1 :       strTmp = msStringConcatenate(strTmp, &quot;((&quot;);</span>
<span class="lineNum">    2104 </span><span class="lineCov">          1 :       strTmp = msStringConcatenate(strTmp, strRect);</span>
<span class="lineNum">    2105 </span><span class="lineCov">          1 :       strTmp = msStringConcatenate(strTmp, &quot;) AND &quot;);</span>
<span class="lineNum">    2106 </span><span class="lineCov">          1 :       strTmp = msStringConcatenate(strTmp, strRectOtherSRID);</span>
<span class="lineNum">    2107 </span><span class="lineCov">          1 :       strTmp = msStringConcatenate(strTmp, &quot;)&quot;);</span>
<span class="lineNum">    2108 </span>            : 
<span class="lineNum">    2109 </span><span class="lineCov">          1 :       msFree(strRect);</span>
<span class="lineNum">    2110 </span><span class="lineCov">          1 :       msFree(strRectOtherSRID);</span>
<span class="lineNum">    2111 </span>            :       strRect = strTmp;
<span class="lineNum">    2112 </span><span class="lineCov">          1 :       strRectLength = strlen(strRect);</span>
<span class="lineNum">    2113 </span>            :     }
<span class="lineNum">    2114 </span>            :   }
<span class="lineNum">    2115 </span>            : 
<span class="lineNum">    2116 </span>            :   /* Handle a translated filter (RFC91). */
<span class="lineNum">    2117 </span><span class="lineCov">          1 :   if ( layer-&gt;filter.native_string ) { </span>
<span class="lineNum">    2118 </span>            :     static char *strFilterTemplate = &quot;(%s)&quot;;
<span class="lineNum">    2119 </span><span class="lineCov">          1 :     strFilter1 = (char *) msSmallMalloc(strlen(strFilterTemplate) + strlen(layer-&gt;filter.native_string)+1);</span>
<span class="lineNum">    2120 </span><span class="lineCov">          1 :     sprintf(strFilter1, strFilterTemplate, layer-&gt;filter.native_string);</span>
<span class="lineNum">    2121 </span><span class="lineCov">          1 :     strFilterLength1 = strlen(strFilter1);</span>
<span class="lineNum">    2122 </span>            :   }
<span class="lineNum">    2123 </span>            : 
<span class="lineNum">    2124 </span>            :   /* Handle a native filter set as a PROCESSING option (#5001). */
<span class="lineNum">    2125 </span><span class="lineCov">          1 :   if( msLayerGetProcessingKey(layer, &quot;NATIVE_FILTER&quot;) != NULL ) {</span>
<span class="lineNum">    2126 </span>            :     static char *strFilterTemplate = &quot;(%s)&quot;;
<span class="lineNum">    2127 </span><span class="lineCov">          1 :     char *native_filter = msLayerGetProcessingKey(layer, &quot;NATIVE_FILTER&quot;);</span>
<span class="lineNum">    2128 </span><span class="lineCov">          1 :     strFilter2 = (char *) msSmallMalloc(strlen(strFilterTemplate) + strlen(native_filter)+1);</span>
<span class="lineNum">    2129 </span><span class="lineCov">          1 :     sprintf(strFilter2, strFilterTemplate, native_filter);</span>
<span class="lineNum">    2130 </span><span class="lineCov">          1 :     strFilterLength2 = strlen(strFilter2);</span>
<span class="lineNum">    2131 </span>            :   }
<span class="lineNum">    2132 </span>            : 
<span class="lineNum">    2133 </span>            :   /* Populate strUid, if necessary. */
<span class="lineNum">    2134 </span><span class="lineCov">          1 :   if ( uid ) {</span>
<span class="lineNum">    2135 </span>            :     static char *strUidTemplate = &quot;\&quot;%s\&quot; = %ld&quot;;
<span class="lineNum">    2136 </span><span class="lineCov">          1 :     strUid = (char*)msSmallMalloc(strlen(strUidTemplate) + strlen(layerinfo-&gt;uid) + 64);</span>
<span class="lineNum">    2137 </span><span class="lineCov">          1 :     sprintf(strUid, strUidTemplate, layerinfo-&gt;uid, *uid);</span>
<span class="lineNum">    2138 </span><span class="lineCov">          1 :     strUidLength = strlen(strUid);</span>
<span class="lineNum">    2139 </span>            :   }
<span class="lineNum">    2140 </span>            : 
<span class="lineNum">    2141 </span>            :   /* Populate strOrderBy, if necessary */
<span class="lineNum">    2142 </span><span class="lineCov">          1 :   if( layer-&gt;sortBy.nProperties &gt; 0 ) {</span>
<span class="lineNum">    2143 </span><span class="lineCov">          1 :     char* pszTmp = msLayerBuildSQLOrderBy(layer);</span>
<span class="lineNum">    2144 </span><span class="lineCov">          1 :     strOrderBy = msStringConcatenate(strOrderBy, &quot; ORDER BY &quot;);</span>
<span class="lineNum">    2145 </span><span class="lineCov">          1 :     strOrderBy = msStringConcatenate(strOrderBy, pszTmp);</span>
<span class="lineNum">    2146 </span><span class="lineCov">          1 :     msFree(pszTmp);</span>
<span class="lineNum">    2147 </span><span class="lineCov">          1 :     strOrderByLength = strlen(strOrderBy);</span>
<span class="lineNum">    2148 </span>            :   }
<span class="lineNum">    2149 </span>            : 
<span class="lineNum">    2150 </span><span class="lineCov">          1 :   bufferSize = strRectLength + 5 + (strFilterLength1 + 5) + (strFilterLength2 + 5) + strUidLength</span>
<span class="lineNum">    2151 </span><span class="lineCov">          1 :                + strLimitLength + strOffsetLength + strOrderByLength + 1;</span>
<span class="lineNum">    2152 </span><span class="lineCov">          1 :   strWhere = (char*)msSmallMalloc(bufferSize);</span>
<span class="lineNum">    2153 </span><span class="lineCov">          1 :   *strWhere = '\0';</span>
<span class="lineNum">    2154 </span><span class="lineCov">          1 :   if ( strRect ) {</span>
<span class="lineNum">    2155 </span><span class="lineCov">          1 :     strlcat(strWhere, strRect, bufferSize);</span>
<span class="lineNum">    2156 </span>            :     insert_and++;
<span class="lineNum">    2157 </span><span class="lineCov">          1 :     free(strRect);</span>
<span class="lineNum">    2158 </span>            :   }
<span class="lineNum">    2159 </span><span class="lineCov">          1 :   if ( strFilter1 ) {</span>
<span class="lineNum">    2160 </span><span class="lineCov">          1 :     if ( insert_and ) {</span>
<span class="lineNum">    2161 </span><span class="lineCov">          1 :       strlcat(strWhere, &quot; and &quot;, bufferSize);</span>
<span class="lineNum">    2162 </span>            :     }
<span class="lineNum">    2163 </span><span class="lineCov">          1 :     strlcat(strWhere, strFilter1, bufferSize);</span>
<span class="lineNum">    2164 </span><span class="lineCov">          1 :     free(strFilter1);</span>
<span class="lineNum">    2165 </span><span class="lineCov">          1 :     insert_and++;</span>
<span class="lineNum">    2166 </span>            :   }
<span class="lineNum">    2167 </span><span class="lineCov">          1 :   if ( strFilter2 ) {</span>
<span class="lineNum">    2168 </span><span class="lineCov">          1 :     if ( insert_and ) {</span>
<span class="lineNum">    2169 </span><span class="lineCov">          1 :       strlcat(strWhere, &quot; and &quot;, bufferSize);</span>
<span class="lineNum">    2170 </span>            :     }
<span class="lineNum">    2171 </span><span class="lineCov">          1 :     strlcat(strWhere, strFilter2, bufferSize);</span>
<span class="lineNum">    2172 </span><span class="lineCov">          1 :     free(strFilter2);</span>
<span class="lineNum">    2173 </span><span class="lineCov">          1 :     insert_and++;</span>
<span class="lineNum">    2174 </span>            :   }
<span class="lineNum">    2175 </span><span class="lineCov">          1 :   if ( strUid ) {</span>
<span class="lineNum">    2176 </span><span class="lineCov">          1 :     if ( insert_and ) {</span>
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 :       strlcat(strWhere, &quot; and &quot;, bufferSize);</span>
<span class="lineNum">    2178 </span>            :     }
<span class="lineNum">    2179 </span><span class="lineCov">          1 :     strlcat(strWhere, strUid, bufferSize);</span>
<span class="lineNum">    2180 </span><span class="lineCov">          1 :     free(strUid);</span>
<span class="lineNum">    2181 </span>            :     insert_and++;
<span class="lineNum">    2182 </span>            :   }
<span class="lineNum">    2183 </span>            : 
<span class="lineNum">    2184 </span><span class="lineCov">          1 :   if ( strOrderBy ) {</span>
<span class="lineNum">    2185 </span><span class="lineCov">          1 :     strlcat(strWhere, strOrderBy, bufferSize);</span>
<span class="lineNum">    2186 </span><span class="lineCov">          1 :     free(strOrderBy);</span>
<span class="lineNum">    2187 </span>            :   }
<span class="lineNum">    2188 </span>            : 
<span class="lineNum">    2189 </span><span class="lineCov">          1 :   if ( strLimit ) {</span>
<span class="lineNum">    2190 </span><span class="lineCov">          1 :     strlcat(strWhere, strLimit, bufferSize);</span>
<span class="lineNum">    2191 </span><span class="lineCov">          1 :     free(strLimit);</span>
<span class="lineNum">    2192 </span>            :   }
<span class="lineNum">    2193 </span><span class="lineCov">          1 :   if ( strOffset ) {</span>
<span class="lineNum">    2194 </span><span class="lineCov">          1 :     strlcat(strWhere, strOffset, bufferSize);</span>
<span class="lineNum">    2195 </span><span class="lineCov">          1 :     free(strOffset);</span>
<span class="lineNum">    2196 </span>            :   }
<span class="lineNum">    2197 </span>            : 
<span class="lineNum">    2198 </span><span class="lineCov">          1 :   return strWhere;</span>
<span class="lineNum">    2199 </span>            : }
<span class="lineNum">    2200 </span>            : 
<span class="lineNum">    2201 </span>            : /*
<span class="lineNum">    2202 </span>            : ** msPostGISBuildSQL()
<span class="lineNum">    2203 </span>            : **
<span class="lineNum">    2204 </span>            : ** rect is the search rectangle in layer SRS. It can be set to NULL
<span class="lineNum">    2205 </span>            : ** uid can be set to NULL
<span class="lineNum">    2206 </span>            : ** rectInOtherSRID is an additional rectangle potentially in another SRS. It can be set to NULL.
<span class="lineNum">    2207 </span>            : ** Only used if rect != NULL
<span class="lineNum">    2208 </span>            : ** otherSRID is the SRID of the additional rectangle. It can be set to -1 if
<span class="lineNum">    2209 </span>            : ** rectInOtherSRID is in the SRID of the layer.
<span class="lineNum">    2210 </span>            : **
<a name="2211"><span class="lineNum">    2211 </span>            : ** Returns malloc'ed char* that must be freed by caller.</a>
<span class="lineNum">    2212 </span>            : */
<span class="lineNum">    2213 </span><span class="lineCov">          1 : char *msPostGISBuildSQL(layerObj *layer, rectObj *rect, long *uid, rectObj *rectInOtherSRID, int otherSRID)</span>
<span class="lineNum">    2214 </span>            : {
<span class="lineNum">    2215 </span>            : 
<span class="lineNum">    2216 </span>            :   msPostGISLayerInfo *layerinfo = 0;
<span class="lineNum">    2217 </span>            :   char *strFrom = 0;
<span class="lineNum">    2218 </span>            :   char *strItems = 0;
<span class="lineNum">    2219 </span>            :   char *strWhere = 0;
<span class="lineNum">    2220 </span>            :   char *strSQL = 0;
<span class="lineNum">    2221 </span>            :   static char *strSQLTemplate0 = &quot;select %s from %s where %s&quot;;
<span class="lineNum">    2222 </span>            :   static char *strSQLTemplate1 = &quot;select %s from %s%s&quot;;
<span class="lineNum">    2223 </span>            :   char *strSQLTemplate = 0;
<span class="lineNum">    2224 </span>            : 
<span class="lineNum">    2225 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISBuildSQL called.\n&quot;);</span>
<span class="lineNum">    2227 </span>            :   }
<span class="lineNum">    2228 </span>            : 
<span class="lineNum">    2229 </span>            :   assert( layer-&gt;layerinfo != NULL);
<span class="lineNum">    2230 </span>            : 
<span class="lineNum">    2231 </span><span class="lineCov">          1 :   layerinfo = (msPostGISLayerInfo *)layer-&gt;layerinfo;</span>
<span class="lineNum">    2232 </span>            : 
<span class="lineNum">    2233 </span><span class="lineCov">          1 :   strItems = msPostGISBuildSQLItems(layer);</span>
<span class="lineNum">    2234 </span><span class="lineCov">          1 :   if ( ! strItems ) {</span>
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 :     msSetError(MS_MISCERR, &quot;Failed to build SQL items.&quot;, &quot;msPostGISBuildSQL()&quot;);</span>
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    2237 </span>            :   }
<span class="lineNum">    2238 </span>            : 
<span class="lineNum">    2239 </span><span class="lineCov">          1 :   strFrom = msPostGISBuildSQLFrom(layer, rect);</span>
<span class="lineNum">    2240 </span>            : 
<span class="lineNum">    2241 </span><span class="lineCov">          1 :   if ( ! strFrom ) {</span>
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :     msSetError(MS_MISCERR, &quot;Failed to build SQL 'from'.&quot;, &quot;msPostGISBuildSQL()&quot;);</span>
<span class="lineNum">    2243 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    2244 </span>            :   }
<span class="lineNum">    2245 </span>            : 
<span class="lineNum">    2246 </span>            :   /* If there's BOX hackery going on, we don't want to append a box index test at
<span class="lineNum">    2247 </span>            :      the end of the query, the user is going to be responsible for making things
<span class="lineNum">    2248 </span>            :      work with their hackery. */
<span class="lineNum">    2249 </span><span class="lineCov">          1 :   if ( strstr(layerinfo-&gt;fromsource, BOXTOKEN) )</span>
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :     strWhere = msPostGISBuildSQLWhere(layer, NULL, uid, rectInOtherSRID, otherSRID);</span>
<span class="lineNum">    2251 </span>            :   else
<span class="lineNum">    2252 </span><span class="lineCov">          1 :     strWhere = msPostGISBuildSQLWhere(layer, rect, uid, rectInOtherSRID, otherSRID);</span>
<span class="lineNum">    2253 </span>            : 
<span class="lineNum">    2254 </span><span class="lineCov">          1 :   if ( ! strWhere ) {</span>
<span class="lineNum">    2255 </span><span class="lineNoCov">          0 :     msSetError(MS_MISCERR, &quot;Failed to build SQL 'where'.&quot;, &quot;msPostGISBuildSQL()&quot;);</span>
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    2257 </span>            :   }
<span class="lineNum">    2258 </span>            : 
<span class="lineNum">    2259 </span><span class="lineCov">          1 :   strSQLTemplate = strlen(strWhere) ? strSQLTemplate0 : strSQLTemplate1;</span>
<span class="lineNum">    2260 </span>            : 
<span class="lineNum">    2261 </span><span class="lineCov">          1 :   strSQL = msSmallMalloc(strlen(strSQLTemplate) + strlen(strFrom) + strlen(strItems) + strlen(strWhere) + 1);</span>
<span class="lineNum">    2262 </span>            :   sprintf(strSQL, strSQLTemplate, strItems, strFrom, strWhere);
<span class="lineNum">    2263 </span>            : 
<span class="lineNum">    2264 </span><span class="lineCov">          1 :   free(strItems);</span>
<span class="lineNum">    2265 </span><span class="lineCov">          1 :   free(strFrom);</span>
<span class="lineNum">    2266 </span><span class="lineCov">          1 :   free(strWhere);</span>
<span class="lineNum">    2267 </span>            : 
<span class="lineNum">    2268 </span><span class="lineCov">          1 :   return strSQL;</span>
<span class="lineNum">    2269 </span>            : }
<a name="2270"><span class="lineNum">    2270 </span>            : </a>
<span class="lineNum">    2271 </span>            : #define wkbstaticsize 4096
<span class="lineNum">    2272 </span><span class="lineCov">          1 : int msPostGISReadShape(layerObj *layer, shapeObj *shape)</span>
<span class="lineNum">    2273 </span>            : {
<span class="lineNum">    2274 </span>            : 
<span class="lineNum">    2275 </span>            :   char *wkbstr = NULL;
<span class="lineNum">    2276 </span>            :   unsigned char wkbstatic[wkbstaticsize];
<span class="lineNum">    2277 </span>            :   unsigned char *wkb = NULL;
<span class="lineNum">    2278 </span>            :   wkbObj w;
<span class="lineNum">    2279 </span>            :   msPostGISLayerInfo *layerinfo = NULL;
<span class="lineNum">    2280 </span>            :   int result = 0;
<span class="lineNum">    2281 </span>            :   int wkbstrlen = 0;
<span class="lineNum">    2282 </span>            : 
<span class="lineNum">    2283 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISReadShape called.\n&quot;);</span>
<span class="lineNum">    2285 </span>            :   }
<span class="lineNum">    2286 </span>            : 
<span class="lineNum">    2287 </span>            :   assert(layer-&gt;layerinfo != NULL);
<span class="lineNum">    2288 </span><span class="lineCov">          1 :   layerinfo = (msPostGISLayerInfo*) layer-&gt;layerinfo;</span>
<span class="lineNum">    2289 </span>            : 
<span class="lineNum">    2290 </span>            :   /* Retrieve the geometry. */
<span class="lineNum">    2291 </span><span class="lineCov">          1 :   wkbstr = (char*)PQgetvalue(layerinfo-&gt;pgresult, layerinfo-&gt;rownum, layer-&gt;numitems );</span>
<span class="lineNum">    2292 </span><span class="lineCov">          1 :   wkbstrlen = PQgetlength(layerinfo-&gt;pgresult, layerinfo-&gt;rownum, layer-&gt;numitems);</span>
<span class="lineNum">    2293 </span>            : 
<span class="lineNum">    2294 </span><span class="lineCov">          1 :   if ( ! wkbstr ) {</span>
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR, &quot;WKB returned is null!&quot;, &quot;msPostGISReadShape()&quot;);</span>
<span class="lineNum">    2296 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    2297 </span>            :   }
<span class="lineNum">    2298 </span>            : 
<span class="lineNum">    2299 </span><span class="lineCov">          1 :   if(wkbstrlen &gt; wkbstaticsize) {</span>
<span class="lineNum">    2300 </span><span class="lineCov">          1 :     wkb = calloc(wkbstrlen, sizeof(char));</span>
<span class="lineNum">    2301 </span>            :   } else {
<span class="lineNum">    2302 </span>            :     wkb = wkbstatic;
<span class="lineNum">    2303 </span>            :   }
<span class="lineNum">    2304 </span>            : #if TRANSFER_ENCODING == 64
<span class="lineNum">    2305 </span>            :   result = msPostGISBase64Decode(wkb, wkbstr, wkbstrlen - 1);
<span class="lineNum">    2306 </span>            :   w.size = (wkbstrlen - 1)/2;
<span class="lineNum">    2307 </span>            : #elif TRANSFER_ENCODING == 256
<span class="lineNum">    2308 </span>            :   result = 1;
<span class="lineNum">    2309 </span><span class="lineCov">          1 :   memcpy(wkb, wkbstr, wkbstrlen);</span>
<span class="lineNum">    2310 </span><span class="lineCov">          1 :   w.size = wkbstrlen;</span>
<span class="lineNum">    2311 </span>            : #else
<span class="lineNum">    2312 </span>            :   result = msPostGISHexDecode(wkb, wkbstr, wkbstrlen);
<span class="lineNum">    2313 </span>            :   w.size = (wkbstrlen - 1)/2;
<span class="lineNum">    2314 </span>            : #endif
<span class="lineNum">    2315 </span>            : 
<span class="lineNum">    2316 </span>            :   if( ! result ) {
<span class="lineNum">    2317 </span>            :     if(wkb!=wkbstatic) free(wkb);
<span class="lineNum">    2318 </span>            :     return MS_FAILURE;
<span class="lineNum">    2319 </span>            :   }
<span class="lineNum">    2320 </span>            : 
<span class="lineNum">    2321 </span>            :   /* Initialize our wkbObj */
<span class="lineNum">    2322 </span><span class="lineCov">          1 :   w.wkb = (char*)wkb;</span>
<span class="lineNum">    2323 </span><span class="lineCov">          1 :   w.ptr = w.wkb;</span>
<span class="lineNum">    2324 </span>            : 
<span class="lineNum">    2325 </span>            :   /* Set the type map according to what version of PostGIS we are dealing with */
<span class="lineNum">    2326 </span><span class="lineCov">          1 :   if( layerinfo-&gt;version &gt;= 20000 ) /* PostGIS 2.0+ */</span>
<span class="lineNum">    2327 </span><span class="lineCov">          1 :     w.typemap = wkb_postgis20;</span>
<span class="lineNum">    2328 </span>            :   else
<span class="lineNum">    2329 </span>            :   {
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 :     w.typemap = wkb_postgis15;</span>
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :     if( layerinfo-&gt;force2d == MS_FALSE )</span>
<span class="lineNum">    2332 </span>            :     {
<span class="lineNum">    2333 </span>            :         /* Is there SRID ? Skip it */
<span class="lineNum">    2334 </span><span class="lineNoCov">          0 :         if( w.size &gt;= 9 &amp;&amp; (w.ptr[4] &amp; 0x20) != 0 )</span>
<span class="lineNum">    2335 </span>            :         {
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 :             w.ptr[5] = w.ptr[1];</span>
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 :             w.ptr[6] = w.ptr[2];</span>
<span class="lineNum">    2338 </span><span class="lineNoCov">          0 :             w.ptr[7] = w.ptr[3];</span>
<span class="lineNum">    2339 </span><span class="lineNoCov">          0 :             w.ptr[8] = w.ptr[4] &amp; ~(0x20);</span>
<span class="lineNum">    2340 </span><span class="lineNoCov">          0 :             w.ptr[4] = 1;</span>
<span class="lineNum">    2341 </span><span class="lineNoCov">          0 :             w.ptr += 4;</span>
<span class="lineNum">    2342 </span><span class="lineNoCov">          0 :             w.size -= 4;</span>
<span class="lineNum">    2343 </span>            :         }
<span class="lineNum">    2344 </span>            :     }
<span class="lineNum">    2345 </span>            :   }
<span class="lineNum">    2346 </span>            : 
<span class="lineNum">    2347 </span><span class="lineCov">          1 :   switch (layer-&gt;type) {</span>
<span class="lineNum">    2348 </span>            : 
<span class="lineNum">    2349 </span>            :     case MS_LAYER_POINT:
<span class="lineNum">    2350 </span><span class="lineCov">          1 :       shape-&gt;type = MS_SHAPE_POINT;</span>
<span class="lineNum">    2351 </span><span class="lineCov">          1 :       result = wkbConvGeometryToShape(&amp;w, shape);</span>
<span class="lineNum">    2352 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    2353 </span>            : 
<span class="lineNum">    2354 </span>            :     case MS_LAYER_LINE:
<span class="lineNum">    2355 </span><span class="lineCov">          1 :       shape-&gt;type = MS_SHAPE_LINE;</span>
<span class="lineNum">    2356 </span><span class="lineCov">          1 :       result = wkbConvGeometryToShape(&amp;w, shape);</span>
<span class="lineNum">    2357 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    2358 </span>            : 
<span class="lineNum">    2359 </span>            :     case MS_LAYER_POLYGON:
<span class="lineNum">    2360 </span><span class="lineCov">          1 :       shape-&gt;type = MS_SHAPE_POLYGON;</span>
<span class="lineNum">    2361 </span><span class="lineCov">          1 :       result = wkbConvGeometryToShape(&amp;w, shape);</span>
<span class="lineNum">    2362 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    2363 </span>            : 
<span class="lineNum">    2364 </span>            :     case MS_LAYER_QUERY:
<span class="lineNum">    2365 </span>            :     case MS_LAYER_CHART:
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :       result = msPostGISFindBestType(&amp;w, shape);</span>
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2368 </span>            : 
<span class="lineNum">    2369 </span>            :     case MS_LAYER_RASTER:
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :       msDebug(&quot;Ignoring MS_LAYER_RASTER in msPostGISReadShape.\n&quot;);</span>
<span class="lineNum">    2371 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2372 </span>            : 
<span class="lineNum">    2373 </span>            :     case MS_LAYER_CIRCLE:
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 :       msDebug(&quot;Ignoring MS_LAYER_RASTER in msPostGISReadShape.\n&quot;);</span>
<span class="lineNum">    2375 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2376 </span>            : 
<span class="lineNum">    2377 </span>            :     default:
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 :       msDebug(&quot;Unsupported layer type in msPostGISReadShape()!\n&quot;);</span>
<span class="lineNum">    2379 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    2380 </span>            :   }
<span class="lineNum">    2381 </span>            : 
<span class="lineNum">    2382 </span>            :   /* All done with WKB geometry, free it! */
<span class="lineNum">    2383 </span><span class="lineCov">          1 :   if(wkb!=wkbstatic) free(wkb);</span>
<span class="lineNum">    2384 </span>            : 
<span class="lineNum">    2385 </span><span class="lineCov">          1 :   if (result != MS_FAILURE) {</span>
<span class="lineNum">    2386 </span>            :     int t;
<span class="lineNum">    2387 </span>            :     long uid;
<span class="lineNum">    2388 </span>            :     char *tmp;
<span class="lineNum">    2389 </span>            :     /* Found a drawable shape, so now retreive the attributes. */
<span class="lineNum">    2390 </span>            : 
<span class="lineNum">    2391 </span><span class="lineCov">          1 :     shape-&gt;values = (char**) msSmallMalloc(sizeof(char*) * layer-&gt;numitems);</span>
<span class="lineNum">    2392 </span><span class="lineCov">          1 :     for ( t = 0; t &lt; layer-&gt;numitems; t++) {</span>
<span class="lineNum">    2393 </span><span class="lineCov">          1 :       int size = PQgetlength(layerinfo-&gt;pgresult, layerinfo-&gt;rownum, t);</span>
<span class="lineNum">    2394 </span><span class="lineCov">          1 :       char *val = (char*)PQgetvalue(layerinfo-&gt;pgresult, layerinfo-&gt;rownum, t);</span>
<span class="lineNum">    2395 </span><span class="lineCov">          1 :       int isnull = PQgetisnull(layerinfo-&gt;pgresult, layerinfo-&gt;rownum, t);</span>
<span class="lineNum">    2396 </span><span class="lineCov">          1 :       if ( isnull ) {</span>
<span class="lineNum">    2397 </span><span class="lineCov">          1 :         shape-&gt;values[t] = msStrdup(&quot;&quot;);</span>
<span class="lineNum">    2398 </span>            :       } else {
<span class="lineNum">    2399 </span><span class="lineCov">          1 :         shape-&gt;values[t] = (char*) msSmallMalloc(size + 1);</span>
<span class="lineNum">    2400 </span><span class="lineCov">          1 :         memcpy(shape-&gt;values[t], val, size);</span>
<span class="lineNum">    2401 </span><span class="lineCov">          1 :         shape-&gt;values[t][size] = '\0'; /* null terminate it */</span>
<span class="lineNum">    2402 </span><span class="lineCov">          1 :         msStringTrimBlanks(shape-&gt;values[t]);</span>
<span class="lineNum">    2403 </span>            :       }
<span class="lineNum">    2404 </span><span class="lineCov">          1 :       if( layer-&gt;debug &gt; 4 ) {</span>
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :         msDebug(&quot;msPostGISReadShape: PQgetlength = %d\n&quot;, size);</span>
<span class="lineNum">    2406 </span>            :       }
<span class="lineNum">    2407 </span><span class="lineCov">          1 :       if( layer-&gt;debug &gt; 1 ) {</span>
<span class="lineNum">    2408 </span><span class="lineNoCov">          0 :         msDebug(&quot;msPostGISReadShape: [%s] \&quot;%s\&quot;\n&quot;, layer-&gt;items[t], shape-&gt;values[t]);</span>
<span class="lineNum">    2409 </span>            :       }
<span class="lineNum">    2410 </span>            :     }
<span class="lineNum">    2411 </span>            : 
<span class="lineNum">    2412 </span>            :     /* t is the geometry, t+1 is the uid */
<span class="lineNum">    2413 </span><span class="lineCov">          1 :     tmp = PQgetvalue(layerinfo-&gt;pgresult, layerinfo-&gt;rownum, t + 1);</span>
<span class="lineNum">    2414 </span><span class="lineCov">          1 :     if( tmp ) {</span>
<span class="lineNum">    2415 </span><span class="lineCov">          1 :       uid = strtol( tmp, NULL, 10 );</span>
<span class="lineNum">    2416 </span>            :     } else {
<span class="lineNum">    2417 </span>            :       uid = 0;
<span class="lineNum">    2418 </span>            :     }
<span class="lineNum">    2419 </span><span class="lineCov">          1 :     if( layer-&gt;debug &gt; 4 ) {</span>
<span class="lineNum">    2420 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISReadShape: Setting shape-&gt;index = %ld\n&quot;, uid);</span>
<span class="lineNum">    2421 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISReadShape: Setting shape-&gt;resultindex = %ld\n&quot;, layerinfo-&gt;rownum);</span>
<span class="lineNum">    2422 </span>            :     }
<span class="lineNum">    2423 </span><span class="lineCov">          1 :     shape-&gt;index = uid;</span>
<span class="lineNum">    2424 </span><span class="lineCov">          1 :     shape-&gt;resultindex = layerinfo-&gt;rownum;</span>
<span class="lineNum">    2425 </span>            : 
<span class="lineNum">    2426 </span><span class="lineCov">          1 :     if( layer-&gt;debug &gt; 2 ) {</span>
<span class="lineNum">    2427 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISReadShape: [index] %ld\n&quot;,  shape-&gt;index);</span>
<span class="lineNum">    2428 </span>            :     }
<span class="lineNum">    2429 </span>            : 
<span class="lineNum">    2430 </span><span class="lineCov">          1 :     shape-&gt;numvalues = layer-&gt;numitems;</span>
<span class="lineNum">    2431 </span>            : 
<span class="lineNum">    2432 </span><span class="lineCov">          1 :     msComputeBounds(shape);</span>
<span class="lineNum">    2433 </span>            :   } else {
<span class="lineNum">    2434 </span><span class="lineNoCov">          0 :      shape-&gt;type = MS_SHAPE_NULL;</span>
<span class="lineNum">    2435 </span>            :   }
<span class="lineNum">    2436 </span>            : 
<span class="lineNum">    2437 </span><span class="lineCov">          1 :   if( layer-&gt;debug &gt; 2 ) {</span>
<span class="lineNum">    2438 </span><span class="lineNoCov">          0 :     char *tmp = msShapeToWKT(shape);</span>
<span class="lineNum">    2439 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISReadShape: [shape] %s\n&quot;, tmp);</span>
<span class="lineNum">    2440 </span><span class="lineNoCov">          0 :     free(tmp);</span>
<span class="lineNum">    2441 </span>            :   }
<span class="lineNum">    2442 </span>            : 
<span class="lineNum">    2443 </span>            :   return MS_SUCCESS;
<span class="lineNum">    2444 </span>            : }
<span class="lineNum">    2445 </span>            : 
<span class="lineNum">    2446 </span>            : #endif /* USE_POSTGIS */
<span class="lineNum">    2447 </span>            : 
<span class="lineNum">    2448 </span>            : 
<span class="lineNum">    2449 </span>            : /*
<span class="lineNum">    2450 </span>            : ** msPostGISLayerOpen()
<span class="lineNum">    2451 </span>            : **
<a name="2452"><span class="lineNum">    2452 </span>            : ** Registered vtable-&gt;LayerOpen function.</a>
<span class="lineNum">    2453 </span>            : */
<span class="lineNum">    2454 </span><span class="lineCov">          1 : int msPostGISLayerOpen(layerObj *layer)</span>
<span class="lineNum">    2455 </span>            : {
<span class="lineNum">    2456 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    2457 </span>            :   msPostGISLayerInfo  *layerinfo;
<span class="lineNum">    2458 </span><span class="lineCov">          1 :   int order_test = 1;</span>
<span class="lineNum">    2459 </span>            :   const char* force2d_processing;
<span class="lineNum">    2460 </span>            : 
<span class="lineNum">    2461 </span>            :   assert(layer != NULL);
<span class="lineNum">    2462 </span>            : 
<span class="lineNum">    2463 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    2464 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerOpen called: %s\n&quot;, layer-&gt;data);</span>
<span class="lineNum">    2465 </span>            :   }
<span class="lineNum">    2466 </span>            : 
<span class="lineNum">    2467 </span><span class="lineCov">          1 :   if (layer-&gt;layerinfo) {</span>
<span class="lineNum">    2468 </span><span class="lineCov">          1 :     if (layer-&gt;debug) {</span>
<span class="lineNum">    2469 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISLayerOpen: Layer is already open!\n&quot;);</span>
<span class="lineNum">    2470 </span>            :     }
<span class="lineNum">    2471 </span>            :     return MS_SUCCESS;  /* already open */
<span class="lineNum">    2472 </span>            :   }
<span class="lineNum">    2473 </span>            : 
<span class="lineNum">    2474 </span><span class="lineCov">          1 :   if (!layer-&gt;data) {</span>
<span class="lineNum">    2475 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR, &quot;Nothing specified in DATA statement.&quot;, &quot;msPostGISLayerOpen()&quot;);</span>
<span class="lineNum">    2476 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    2477 </span>            :   }
<span class="lineNum">    2478 </span>            : 
<span class="lineNum">    2479 </span>            :   /*
<span class="lineNum">    2480 </span>            :   ** Initialize the layerinfo
<span class="lineNum">    2481 </span>            :   **/
<span class="lineNum">    2482 </span><span class="lineCov">          1 :   layerinfo = msPostGISCreateLayerInfo();</span>
<span class="lineNum">    2483 </span>            : 
<span class="lineNum">    2484 </span>            :   if (((char*) &amp;order_test)[0] == 1) {
<span class="lineNum">    2485 </span><span class="lineCov">          1 :     layerinfo-&gt;endian = LITTLE_ENDIAN;</span>
<span class="lineNum">    2486 </span>            :   } else {
<span class="lineNum">    2487 </span>            :     layerinfo-&gt;endian = BIG_ENDIAN;
<span class="lineNum">    2488 </span>            :   }
<span class="lineNum">    2489 </span>            : 
<span class="lineNum">    2490 </span>            :   /*
<span class="lineNum">    2491 </span>            :   ** Get a database connection from the pool.
<span class="lineNum">    2492 </span>            :   */
<span class="lineNum">    2493 </span><span class="lineCov">          1 :   layerinfo-&gt;pgconn = (PGconn *) msConnPoolRequest(layer);</span>
<span class="lineNum">    2494 </span>            : 
<span class="lineNum">    2495 </span>            :   /* No connection in the pool, so set one up. */
<span class="lineNum">    2496 </span><span class="lineCov">          1 :   if (!layerinfo-&gt;pgconn) {</span>
<span class="lineNum">    2497 </span>            :     char *conn_decrypted;
<span class="lineNum">    2498 </span><span class="lineCov">          1 :     if (layer-&gt;debug) {</span>
<span class="lineNum">    2499 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISLayerOpen: No connection in pool, creating a fresh one.\n&quot;);</span>
<span class="lineNum">    2500 </span>            :     }
<span class="lineNum">    2501 </span>            : 
<span class="lineNum">    2502 </span><span class="lineCov">          1 :     if (!layer-&gt;connection) {</span>
<span class="lineNum">    2503 </span><span class="lineNoCov">          0 :       msSetError(MS_MISCERR, &quot;Missing CONNECTION keyword.&quot;, &quot;msPostGISLayerOpen()&quot;);</span>
<span class="lineNum">    2504 </span><span class="lineNoCov">          0 :       free(layerinfo);</span>
<span class="lineNum">    2505 </span><span class="lineNoCov">          0 :       return MS_FAILURE;</span>
<span class="lineNum">    2506 </span>            :     }
<span class="lineNum">    2507 </span>            : 
<span class="lineNum">    2508 </span>            :     /*
<span class="lineNum">    2509 </span>            :     ** Decrypt any encrypted token in connection string and attempt to connect.
<span class="lineNum">    2510 </span>            :     */
<span class="lineNum">    2511 </span><span class="lineCov">          1 :     conn_decrypted = msDecryptStringTokens(layer-&gt;map, layer-&gt;connection);</span>
<span class="lineNum">    2512 </span><span class="lineCov">          1 :     if (conn_decrypted == NULL) {</span>
<span class="lineNum">    2513 </span><span class="lineNoCov">          0 :       free(layerinfo);</span>
<span class="lineNum">    2514 </span><span class="lineNoCov">          0 :       return MS_FAILURE;  /* An error should already have been produced */</span>
<span class="lineNum">    2515 </span>            :     }
<span class="lineNum">    2516 </span><span class="lineCov">          1 :     layerinfo-&gt;pgconn = PQconnectdb(conn_decrypted);</span>
<span class="lineNum">    2517 </span><span class="lineCov">          1 :     msFree(conn_decrypted);</span>
<span class="lineNum">    2518 </span>            :     conn_decrypted = NULL;
<span class="lineNum">    2519 </span>            : 
<span class="lineNum">    2520 </span>            :     /*
<span class="lineNum">    2521 </span>            :     ** Connection failed, return error message with passwords ***ed out.
<span class="lineNum">    2522 </span>            :     */
<span class="lineNum">    2523 </span><span class="lineCov">          1 :     if (!layerinfo-&gt;pgconn || PQstatus(layerinfo-&gt;pgconn) == CONNECTION_BAD) {</span>
<span class="lineNum">    2524 </span>            :       char *index, *maskeddata;
<span class="lineNum">    2525 </span><span class="lineNoCov">          0 :       if (layer-&gt;debug)</span>
<span class="lineNum">    2526 </span><span class="lineNoCov">          0 :         msDebug(&quot;msPostGISLayerOpen: Connection failure.\n&quot;);</span>
<span class="lineNum">    2527 </span>            : 
<span class="lineNum">    2528 </span><span class="lineNoCov">          0 :       maskeddata = msStrdup(layer-&gt;connection);</span>
<span class="lineNum">    2529 </span><span class="lineNoCov">          0 :       index = strstr(maskeddata, &quot;password=&quot;);</span>
<span class="lineNum">    2530 </span><span class="lineNoCov">          0 :       if (index != NULL) {</span>
<span class="lineNum">    2531 </span><span class="lineNoCov">          0 :         index = (char*)(index + 9);</span>
<span class="lineNum">    2532 </span><span class="lineNoCov">          0 :         while (*index != '\0' &amp;&amp; *index != ' ') {</span>
<span class="lineNum">    2533 </span><span class="lineNoCov">          0 :           *index = '*';</span>
<span class="lineNum">    2534 </span><span class="lineNoCov">          0 :           index++;</span>
<span class="lineNum">    2535 </span>            :         }
<span class="lineNum">    2536 </span>            :       }
<span class="lineNum">    2537 </span>            : 
<span class="lineNum">    2538 </span><span class="lineNoCov">          0 :       msDebug( &quot;Database connection failed (%s) with connect string '%s'\nIs the database running? Is it allowing connections? Does the specified user exist? Is the password valid? Is the database on the standard port? in msPostGISLayerOpen()&quot;, PQerrorMessage(layerinfo-&gt;pgconn), maskeddata);</span>
<span class="lineNum">    2539 </span><span class="lineNoCov">          0 :       msSetError(MS_QUERYERR, &quot;Database connection failed. Check server logs for more details.Is the database running? Is it allowing connections? Does the specified user exist? Is the password valid? Is the database on the standard port?&quot;, &quot;msPostGISLayerOpen()&quot;);</span>
<span class="lineNum">    2540 </span>            : 
<span class="lineNum">    2541 </span><span class="lineNoCov">          0 :       if(layerinfo-&gt;pgconn) PQfinish(layerinfo-&gt;pgconn);</span>
<span class="lineNum">    2542 </span><span class="lineNoCov">          0 :       free(maskeddata);</span>
<span class="lineNum">    2543 </span><span class="lineNoCov">          0 :       free(layerinfo);</span>
<span class="lineNum">    2544 </span><span class="lineNoCov">          0 :       return MS_FAILURE;</span>
<span class="lineNum">    2545 </span>            :     }
<span class="lineNum">    2546 </span>            : 
<span class="lineNum">    2547 </span>            :     /* Register to receive notifications from the database. */
<span class="lineNum">    2548 </span><span class="lineCov">          1 :     PQsetNoticeProcessor(layerinfo-&gt;pgconn, postresqlNoticeHandler, (void *) layer);</span>
<span class="lineNum">    2549 </span>            : 
<span class="lineNum">    2550 </span>            :     /* Save this connection in the pool for later. */
<span class="lineNum">    2551 </span><span class="lineCov">          1 :     msConnPoolRegister(layer, layerinfo-&gt;pgconn, msPostGISCloseConnection);</span>
<span class="lineNum">    2552 </span>            :   } else {
<span class="lineNum">    2553 </span>            :     /* Connection in the pool should be tested to see if backend is alive. */
<span class="lineNum">    2554 </span><span class="lineCov">          1 :     if( PQstatus(layerinfo-&gt;pgconn) != CONNECTION_OK ) {</span>
<span class="lineNum">    2555 </span>            :       /* Uh oh, bad connection. Can we reset it? */
<span class="lineNum">    2556 </span><span class="lineNoCov">          0 :       PQreset(layerinfo-&gt;pgconn);</span>
<span class="lineNum">    2557 </span><span class="lineNoCov">          0 :       if( PQstatus(layerinfo-&gt;pgconn) != CONNECTION_OK ) {</span>
<span class="lineNum">    2558 </span>            :         /* Nope, time to bail out. */
<span class="lineNum">    2559 </span><span class="lineNoCov">          0 :         msSetError(MS_QUERYERR, &quot;PostgreSQL database connection. Check server logs for more details&quot;, &quot;msPostGISLayerOpen()&quot;);</span>
<span class="lineNum">    2560 </span><span class="lineNoCov">          0 :         msDebug( &quot;PostgreSQL database connection gone bad (%s) in msPostGISLayerOpen()&quot;, PQerrorMessage(layerinfo-&gt;pgconn));</span>
<span class="lineNum">    2561 </span><span class="lineNoCov">          0 :         free(layerinfo);</span>
<span class="lineNum">    2562 </span>            :         /* FIXME: we should also release the connection from the pool in this case, but it is stale...
<span class="lineNum">    2563 </span>            :          * for the time being we do not release it so it can never be used again. If this happens multiple
<span class="lineNum">    2564 </span>            :          * times there will be a leak... */
<span class="lineNum">    2565 </span><span class="lineNoCov">          0 :         return MS_FAILURE;</span>
<span class="lineNum">    2566 </span>            :       }
<span class="lineNum">    2567 </span>            :     }
<span class="lineNum">    2568 </span>            :   }
<span class="lineNum">    2569 </span>            : 
<span class="lineNum">    2570 </span>            :   /* Get the PostGIS version number from the database */
<span class="lineNum">    2571 </span><span class="lineCov">          1 :   layerinfo-&gt;version = msPostGISRetrieveVersion(layerinfo-&gt;pgconn);</span>
<span class="lineNum">    2572 </span><span class="lineCov">          1 :   if( layerinfo-&gt;version == MS_FAILURE ) {</span>
<span class="lineNum">    2573 </span><span class="lineNoCov">          0 :     msConnPoolRelease(layer, layerinfo-&gt;pgconn);</span>
<span class="lineNum">    2574 </span><span class="lineNoCov">          0 :     free(layerinfo);</span>
<span class="lineNum">    2575 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    2576 </span>            :   }
<span class="lineNum">    2577 </span><span class="lineCov">          1 :   if (layer-&gt;debug)</span>
<span class="lineNum">    2578 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerOpen: Got PostGIS version %d.\n&quot;, layerinfo-&gt;version);</span>
<span class="lineNum">    2579 </span>            : 
<span class="lineNum">    2580 </span><span class="lineCov">          1 :   force2d_processing = msLayerGetProcessingKey( layer, &quot;FORCE2D&quot; );</span>
<span class="lineNum">    2581 </span><span class="lineCov">          1 :   if(force2d_processing &amp;&amp; !strcasecmp(force2d_processing,&quot;no&quot;)) {</span>
<span class="lineNum">    2582 </span><span class="lineNoCov">          0 :     layerinfo-&gt;force2d = MS_FALSE;</span>
<span class="lineNum">    2583 </span>            :   }
<span class="lineNum">    2584 </span><span class="lineCov">          1 :   else if(force2d_processing &amp;&amp; !strcasecmp(force2d_processing,&quot;yes&quot;)) {</span>
<span class="lineNum">    2585 </span><span class="lineNoCov">          0 :     layerinfo-&gt;force2d = MS_TRUE;</span>
<span class="lineNum">    2586 </span>            :   }
<span class="lineNum">    2587 </span><span class="lineCov">          1 :   if (layer-&gt;debug)</span>
<span class="lineNum">    2588 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerOpen: Forcing 2D geometries: %s.\n&quot;, (layerinfo-&gt;force2d)?&quot;yes&quot;:&quot;no&quot;);</span>
<span class="lineNum">    2589 </span>            : 
<span class="lineNum">    2590 </span>            :   /* Save the layerinfo in the layerObj. */
<span class="lineNum">    2591 </span><span class="lineCov">          1 :   layer-&gt;layerinfo = (void*)layerinfo;</span>
<span class="lineNum">    2592 </span>            : 
<span class="lineNum">    2593 </span><span class="lineCov">          1 :   return MS_SUCCESS;</span>
<span class="lineNum">    2594 </span>            : #else
<span class="lineNum">    2595 </span>            :   msSetError( MS_MISCERR,
<span class="lineNum">    2596 </span>            :               &quot;PostGIS support is not available.&quot;,
<span class="lineNum">    2597 </span>            :               &quot;msPostGISLayerOpen()&quot;);
<span class="lineNum">    2598 </span>            :   return MS_FAILURE;
<span class="lineNum">    2599 </span>            : #endif
<span class="lineNum">    2600 </span>            : }
<span class="lineNum">    2601 </span>            : 
<span class="lineNum">    2602 </span>            : /*
<span class="lineNum">    2603 </span>            : ** msPostGISLayerClose()
<span class="lineNum">    2604 </span>            : **
<a name="2605"><span class="lineNum">    2605 </span>            : ** Registered vtable-&gt;LayerClose function.</a>
<span class="lineNum">    2606 </span>            : */
<span class="lineNum">    2607 </span><span class="lineCov">          1 : int msPostGISLayerClose(layerObj *layer)</span>
<span class="lineNum">    2608 </span>            : {
<span class="lineNum">    2609 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    2610 </span>            : 
<span class="lineNum">    2611 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    2612 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerClose called: %s\n&quot;, layer-&gt;data);</span>
<span class="lineNum">    2613 </span>            :   }
<span class="lineNum">    2614 </span>            : 
<span class="lineNum">    2615 </span><span class="lineCov">          1 :   if( layer-&gt;layerinfo ) {</span>
<span class="lineNum">    2616 </span><span class="lineCov">          1 :     msPostGISFreeLayerInfo(layer);</span>
<span class="lineNum">    2617 </span>            :   }
<span class="lineNum">    2618 </span>            : 
<span class="lineNum">    2619 </span><span class="lineCov">          1 :   return MS_SUCCESS;</span>
<span class="lineNum">    2620 </span>            : #else
<span class="lineNum">    2621 </span>            :   msSetError( MS_MISCERR,
<span class="lineNum">    2622 </span>            :               &quot;PostGIS support is not available.&quot;,
<span class="lineNum">    2623 </span>            :               &quot;msPostGISLayerClose()&quot;);
<span class="lineNum">    2624 </span>            :   return MS_FAILURE;
<span class="lineNum">    2625 </span>            : #endif
<span class="lineNum">    2626 </span>            : }
<span class="lineNum">    2627 </span>            : 
<span class="lineNum">    2628 </span>            : 
<span class="lineNum">    2629 </span>            : /*
<span class="lineNum">    2630 </span>            : ** msPostGISLayerIsOpen()
<span class="lineNum">    2631 </span>            : **
<a name="2632"><span class="lineNum">    2632 </span>            : ** Registered vtable-&gt;LayerIsOpen function.</a>
<span class="lineNum">    2633 </span>            : */
<span class="lineNum">    2634 </span><span class="lineCov">          1 : int msPostGISLayerIsOpen(layerObj *layer)</span>
<span class="lineNum">    2635 </span>            : {
<span class="lineNum">    2636 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    2637 </span>            : 
<span class="lineNum">    2638 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    2639 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerIsOpen called.\n&quot;);</span>
<span class="lineNum">    2640 </span>            :   }
<span class="lineNum">    2641 </span>            : 
<span class="lineNum">    2642 </span><span class="lineCov">          1 :   if (layer-&gt;layerinfo)</span>
<span class="lineNum">    2643 </span>            :     return MS_TRUE;
<span class="lineNum">    2644 </span>            :   else
<span class="lineNum">    2645 </span><span class="lineCov">          1 :     return MS_FALSE;</span>
<span class="lineNum">    2646 </span>            : #else
<span class="lineNum">    2647 </span>            :   msSetError( MS_MISCERR,
<span class="lineNum">    2648 </span>            :               &quot;PostGIS support is not available.&quot;,
<span class="lineNum">    2649 </span>            :               &quot;msPostGISLayerIsOpen()&quot;);
<span class="lineNum">    2650 </span>            :   return MS_FAILURE;
<span class="lineNum">    2651 </span>            : #endif
<span class="lineNum">    2652 </span>            : }
<span class="lineNum">    2653 </span>            : 
<span class="lineNum">    2654 </span>            : 
<span class="lineNum">    2655 </span>            : /*
<span class="lineNum">    2656 </span>            : ** msPostGISLayerFreeItemInfo()
<span class="lineNum">    2657 </span>            : **
<a name="2658"><span class="lineNum">    2658 </span>            : ** Registered vtable-&gt;LayerFreeItemInfo function.</a>
<span class="lineNum">    2659 </span>            : */
<span class="lineNum">    2660 </span><span class="lineCov">          1 : void msPostGISLayerFreeItemInfo(layerObj *layer)</span>
<span class="lineNum">    2661 </span>            : {
<span class="lineNum">    2662 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    2663 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    2664 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerFreeItemInfo called.\n&quot;);</span>
<span class="lineNum">    2665 </span>            :   }
<span class="lineNum">    2666 </span>            : 
<span class="lineNum">    2667 </span><span class="lineCov">          1 :   if (layer-&gt;iteminfo) {</span>
<span class="lineNum">    2668 </span><span class="lineCov">          1 :     free(layer-&gt;iteminfo);</span>
<span class="lineNum">    2669 </span>            :   }
<span class="lineNum">    2670 </span><span class="lineCov">          1 :   layer-&gt;iteminfo = NULL;</span>
<span class="lineNum">    2671 </span>            : #endif
<span class="lineNum">    2672 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    2673 </span>            : 
<span class="lineNum">    2674 </span>            : /*
<span class="lineNum">    2675 </span>            : ** msPostGISLayerInitItemInfo()
<span class="lineNum">    2676 </span>            : **
<span class="lineNum">    2677 </span>            : ** Registered vtable-&gt;LayerInitItemInfo function.
<a name="2678"><span class="lineNum">    2678 </span>            : ** Our iteminfo is list of indexes from 1..numitems.</a>
<span class="lineNum">    2679 </span>            : */
<span class="lineNum">    2680 </span><span class="lineCov">          1 : int msPostGISLayerInitItemInfo(layerObj *layer)</span>
<span class="lineNum">    2681 </span>            : {
<span class="lineNum">    2682 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    2683 </span>            :   int i;
<span class="lineNum">    2684 </span>            :   int *itemindexes ;
<span class="lineNum">    2685 </span>            : 
<span class="lineNum">    2686 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    2687 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerInitItemInfo called.\n&quot;);</span>
<span class="lineNum">    2688 </span>            :   }
<span class="lineNum">    2689 </span>            : 
<span class="lineNum">    2690 </span><span class="lineCov">          1 :   if (layer-&gt;numitems == 0) {</span>
<span class="lineNum">    2691 </span>            :     return MS_SUCCESS;
<span class="lineNum">    2692 </span>            :   }
<span class="lineNum">    2693 </span>            : 
<span class="lineNum">    2694 </span><span class="lineCov">          1 :   if (layer-&gt;iteminfo) {</span>
<span class="lineNum">    2695 </span><span class="lineCov">          1 :     free(layer-&gt;iteminfo);</span>
<span class="lineNum">    2696 </span>            :   }
<span class="lineNum">    2697 </span>            : 
<span class="lineNum">    2698 </span><span class="lineCov">          1 :   layer-&gt;iteminfo = msSmallMalloc(sizeof(int) * layer-&gt;numitems);</span>
<span class="lineNum">    2699 </span><span class="lineCov">          1 :   if (!layer-&gt;iteminfo) {</span>
<span class="lineNum">    2700 </span><span class="lineNoCov">          0 :     msSetError(MS_MEMERR, &quot;Out of memory.&quot;, &quot;msPostGISLayerInitItemInfo()&quot;);</span>
<span class="lineNum">    2701 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    2702 </span>            :   }
<span class="lineNum">    2703 </span>            : 
<span class="lineNum">    2704 </span>            :   itemindexes = (int*)layer-&gt;iteminfo;
<span class="lineNum">    2705 </span><span class="lineCov">          1 :   for (i = 0; i &lt; layer-&gt;numitems; i++) {</span>
<span class="lineNum">    2706 </span><span class="lineCov">          1 :     itemindexes[i] = i; /* Last item is always the geometry. The rest are non-geometry. */</span>
<span class="lineNum">    2707 </span>            :   }
<span class="lineNum">    2708 </span>            : 
<span class="lineNum">    2709 </span>            :   return MS_SUCCESS;
<span class="lineNum">    2710 </span>            : #else
<span class="lineNum">    2711 </span>            :   msSetError( MS_MISCERR,
<span class="lineNum">    2712 </span>            :               &quot;PostGIS support is not available.&quot;,
<span class="lineNum">    2713 </span>            :               &quot;msPostGISLayerInitItemInfo()&quot;);
<span class="lineNum">    2714 </span>            :   return MS_FAILURE;
<span class="lineNum">    2715 </span>            : #endif
<span class="lineNum">    2716 </span>            : }
<span class="lineNum">    2717 </span>            : 
<span class="lineNum">    2718 </span>            : /*
<span class="lineNum">    2719 </span>            : ** msPostGISLayerWhichShapes()
<span class="lineNum">    2720 </span>            : **
<a name="2721"><span class="lineNum">    2721 </span>            : ** Registered vtable-&gt;LayerWhichShapes function.</a>
<span class="lineNum">    2722 </span>            : */
<span class="lineNum">    2723 </span><span class="lineCov">          1 : int msPostGISLayerWhichShapes(layerObj *layer, rectObj rect, int isQuery)</span>
<span class="lineNum">    2724 </span>            : {
<span class="lineNum">    2725 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    2726 </span>            :   msPostGISLayerInfo *layerinfo = NULL;
<span class="lineNum">    2727 </span>            :   char *strSQL = NULL;
<span class="lineNum">    2728 </span>            :   PGresult *pgresult = NULL;
<span class="lineNum">    2729 </span>            :   const char** layer_bind_values = NULL;
<span class="lineNum">    2730 </span>            :   const char* bind_value;
<span class="lineNum">    2731 </span>            :   char* bind_key = NULL;
<span class="lineNum">    2732 </span>            : 
<span class="lineNum">    2733 </span>            :   int num_bind_values = 0;
<span class="lineNum">    2734 </span>            : 
<span class="lineNum">    2735 </span>            :   assert(layer != NULL);
<span class="lineNum">    2736 </span>            :   assert(layer-&gt;layerinfo != NULL);
<span class="lineNum">    2737 </span>            : 
<span class="lineNum">    2738 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    2739 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerWhichShapes called.\n&quot;);</span>
<span class="lineNum">    2740 </span>            :   }
<span class="lineNum">    2741 </span>            : 
<span class="lineNum">    2742 </span>            :   /* Fill out layerinfo with our current DATA state. */
<span class="lineNum">    2743 </span><span class="lineCov">          1 :   if ( msPostGISParseData(layer) != MS_SUCCESS) {</span>
<span class="lineNum">    2744 </span>            :     return MS_FAILURE;
<span class="lineNum">    2745 </span>            :   }
<span class="lineNum">    2746 </span>            : 
<span class="lineNum">    2747 </span>            :   /* try to get the first bind value */
<span class="lineNum">    2748 </span><span class="lineCov">          1 :   layer_bind_values = (const char**)msSmallMalloc(sizeof(const char*) * 1000);</span>
<span class="lineNum">    2749 </span><span class="lineCov">          1 :   bind_key = (char*)msSmallMalloc(3);</span>
<span class="lineNum">    2750 </span><span class="lineCov">          1 :   bind_value = msLookupHashTable(&amp;layer-&gt;bindvals, &quot;1&quot;);</span>
<span class="lineNum">    2751 </span><span class="lineCov">          1 :   while(bind_value != NULL) {</span>
<span class="lineNum">    2752 </span>            :     /* put the bind value on the stack */
<span class="lineNum">    2753 </span><span class="lineNoCov">          0 :     layer_bind_values[num_bind_values] = bind_value;</span>
<span class="lineNum">    2754 </span>            :     /* increment the counter */
<span class="lineNum">    2755 </span><span class="lineNoCov">          0 :     num_bind_values++;</span>
<span class="lineNum">    2756 </span>            :     /* create a new lookup key */
<span class="lineNum">    2757 </span><span class="lineNoCov">          0 :     sprintf(bind_key, &quot;%d&quot;, num_bind_values+1);</span>
<span class="lineNum">    2758 </span>            :     /* get the bind_value */
<span class="lineNum">    2759 </span><span class="lineNoCov">          0 :     bind_value = msLookupHashTable(&amp;layer-&gt;bindvals, bind_key);</span>
<span class="lineNum">    2760 </span>            :   }
<span class="lineNum">    2761 </span>            : 
<span class="lineNum">    2762 </span>            :   /*
<span class="lineNum">    2763 </span>            :   ** This comes *after* parsedata, because parsedata fills in
<span class="lineNum">    2764 </span>            :   ** layer-&gt;layerinfo.
<span class="lineNum">    2765 </span>            :   */
<span class="lineNum">    2766 </span><span class="lineCov">          1 :   layerinfo = (msPostGISLayerInfo*) layer-&gt;layerinfo;</span>
<span class="lineNum">    2767 </span>            : 
<span class="lineNum">    2768 </span>            :   /* Build a SQL query based on our current state. */
<span class="lineNum">    2769 </span><span class="lineCov">          1 :   strSQL = msPostGISBuildSQL(layer, &amp;rect, NULL, NULL, -1);</span>
<span class="lineNum">    2770 </span><span class="lineCov">          1 :   if ( ! strSQL ) {</span>
<span class="lineNum">    2771 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR, &quot;Failed to build query SQL.&quot;, &quot;msPostGISLayerWhichShapes()&quot;);</span>
<span class="lineNum">    2772 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    2773 </span>            :   }
<span class="lineNum">    2774 </span>            : 
<span class="lineNum">    2775 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    2776 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerWhichShapes query: %s\n&quot;, strSQL);</span>
<span class="lineNum">    2777 </span>            :   }
<span class="lineNum">    2778 </span>            : 
<span class="lineNum">    2779 </span>            :   // fprintf(stderr, &quot;SQL: %s\n&quot;, strSQL);
<span class="lineNum">    2780 </span>            : 
<span class="lineNum">    2781 </span><span class="lineCov">          1 :   if(num_bind_values &gt; 0) {</span>
<span class="lineNum">    2782 </span><span class="lineNoCov">          0 :     pgresult = PQexecParams(layerinfo-&gt;pgconn, strSQL, num_bind_values, NULL, layer_bind_values, NULL, NULL, RESULTSET_TYPE);</span>
<span class="lineNum">    2783 </span>            :   } else {
<span class="lineNum">    2784 </span><span class="lineCov">          1 :     pgresult = PQexecParams(layerinfo-&gt;pgconn, strSQL,0, NULL, NULL, NULL, NULL, RESULTSET_TYPE);</span>
<span class="lineNum">    2785 </span>            :   }
<span class="lineNum">    2786 </span>            : 
<span class="lineNum">    2787 </span>            :   /* free bind values */
<span class="lineNum">    2788 </span><span class="lineCov">          1 :   free(bind_key);</span>
<span class="lineNum">    2789 </span><span class="lineCov">          1 :   free((void*)layer_bind_values);</span>
<span class="lineNum">    2790 </span>            : 
<span class="lineNum">    2791 </span><span class="lineCov">          1 :   if ( layer-&gt;debug &gt; 1 ) {</span>
<span class="lineNum">    2792 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerWhichShapes query status: %s (%d)\n&quot;, PQresStatus(PQresultStatus(pgresult)), PQresultStatus(pgresult));</span>
<span class="lineNum">    2793 </span>            :   }
<span class="lineNum">    2794 </span>            : 
<span class="lineNum">    2795 </span>            :   /* Something went wrong. */
<span class="lineNum">    2796 </span><span class="lineCov">          1 :   if (!pgresult || PQresultStatus(pgresult) != PGRES_TUPLES_OK) {</span>
<span class="lineNum">    2797 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerWhichShapes(): Error (%s) executing query: %s\n&quot;, PQerrorMessage(layerinfo-&gt;pgconn), strSQL);</span>
<span class="lineNum">    2798 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR, &quot;Error executing query. Check server logs&quot;,&quot;msPostGISLayerWhichShapes()&quot;);</span>
<span class="lineNum">    2799 </span><span class="lineNoCov">          0 :     free(strSQL);</span>
<span class="lineNum">    2800 </span><span class="lineNoCov">          0 :     if (pgresult) {</span>
<span class="lineNum">    2801 </span><span class="lineNoCov">          0 :       PQclear(pgresult);</span>
<span class="lineNum">    2802 </span>            :     }
<span class="lineNum">    2803 </span>            :     return MS_FAILURE;
<span class="lineNum">    2804 </span>            :   }
<span class="lineNum">    2805 </span>            : 
<span class="lineNum">    2806 </span><span class="lineCov">          1 :   if ( layer-&gt;debug ) {</span>
<span class="lineNum">    2807 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerWhichShapes got %d records in result.\n&quot;, PQntuples(pgresult));</span>
<span class="lineNum">    2808 </span>            :   }
<span class="lineNum">    2809 </span>            : 
<span class="lineNum">    2810 </span>            :   /* Clean any existing pgresult before storing current one. */
<span class="lineNum">    2811 </span><span class="lineCov">          1 :   if(layerinfo-&gt;pgresult) PQclear(layerinfo-&gt;pgresult);</span>
<span class="lineNum">    2812 </span><span class="lineCov">          1 :   layerinfo-&gt;pgresult = pgresult;</span>
<span class="lineNum">    2813 </span>            : 
<span class="lineNum">    2814 </span>            :   /* Clean any existing SQL before storing current. */
<span class="lineNum">    2815 </span><span class="lineCov">          1 :   if(layerinfo-&gt;sql) free(layerinfo-&gt;sql);</span>
<span class="lineNum">    2816 </span><span class="lineCov">          1 :   layerinfo-&gt;sql = strSQL;</span>
<span class="lineNum">    2817 </span>            : 
<span class="lineNum">    2818 </span><span class="lineCov">          1 :   layerinfo-&gt;rownum = 0;</span>
<span class="lineNum">    2819 </span>            : 
<span class="lineNum">    2820 </span><span class="lineCov">          1 :   return MS_SUCCESS;</span>
<span class="lineNum">    2821 </span>            : #else
<span class="lineNum">    2822 </span>            :   msSetError( MS_MISCERR,
<span class="lineNum">    2823 </span>            :               &quot;PostGIS support is not available.&quot;,
<span class="lineNum">    2824 </span>            :               &quot;msPostGISLayerWhichShapes()&quot;);
<span class="lineNum">    2825 </span>            :   return MS_FAILURE;
<span class="lineNum">    2826 </span>            : #endif
<span class="lineNum">    2827 </span>            : }
<span class="lineNum">    2828 </span>            : 
<span class="lineNum">    2829 </span>            : /*
<span class="lineNum">    2830 </span>            : ** msPostGISLayerNextShape()
<span class="lineNum">    2831 </span>            : **
<a name="2832"><span class="lineNum">    2832 </span>            : ** Registered vtable-&gt;LayerNextShape function.</a>
<span class="lineNum">    2833 </span>            : */
<span class="lineNum">    2834 </span><span class="lineCov">          1 : int msPostGISLayerNextShape(layerObj *layer, shapeObj *shape)</span>
<span class="lineNum">    2835 </span>            : {
<span class="lineNum">    2836 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    2837 </span>            :   msPostGISLayerInfo  *layerinfo;
<span class="lineNum">    2838 </span>            : 
<span class="lineNum">    2839 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    2840 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerNextShape called.\n&quot;);</span>
<span class="lineNum">    2841 </span>            :   }
<span class="lineNum">    2842 </span>            : 
<span class="lineNum">    2843 </span>            :   assert(layer != NULL);
<span class="lineNum">    2844 </span>            :   assert(layer-&gt;layerinfo != NULL);
<span class="lineNum">    2845 </span>            : 
<span class="lineNum">    2846 </span><span class="lineCov">          1 :   layerinfo = (msPostGISLayerInfo*) layer-&gt;layerinfo;</span>
<span class="lineNum">    2847 </span>            : 
<span class="lineNum">    2848 </span><span class="lineCov">          1 :   shape-&gt;type = MS_SHAPE_NULL;</span>
<span class="lineNum">    2849 </span>            : 
<span class="lineNum">    2850 </span>            :   /*
<span class="lineNum">    2851 </span>            :   ** Roll through pgresult until we hit non-null shape (usually right away).
<span class="lineNum">    2852 </span>            :   */
<span class="lineNum">    2853 </span><span class="lineCov">          1 :   while (shape-&gt;type == MS_SHAPE_NULL) {</span>
<span class="lineNum">    2854 </span><span class="lineCov">          1 :     if (layerinfo-&gt;rownum &lt; PQntuples(layerinfo-&gt;pgresult)) {</span>
<span class="lineNum">    2855 </span>            :       /* Retrieve this shape, cursor access mode. */
<span class="lineNum">    2856 </span><span class="lineCov">          1 :       msPostGISReadShape(layer, shape);</span>
<span class="lineNum">    2857 </span><span class="lineCov">          1 :       if( shape-&gt;type != MS_SHAPE_NULL ) {</span>
<span class="lineNum">    2858 </span><span class="lineCov">          1 :         (layerinfo-&gt;rownum)++; /* move to next shape */</span>
<span class="lineNum">    2859 </span><span class="lineCov">          1 :         return MS_SUCCESS;</span>
<span class="lineNum">    2860 </span>            :       } else {
<span class="lineNum">    2861 </span><span class="lineNoCov">          0 :         (layerinfo-&gt;rownum)++; /* move to next shape */</span>
<span class="lineNum">    2862 </span>            :       }
<span class="lineNum">    2863 </span>            :     } else {
<span class="lineNum">    2864 </span>            :       return MS_DONE;
<span class="lineNum">    2865 </span>            :     }
<span class="lineNum">    2866 </span>            :   }
<span class="lineNum">    2867 </span>            : 
<span class="lineNum">    2868 </span>            :   /* Found nothing, clean up and exit. */
<span class="lineNum">    2869 </span><span class="lineNoCov">          0 :   msFreeShape(shape);</span>
<span class="lineNum">    2870 </span>            : 
<span class="lineNum">    2871 </span><span class="lineNoCov">          0 :   return MS_FAILURE;</span>
<span class="lineNum">    2872 </span>            : #else
<span class="lineNum">    2873 </span>            :   msSetError( MS_MISCERR,
<span class="lineNum">    2874 </span>            :               &quot;PostGIS support is not available.&quot;,
<span class="lineNum">    2875 </span>            :               &quot;msPostGISLayerNextShape()&quot;);
<span class="lineNum">    2876 </span>            :   return MS_FAILURE;
<span class="lineNum">    2877 </span>            : #endif
<span class="lineNum">    2878 </span>            : }
<span class="lineNum">    2879 </span>            : 
<span class="lineNum">    2880 </span>            : /*
<span class="lineNum">    2881 </span>            : ** msPostGISLayerGetShape()
<a name="2882"><span class="lineNum">    2882 </span>            : **</a>
<span class="lineNum">    2883 </span>            :  */
<span class="lineNum">    2884 </span><span class="lineCov">          1 : int msPostGISLayerGetShapeCount(layerObj *layer, rectObj rect, projectionObj *rectProjection)</span>
<span class="lineNum">    2885 </span>            : {
<span class="lineNum">    2886 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    2887 </span>            :   msPostGISLayerInfo *layerinfo = NULL;
<span class="lineNum">    2888 </span>            :   char *strSQL = NULL;
<span class="lineNum">    2889 </span>            :   char *strSQLCount = NULL;
<span class="lineNum">    2890 </span>            :   PGresult *pgresult = NULL;
<span class="lineNum">    2891 </span>            :   const char** layer_bind_values = NULL;
<span class="lineNum">    2892 </span>            :   const char* bind_value;
<span class="lineNum">    2893 </span>            :   char* bind_key = NULL;
<span class="lineNum">    2894 </span>            :   int num_bind_values = 0;
<span class="lineNum">    2895 </span>            :   int nCount = 0;
<span class="lineNum">    2896 </span>            :   int rectSRID = -1;
<span class="lineNum">    2897 </span><span class="lineCov">          1 :   rectObj searchrectInLayerProj = rect;</span>
<span class="lineNum">    2898 </span>            : 
<span class="lineNum">    2899 </span>            :   assert(layer != NULL);
<span class="lineNum">    2900 </span>            :   assert(layer-&gt;layerinfo != NULL);
<span class="lineNum">    2901 </span>            : 
<span class="lineNum">    2902 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    2903 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerGetShapeCount called.\n&quot;);</span>
<span class="lineNum">    2904 </span>            :   }
<span class="lineNum">    2905 </span>            : 
<span class="lineNum">    2906 </span>            : #ifdef USE_PROJ
<span class="lineNum">    2907 </span>            :   // Special processing if the specified projection for the rect is different from the layer projection
<span class="lineNum">    2908 </span>            :   // We want to issue a WHERE that includes
<span class="lineNum">    2909 </span>            :   // ((the_geom &amp;&amp; rect_reprojected_in_layer_SRID) AND NOT ST_Disjoint(ST_Transform(the_geom, rect_SRID), rect))
<span class="lineNum">    2910 </span><span class="lineCov">          1 :   if( rectProjection != NULL &amp;&amp; layer-&gt;project &amp;&amp;</span>
<span class="lineNum">    2911 </span><span class="lineCov">          1 :       msProjectionsDiffer(&amp;(layer-&gt;projection), rectProjection) )</span>
<span class="lineNum">    2912 </span>            :   {
<span class="lineNum">    2913 </span>            :     // If we cannot guess the EPSG code of the rectProjection, we cannot
<span class="lineNum">    2914 </span>            :     // use ST_Transform, so fallback on slow implementation
<span class="lineNum">    2915 </span><span class="lineCov">          1 :     if( rectProjection-&gt;numargs &lt; 1 ||</span>
<span class="lineNum">    2916 </span><span class="lineCov">          1 :         strncasecmp(rectProjection-&gt;args[0], &quot;init=epsg:&quot;, strlen(&quot;init=epsg:&quot;)) != 0 )</span>
<span class="lineNum">    2917 </span>            :     {
<span class="lineNum">    2918 </span><span class="lineNoCov">          0 :       if (layer-&gt;debug) {</span>
<span class="lineNum">    2919 </span><span class="lineNoCov">          0 :         msDebug(&quot;msPostGISLayerGetShapeCount(): cannot find EPSG code of rectProjection. Falling back on client-side feature count.\n&quot;);</span>
<span class="lineNum">    2920 </span>            :       }
<span class="lineNum">    2921 </span><span class="lineNoCov">          0 :       return LayerDefaultGetShapeCount(layer, rect, rectProjection);</span>
<span class="lineNum">    2922 </span>            :     }
<span class="lineNum">    2923 </span>            : 
<span class="lineNum">    2924 </span>            :     // Reproject the passed rect into the layer projection and get
<span class="lineNum">    2925 </span>            :     // the SRID from the rectProjection
<span class="lineNum">    2926 </span><span class="lineCov">          1 :     msProjectRect(rectProjection, &amp;(layer-&gt;projection), &amp;searchrectInLayerProj); /* project the searchrect to source coords */</span>
<span class="lineNum">    2927 </span><span class="lineCov">          1 :     rectSRID = atoi(rectProjection-&gt;args[0] + strlen(&quot;init=epsg:&quot;));</span>
<span class="lineNum">    2928 </span>            :   }
<span class="lineNum">    2929 </span>            : #endif
<span class="lineNum">    2930 </span>            : 
<span class="lineNum">    2931 </span><span class="lineCov">          1 :   msLayerTranslateFilter(layer, &amp;layer-&gt;filter, layer-&gt;filteritem);</span>
<span class="lineNum">    2932 </span>            : 
<span class="lineNum">    2933 </span>            :   /* Fill out layerinfo with our current DATA state. */
<span class="lineNum">    2934 </span><span class="lineCov">          1 :   if ( msPostGISParseData(layer) != MS_SUCCESS) {</span>
<span class="lineNum">    2935 </span>            :     return -1;
<span class="lineNum">    2936 </span>            :   }
<span class="lineNum">    2937 </span>            : 
<span class="lineNum">    2938 </span>            :   /* try to get the first bind value */
<span class="lineNum">    2939 </span><span class="lineCov">          1 :   layer_bind_values = (const char**)msSmallMalloc(sizeof(const char*) * 1000);</span>
<span class="lineNum">    2940 </span><span class="lineCov">          1 :   bind_value = msLookupHashTable(&amp;layer-&gt;bindvals, &quot;1&quot;);</span>
<span class="lineNum">    2941 </span><span class="lineCov">          1 :   bind_key = (char*)msSmallMalloc(3);</span>
<span class="lineNum">    2942 </span><span class="lineCov">          1 :   while(bind_value != NULL) {</span>
<span class="lineNum">    2943 </span>            :     /* put the bind value on the stack */
<span class="lineNum">    2944 </span><span class="lineNoCov">          0 :     layer_bind_values[num_bind_values] = bind_value;</span>
<span class="lineNum">    2945 </span>            :     /* increment the counter */
<span class="lineNum">    2946 </span><span class="lineNoCov">          0 :     num_bind_values++;</span>
<span class="lineNum">    2947 </span>            :     /* create a new lookup key */
<span class="lineNum">    2948 </span><span class="lineNoCov">          0 :     sprintf(bind_key, &quot;%d&quot;, num_bind_values+1);</span>
<span class="lineNum">    2949 </span>            :     /* get the bind_value */
<span class="lineNum">    2950 </span><span class="lineNoCov">          0 :     bind_value = msLookupHashTable(&amp;layer-&gt;bindvals, bind_key);</span>
<span class="lineNum">    2951 </span>            :   }
<span class="lineNum">    2952 </span>            : 
<span class="lineNum">    2953 </span>            :   /*
<span class="lineNum">    2954 </span>            :   ** This comes *after* parsedata, because parsedata fills in
<span class="lineNum">    2955 </span>            :   ** layer-&gt;layerinfo.
<span class="lineNum">    2956 </span>            :   */
<span class="lineNum">    2957 </span><span class="lineCov">          1 :   layerinfo = (msPostGISLayerInfo*) layer-&gt;layerinfo;</span>
<span class="lineNum">    2958 </span>            : 
<span class="lineNum">    2959 </span>            :   /* Build a SQL query based on our current state. */
<span class="lineNum">    2960 </span><span class="lineCov">          1 :   strSQL = msPostGISBuildSQL(layer, &amp;searchrectInLayerProj, NULL,</span>
<span class="lineNum">    2961 </span>            :                              &amp;rect, rectSRID);
<span class="lineNum">    2962 </span><span class="lineCov">          1 :   if ( ! strSQL ) {</span>
<span class="lineNum">    2963 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR, &quot;Failed to build query SQL.&quot;, &quot;msPostGISLayerGetShapeCount()&quot;);</span>
<span class="lineNum">    2964 </span><span class="lineNoCov">          0 :     return -1;</span>
<span class="lineNum">    2965 </span>            :   }
<span class="lineNum">    2966 </span>            : 
<span class="lineNum">    2967 </span>            :   strSQLCount = NULL;
<span class="lineNum">    2968 </span><span class="lineCov">          1 :   strSQLCount = msStringConcatenate(strSQLCount, &quot;SELECT COUNT(*) FROM (&quot;);</span>
<span class="lineNum">    2969 </span><span class="lineCov">          1 :   strSQLCount = msStringConcatenate(strSQLCount, strSQL);</span>
<span class="lineNum">    2970 </span><span class="lineCov">          1 :   strSQLCount = msStringConcatenate(strSQLCount, &quot;) msQuery&quot;);</span>
<span class="lineNum">    2971 </span>            : 
<span class="lineNum">    2972 </span><span class="lineCov">          1 :   msFree(strSQL);</span>
<span class="lineNum">    2973 </span>            : 
<span class="lineNum">    2974 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    2975 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerGetShapeCount query: %s\n&quot;, strSQLCount);</span>
<span class="lineNum">    2976 </span>            :   }
<span class="lineNum">    2977 </span>            : 
<span class="lineNum">    2978 </span><span class="lineCov">          1 :   if(num_bind_values &gt; 0) {</span>
<span class="lineNum">    2979 </span><span class="lineNoCov">          0 :     pgresult = PQexecParams(layerinfo-&gt;pgconn, strSQLCount, num_bind_values, NULL, layer_bind_values, NULL, NULL, 1);</span>
<span class="lineNum">    2980 </span>            :   } else {
<span class="lineNum">    2981 </span><span class="lineCov">          1 :     pgresult = PQexecParams(layerinfo-&gt;pgconn, strSQLCount,0, NULL, NULL, NULL, NULL, 0);</span>
<span class="lineNum">    2982 </span>            :   }
<span class="lineNum">    2983 </span>            : 
<span class="lineNum">    2984 </span>            :   /* free bind values */
<span class="lineNum">    2985 </span><span class="lineCov">          1 :   free(bind_key);</span>
<span class="lineNum">    2986 </span><span class="lineCov">          1 :   free((void*)layer_bind_values);</span>
<span class="lineNum">    2987 </span>            : 
<span class="lineNum">    2988 </span><span class="lineCov">          1 :   if ( layer-&gt;debug &gt; 1 ) {</span>
<span class="lineNum">    2989 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerWhichShapes query status: %s (%d)\n&quot;,</span>
<span class="lineNum">    2990 </span><span class="lineNoCov">          0 :             PQresStatus(PQresultStatus(pgresult)), PQresultStatus(pgresult));</span>
<span class="lineNum">    2991 </span>            :   }
<span class="lineNum">    2992 </span>            : 
<span class="lineNum">    2993 </span>            :   /* Something went wrong. */
<span class="lineNum">    2994 </span><span class="lineCov">          1 :   if (!pgresult || PQresultStatus(pgresult) != PGRES_TUPLES_OK) {</span>
<span class="lineNum">    2995 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerGetShapeCount(): Error (%s) executing query: %s. &quot;</span>
<span class="lineNum">    2996 </span>            :             &quot;Falling back to client-side evaluation\n&quot;,
<span class="lineNum">    2997 </span><span class="lineNoCov">          0 :             PQerrorMessage(layerinfo-&gt;pgconn), strSQLCount);</span>
<span class="lineNum">    2998 </span><span class="lineNoCov">          0 :     msFree(strSQLCount);</span>
<span class="lineNum">    2999 </span><span class="lineNoCov">          0 :     if (pgresult) {</span>
<span class="lineNum">    3000 </span><span class="lineNoCov">          0 :       PQclear(pgresult);</span>
<span class="lineNum">    3001 </span>            :     }
<span class="lineNum">    3002 </span><span class="lineNoCov">          0 :     return LayerDefaultGetShapeCount(layer, rect, rectProjection);</span>
<span class="lineNum">    3003 </span>            :   }
<span class="lineNum">    3004 </span>            : 
<span class="lineNum">    3005 </span><span class="lineCov">          1 :   msFree(strSQLCount);</span>
<span class="lineNum">    3006 </span><span class="lineCov">          1 :   nCount = atoi(PQgetvalue(pgresult, 0, 0 ));</span>
<span class="lineNum">    3007 </span>            : 
<span class="lineNum">    3008 </span><span class="lineCov">          1 :   if ( layer-&gt;debug ) {</span>
<span class="lineNum">    3009 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerWhichShapes return: %d.\n&quot;, nCount);</span>
<span class="lineNum">    3010 </span>            :   }
<span class="lineNum">    3011 </span><span class="lineCov">          1 :   PQclear(pgresult);</span>
<span class="lineNum">    3012 </span>            : 
<span class="lineNum">    3013 </span><span class="lineCov">          1 :   return nCount;</span>
<span class="lineNum">    3014 </span>            : #else
<span class="lineNum">    3015 </span>            :   msSetError( MS_MISCERR,
<span class="lineNum">    3016 </span>            :               &quot;PostGIS support is not available.&quot;,
<span class="lineNum">    3017 </span>            :               &quot;msPostGISLayerGetShapeCount()&quot;);
<span class="lineNum">    3018 </span>            :   return -1;
<span class="lineNum">    3019 </span>            : #endif
<span class="lineNum">    3020 </span>            : }
<span class="lineNum">    3021 </span>            : 
<span class="lineNum">    3022 </span>            : 
<span class="lineNum">    3023 </span>            : /*
<span class="lineNum">    3024 </span>            : ** msPostGISLayerGetShape()
<span class="lineNum">    3025 </span>            : **
<span class="lineNum">    3026 </span>            : ** Registered vtable-&gt;LayerGetShape function. For pulling from a prepared and
<a name="3027"><span class="lineNum">    3027 </span>            : ** undisposed result set.</a>
<span class="lineNum">    3028 </span>            : */
<span class="lineNum">    3029 </span><span class="lineCov">          1 : int msPostGISLayerGetShape(layerObj *layer, shapeObj *shape, resultObj *record)</span>
<span class="lineNum">    3030 </span>            : {
<span class="lineNum">    3031 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    3032 </span>            : 
<span class="lineNum">    3033 </span>            :   PGresult *pgresult = NULL;
<span class="lineNum">    3034 </span>            :   msPostGISLayerInfo *layerinfo = NULL;
<span class="lineNum">    3035 </span>            : 
<span class="lineNum">    3036 </span><span class="lineCov">          1 :   long shapeindex = record-&gt;shapeindex;</span>
<span class="lineNum">    3037 </span><span class="lineCov">          1 :   int resultindex = record-&gt;resultindex;</span>
<span class="lineNum">    3038 </span>            : 
<span class="lineNum">    3039 </span>            :   assert(layer != NULL);
<span class="lineNum">    3040 </span>            :   assert(layer-&gt;layerinfo != NULL);
<span class="lineNum">    3041 </span>            : 
<span class="lineNum">    3042 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    3043 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerGetShape called for record = %i\n&quot;, resultindex);</span>
<span class="lineNum">    3044 </span>            :   }
<span class="lineNum">    3045 </span>            : 
<span class="lineNum">    3046 </span>            :   /* If resultindex is set, fetch the shape from the resultcache, otherwise fetch it from the DB  */
<span class="lineNum">    3047 </span><span class="lineCov">          1 :   if (resultindex &gt;= 0) {</span>
<span class="lineNum">    3048 </span>            :     int status;
<span class="lineNum">    3049 </span>            : 
<span class="lineNum">    3050 </span><span class="lineCov">          1 :     layerinfo = (msPostGISLayerInfo*) layer-&gt;layerinfo;</span>
<span class="lineNum">    3051 </span>            : 
<span class="lineNum">    3052 </span>            :     /* Check the validity of the open result. */
<span class="lineNum">    3053 </span><span class="lineCov">          1 :     pgresult = layerinfo-&gt;pgresult;</span>
<span class="lineNum">    3054 </span><span class="lineCov">          1 :     if ( ! pgresult ) {</span>
<span class="lineNum">    3055 </span><span class="lineNoCov">          0 :       msSetError( MS_MISCERR,</span>
<span class="lineNum">    3056 </span>            :                   &quot;PostgreSQL result set is null.&quot;,
<span class="lineNum">    3057 </span>            :                   &quot;msPostGISLayerGetShape()&quot;);
<span class="lineNum">    3058 </span><span class="lineNoCov">          0 :       return MS_FAILURE;</span>
<span class="lineNum">    3059 </span>            :     }
<span class="lineNum">    3060 </span><span class="lineCov">          1 :     status = PQresultStatus(pgresult);</span>
<span class="lineNum">    3061 </span><span class="lineCov">          1 :     if ( layer-&gt;debug &gt; 1 ) {</span>
<span class="lineNum">    3062 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISLayerGetShape query status: %s (%d)\n&quot;, PQresStatus(status), status);</span>
<span class="lineNum">    3063 </span>            :     }
<span class="lineNum">    3064 </span><span class="lineCov">          1 :     if( ! ( status == PGRES_COMMAND_OK || status == PGRES_TUPLES_OK) ) {</span>
<span class="lineNum">    3065 </span><span class="lineNoCov">          0 :       msSetError( MS_MISCERR,</span>
<span class="lineNum">    3066 </span>            :                   &quot;PostgreSQL result set is not ready.&quot;,
<span class="lineNum">    3067 </span>            :                   &quot;msPostGISLayerGetShape()&quot;);
<span class="lineNum">    3068 </span><span class="lineNoCov">          0 :       return MS_FAILURE;</span>
<span class="lineNum">    3069 </span>            :     }
<span class="lineNum">    3070 </span>            : 
<span class="lineNum">    3071 </span>            :     /* Check the validity of the requested record number. */
<span class="lineNum">    3072 </span><span class="lineCov">          1 :     if( resultindex &gt;= PQntuples(pgresult) ) {</span>
<span class="lineNum">    3073 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISLayerGetShape got request for (%d) but only has %d tuples.\n&quot;, resultindex, PQntuples(pgresult));</span>
<span class="lineNum">    3074 </span><span class="lineNoCov">          0 :       msSetError( MS_MISCERR,</span>
<span class="lineNum">    3075 </span>            :                   &quot;Got request larger than result set.&quot;,
<span class="lineNum">    3076 </span>            :                   &quot;msPostGISLayerGetShape()&quot;);
<span class="lineNum">    3077 </span><span class="lineNoCov">          0 :       return MS_FAILURE;</span>
<span class="lineNum">    3078 </span>            :     }
<span class="lineNum">    3079 </span>            : 
<span class="lineNum">    3080 </span><span class="lineCov">          1 :     layerinfo-&gt;rownum = resultindex; /* Only return one result. */</span>
<span class="lineNum">    3081 </span>            : 
<span class="lineNum">    3082 </span>            :     /* We don't know the shape type until we read the geometry. */
<span class="lineNum">    3083 </span><span class="lineCov">          1 :     shape-&gt;type = MS_SHAPE_NULL;</span>
<span class="lineNum">    3084 </span>            : 
<span class="lineNum">    3085 </span>            :     /* Return the shape, cursor access mode. */
<span class="lineNum">    3086 </span><span class="lineCov">          1 :     msPostGISReadShape(layer, shape);</span>
<span class="lineNum">    3087 </span>            : 
<span class="lineNum">    3088 </span><span class="lineCov">          1 :     return (shape-&gt;type == MS_SHAPE_NULL) ? MS_FAILURE : MS_SUCCESS;</span>
<span class="lineNum">    3089 </span>            :   } else { /* no resultindex, fetch the shape from the DB */
<span class="lineNum">    3090 </span>            :     int num_tuples;
<span class="lineNum">    3091 </span>            :     char *strSQL = 0;
<span class="lineNum">    3092 </span>            : 
<span class="lineNum">    3093 </span>            :     /* Fill out layerinfo with our current DATA state. */
<span class="lineNum">    3094 </span><span class="lineCov">          1 :     if ( msPostGISParseData(layer) != MS_SUCCESS) {</span>
<span class="lineNum">    3095 </span>            :       return MS_FAILURE;
<span class="lineNum">    3096 </span>            :     }
<span class="lineNum">    3097 </span>            : 
<span class="lineNum">    3098 </span>            :     /*
<span class="lineNum">    3099 </span>            :     ** This comes *after* parsedata, because parsedata fills in
<span class="lineNum">    3100 </span>            :     ** layer-&gt;layerinfo.
<span class="lineNum">    3101 </span>            :     */
<span class="lineNum">    3102 </span><span class="lineCov">          1 :     layerinfo = (msPostGISLayerInfo*) layer-&gt;layerinfo;</span>
<span class="lineNum">    3103 </span>            : 
<span class="lineNum">    3104 </span>            :     /* Build a SQL query based on our current state. */
<span class="lineNum">    3105 </span><span class="lineCov">          1 :     strSQL = msPostGISBuildSQL(layer, NULL, &amp;shapeindex, NULL, -1);</span>
<span class="lineNum">    3106 </span><span class="lineCov">          1 :     if ( ! strSQL ) {</span>
<span class="lineNum">    3107 </span><span class="lineNoCov">          0 :       msSetError(MS_QUERYERR, &quot;Failed to build query SQL.&quot;, &quot;msPostGISLayerGetShape()&quot;);</span>
<span class="lineNum">    3108 </span><span class="lineNoCov">          0 :       return MS_FAILURE;</span>
<span class="lineNum">    3109 </span>            :     }
<span class="lineNum">    3110 </span>            : 
<span class="lineNum">    3111 </span><span class="lineCov">          1 :     if (layer-&gt;debug) {</span>
<span class="lineNum">    3112 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISLayerGetShape query: %s\n&quot;, strSQL);</span>
<span class="lineNum">    3113 </span>            :     }
<span class="lineNum">    3114 </span>            : 
<span class="lineNum">    3115 </span><span class="lineCov">          1 :     pgresult = PQexecParams(layerinfo-&gt;pgconn, strSQL,0, NULL, NULL, NULL, NULL, RESULTSET_TYPE);</span>
<span class="lineNum">    3116 </span>            : 
<span class="lineNum">    3117 </span>            :     /* Something went wrong. */
<span class="lineNum">    3118 </span><span class="lineCov">          1 :     if ( (!pgresult) || (PQresultStatus(pgresult) != PGRES_TUPLES_OK) ) {</span>
<span class="lineNum">    3119 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISLayerGetShape(): Error (%s) executing SQL: %s\n&quot;, PQerrorMessage(layerinfo-&gt;pgconn), strSQL );</span>
<span class="lineNum">    3120 </span><span class="lineNoCov">          0 :       msSetError(MS_QUERYERR, &quot;Error executing SQL. Check server logs.&quot;,&quot;msPostGISLayerGetShape()&quot;);</span>
<span class="lineNum">    3121 </span>            : 
<span class="lineNum">    3122 </span><span class="lineNoCov">          0 :       if (pgresult) {</span>
<span class="lineNum">    3123 </span><span class="lineNoCov">          0 :         PQclear(pgresult);</span>
<span class="lineNum">    3124 </span>            :       }
<span class="lineNum">    3125 </span><span class="lineNoCov">          0 :       free(strSQL);</span>
<span class="lineNum">    3126 </span>            : 
<span class="lineNum">    3127 </span><span class="lineNoCov">          0 :       return MS_FAILURE;</span>
<span class="lineNum">    3128 </span>            :     }
<span class="lineNum">    3129 </span>            : 
<span class="lineNum">    3130 </span>            :     /* Clean any existing pgresult before storing current one. */
<span class="lineNum">    3131 </span><span class="lineCov">          1 :     if(layerinfo-&gt;pgresult) PQclear(layerinfo-&gt;pgresult);</span>
<span class="lineNum">    3132 </span><span class="lineCov">          1 :     layerinfo-&gt;pgresult = pgresult;</span>
<span class="lineNum">    3133 </span>            : 
<span class="lineNum">    3134 </span>            :     /* Clean any existing SQL before storing current. */
<span class="lineNum">    3135 </span><span class="lineCov">          1 :     if(layerinfo-&gt;sql) free(layerinfo-&gt;sql);</span>
<span class="lineNum">    3136 </span><span class="lineCov">          1 :     layerinfo-&gt;sql = strSQL;</span>
<span class="lineNum">    3137 </span>            : 
<span class="lineNum">    3138 </span><span class="lineCov">          1 :     layerinfo-&gt;rownum = 0; /* Only return one result. */</span>
<span class="lineNum">    3139 </span>            : 
<span class="lineNum">    3140 </span>            :     /* We don't know the shape type until we read the geometry. */
<span class="lineNum">    3141 </span><span class="lineCov">          1 :     shape-&gt;type = MS_SHAPE_NULL;</span>
<span class="lineNum">    3142 </span>            : 
<span class="lineNum">    3143 </span><span class="lineCov">          1 :     num_tuples = PQntuples(pgresult);</span>
<span class="lineNum">    3144 </span><span class="lineCov">          1 :     if (layer-&gt;debug) {</span>
<span class="lineNum">    3145 </span><span class="lineNoCov">          0 :       msDebug(&quot;msPostGISLayerGetShape number of records: %d\n&quot;, num_tuples);</span>
<span class="lineNum">    3146 </span>            :     }
<span class="lineNum">    3147 </span>            : 
<span class="lineNum">    3148 </span><span class="lineCov">          1 :     if (num_tuples &gt; 0) {</span>
<span class="lineNum">    3149 </span>            :       /* Get shape in random access mode. */
<span class="lineNum">    3150 </span><span class="lineCov">          1 :       msPostGISReadShape(layer, shape);</span>
<span class="lineNum">    3151 </span>            :     }
<span class="lineNum">    3152 </span>            : 
<span class="lineNum">    3153 </span><span class="lineCov">          1 :     return (shape-&gt;type == MS_SHAPE_NULL) ? MS_FAILURE : ( (num_tuples &gt; 0) ? MS_SUCCESS : MS_DONE );</span>
<span class="lineNum">    3154 </span>            :   }
<span class="lineNum">    3155 </span>            : #else
<span class="lineNum">    3156 </span>            :   msSetError( MS_MISCERR,
<span class="lineNum">    3157 </span>            :               &quot;PostGIS support is not available.&quot;,
<span class="lineNum">    3158 </span>            :               &quot;msPostGISLayerGetShape()&quot;);
<span class="lineNum">    3159 </span>            :   return MS_FAILURE;
<span class="lineNum">    3160 </span>            : #endif
<span class="lineNum">    3161 </span>            : }
<span class="lineNum">    3162 </span>            : 
<span class="lineNum">    3163 </span>            : /**********************************************************************
<span class="lineNum">    3164 </span>            :  *                     msPostGISPassThroughFieldDefinitions()
<span class="lineNum">    3165 </span>            :  *
<span class="lineNum">    3166 </span>            :  * Pass the field definitions through to the layer metadata in the
<span class="lineNum">    3167 </span>            :  * &quot;gml_[item]_{type,width,precision}&quot; set of metadata items for
<span class="lineNum">    3168 </span>            :  * defining fields.
<span class="lineNum">    3169 </span>            :  **********************************************************************/
<span class="lineNum">    3170 </span>            : 
<span class="lineNum">    3171 </span>            : /* These are the OIDs for some builtin types, as returned by PQftype(). */
<span class="lineNum">    3172 </span>            : /* They were copied from pg_type.h in src/include/catalog/pg_type.h */
<span class="lineNum">    3173 </span>            : 
<span class="lineNum">    3174 </span>            : #ifndef BOOLOID
<span class="lineNum">    3175 </span>            : #define BOOLOID                 16
<span class="lineNum">    3176 </span>            : #define BYTEAOID                17
<span class="lineNum">    3177 </span>            : #define CHAROID                 18
<span class="lineNum">    3178 </span>            : #define NAMEOID                 19
<span class="lineNum">    3179 </span>            : #define INT8OID                 20
<span class="lineNum">    3180 </span>            : #define INT2OID                 21
<span class="lineNum">    3181 </span>            : #define INT2VECTOROID           22
<span class="lineNum">    3182 </span>            : #define INT4OID                 23
<span class="lineNum">    3183 </span>            : #define REGPROCOID              24
<span class="lineNum">    3184 </span>            : #define TEXTOID                 25
<span class="lineNum">    3185 </span>            : #define OIDOID                  26
<span class="lineNum">    3186 </span>            : #define TIDOID                  27
<span class="lineNum">    3187 </span>            : #define XIDOID                  28
<span class="lineNum">    3188 </span>            : #define CIDOID                  29
<span class="lineNum">    3189 </span>            : #define OIDVECTOROID            30
<span class="lineNum">    3190 </span>            : #define FLOAT4OID               700
<span class="lineNum">    3191 </span>            : #define FLOAT8OID               701
<span class="lineNum">    3192 </span>            : #define INT4ARRAYOID            1007
<span class="lineNum">    3193 </span>            : #define TEXTARRAYOID            1009
<span class="lineNum">    3194 </span>            : #define BPCHARARRAYOID          1014
<span class="lineNum">    3195 </span>            : #define VARCHARARRAYOID         1015
<span class="lineNum">    3196 </span>            : #define FLOAT4ARRAYOID          1021
<span class="lineNum">    3197 </span>            : #define FLOAT8ARRAYOID          1022
<span class="lineNum">    3198 </span>            : #define BPCHAROID   1042
<span class="lineNum">    3199 </span>            : #define VARCHAROID    1043
<span class="lineNum">    3200 </span>            : #define DATEOID     1082
<span class="lineNum">    3201 </span>            : #define TIMEOID     1083
<span class="lineNum">    3202 </span>            : #define TIMETZOID     1266
<span class="lineNum">    3203 </span>            : #define TIMESTAMPOID          1114
<span class="lineNum">    3204 </span>            : #define TIMESTAMPTZOID          1184
<span class="lineNum">    3205 </span>            : #define NUMERICOID              1700
<span class="lineNum">    3206 </span>            : #endif
<span class="lineNum">    3207 </span>            : 
<a name="3208"><span class="lineNum">    3208 </span>            : #ifdef USE_POSTGIS</a>
<span class="lineNum">    3209 </span>            : static void
<span class="lineNum">    3210 </span><span class="lineCov">          1 : msPostGISPassThroughFieldDefinitions( layerObj *layer,</span>
<span class="lineNum">    3211 </span>            :                                       PGresult *pgresult )
<span class="lineNum">    3212 </span>            : 
<span class="lineNum">    3213 </span>            : {
<span class="lineNum">    3214 </span><span class="lineCov">          1 :   int i, numitems = PQnfields(pgresult);</span>
<span class="lineNum">    3215 </span><span class="lineCov">          1 :   msPostGISLayerInfo *layerinfo = layer-&gt;layerinfo;</span>
<span class="lineNum">    3216 </span>            : 
<span class="lineNum">    3217 </span><span class="lineCov">          1 :   for(i=0; i&lt;numitems; i++) {</span>
<span class="lineNum">    3218 </span>            :     int oid, fmod;
<span class="lineNum">    3219 </span>            :     const char *gml_type = &quot;Character&quot;;
<span class="lineNum">    3220 </span><span class="lineCov">          1 :     const char *item = PQfname(pgresult,i);</span>
<span class="lineNum">    3221 </span>            :     char md_item_name[256];
<span class="lineNum">    3222 </span>            :     char gml_width[32], gml_precision[32];
<span class="lineNum">    3223 </span>            : 
<span class="lineNum">    3224 </span><span class="lineCov">          1 :     gml_width[0] = '\0';</span>
<span class="lineNum">    3225 </span><span class="lineCov">          1 :     gml_precision[0] = '\0';</span>
<span class="lineNum">    3226 </span>            : 
<span class="lineNum">    3227 </span>            :     /* skip geometry column */
<span class="lineNum">    3228 </span><span class="lineCov">          1 :     if( strcmp(item, layerinfo-&gt;geomcolumn) == 0 )</span>
<span class="lineNum">    3229 </span><span class="lineCov">          1 :       continue;</span>
<span class="lineNum">    3230 </span>            : 
<span class="lineNum">    3231 </span><span class="lineCov">          1 :     oid = PQftype(pgresult,i);</span>
<span class="lineNum">    3232 </span><span class="lineCov">          1 :     fmod = PQfmod(pgresult,i);</span>
<span class="lineNum">    3233 </span>            : 
<span class="lineNum">    3234 </span><span class="lineCov">          1 :     if( (oid == BPCHAROID || oid == VARCHAROID) &amp;&amp; fmod &gt;= 4 ) {</span>
<span class="lineNum">    3235 </span><span class="lineNoCov">          0 :       sprintf( gml_width, &quot;%d&quot;, fmod-4 );</span>
<span class="lineNum">    3236 </span>            : 
<span class="lineNum">    3237 </span><span class="lineCov">          1 :     } else if( oid == BOOLOID ) {</span>
<span class="lineNum">    3238 </span>            :       gml_type = &quot;Integer&quot;;
<span class="lineNum">    3239 </span>            :       sprintf( gml_width, &quot;%d&quot;, 1 );
<span class="lineNum">    3240 </span>            : 
<span class="lineNum">    3241 </span><span class="lineCov">          1 :     } else if( oid == INT2OID ) {</span>
<span class="lineNum">    3242 </span>            :       gml_type = &quot;Integer&quot;;
<span class="lineNum">    3243 </span>            :       sprintf( gml_width, &quot;%d&quot;, 5 );
<span class="lineNum">    3244 </span>            : 
<span class="lineNum">    3245 </span><span class="lineCov">          1 :     } else if( oid == INT4OID ) {</span>
<span class="lineNum">    3246 </span>            :       gml_type = &quot;Integer&quot;;
<span class="lineNum">    3247 </span>            : 
<span class="lineNum">    3248 </span><span class="lineCov">          1 :     } else if( oid == INT8OID ) {</span>
<span class="lineNum">    3249 </span>            :       gml_type = &quot;Long&quot;;
<span class="lineNum">    3250 </span>            : 
<span class="lineNum">    3251 </span><span class="lineCov">          1 :     } else if( oid == FLOAT4OID || oid == FLOAT8OID ) {</span>
<span class="lineNum">    3252 </span>            :       gml_type = &quot;Real&quot;;
<span class="lineNum">    3253 </span>            : 
<span class="lineNum">    3254 </span><span class="lineCov">          1 :     } else if( oid == NUMERICOID ) {</span>
<span class="lineNum">    3255 </span>            :       gml_type = &quot;Real&quot;;
<span class="lineNum">    3256 </span>            : 
<span class="lineNum">    3257 </span><span class="lineNoCov">          0 :       if( fmod &gt;= 4 &amp;&amp; ((fmod - 4) &amp; 0xFFFF) == 0 ) {</span>
<span class="lineNum">    3258 </span>            :         gml_type = &quot;Integer&quot;;
<span class="lineNum">    3259 </span><span class="lineNoCov">          0 :         sprintf( gml_width, &quot;%d&quot;, (fmod - 4) &gt;&gt; 16 );</span>
<span class="lineNum">    3260 </span><span class="lineNoCov">          0 :       } else if( fmod &gt;= 4 ) {</span>
<span class="lineNum">    3261 </span><span class="lineNoCov">          0 :         sprintf( gml_width, &quot;%d&quot;, (fmod - 4) &gt;&gt; 16 );</span>
<span class="lineNum">    3262 </span><span class="lineNoCov">          0 :         sprintf( gml_precision, &quot;%d&quot;, ((fmod-4) &amp; 0xFFFF) );</span>
<span class="lineNum">    3263 </span>            :       }
<span class="lineNum">    3264 </span><span class="lineCov">          1 :     } else if( oid == DATEOID ) {</span>
<span class="lineNum">    3265 </span>            :       gml_type = &quot;Date&quot;;
<span class="lineNum">    3266 </span><span class="lineCov">          1 :     } else if( oid == TIMEOID || oid == TIMETZOID ) {</span>
<span class="lineNum">    3267 </span>            :       gml_type = &quot;Time&quot;;
<span class="lineNum">    3268 </span><span class="lineCov">          1 :     } else if( oid == TIMESTAMPOID || oid == TIMESTAMPTZOID ) {</span>
<span class="lineNum">    3269 </span>            :       gml_type = &quot;DateTime&quot;;
<span class="lineNum">    3270 </span>            :     }
<span class="lineNum">    3271 </span>            : 
<span class="lineNum">    3272 </span>            :     snprintf( md_item_name, sizeof(md_item_name), &quot;gml_%s_type&quot;, item );
<span class="lineNum">    3273 </span><span class="lineCov">          1 :     if( msOWSLookupMetadata(&amp;(layer-&gt;metadata), &quot;G&quot;, &quot;type&quot;) == NULL )</span>
<span class="lineNum">    3274 </span><span class="lineCov">          1 :       msInsertHashTable(&amp;(layer-&gt;metadata), md_item_name, gml_type );</span>
<span class="lineNum">    3275 </span>            : 
<span class="lineNum">    3276 </span>            :     snprintf( md_item_name, sizeof(md_item_name), &quot;gml_%s_width&quot;, item );
<span class="lineNum">    3277 </span><span class="lineCov">          1 :     if( strlen(gml_width) &gt; 0</span>
<span class="lineNum">    3278 </span><span class="lineNoCov">          0 :         &amp;&amp; msOWSLookupMetadata(&amp;(layer-&gt;metadata), &quot;G&quot;, &quot;width&quot;) == NULL )</span>
<span class="lineNum">    3279 </span><span class="lineNoCov">          0 :       msInsertHashTable(&amp;(layer-&gt;metadata), md_item_name, gml_width );</span>
<span class="lineNum">    3280 </span>            : 
<span class="lineNum">    3281 </span>            :     snprintf( md_item_name, sizeof(md_item_name), &quot;gml_%s_precision&quot;,item );
<span class="lineNum">    3282 </span><span class="lineCov">          1 :     if( strlen(gml_precision) &gt; 0</span>
<span class="lineNum">    3283 </span><span class="lineNoCov">          0 :         &amp;&amp; msOWSLookupMetadata(&amp;(layer-&gt;metadata), &quot;G&quot;, &quot;precision&quot;)==NULL )</span>
<span class="lineNum">    3284 </span><span class="lineNoCov">          0 :       msInsertHashTable(&amp;(layer-&gt;metadata), md_item_name, gml_precision );</span>
<span class="lineNum">    3285 </span>            :   }
<span class="lineNum">    3286 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    3287 </span>            : #endif /* defined(USE_POSTGIS) */
<span class="lineNum">    3288 </span>            : 
<span class="lineNum">    3289 </span>            : /*
<span class="lineNum">    3290 </span>            : ** msPostGISLayerGetItems()
<span class="lineNum">    3291 </span>            : **
<span class="lineNum">    3292 </span>            : ** Registered vtable-&gt;LayerGetItems function. Query the database for
<span class="lineNum">    3293 </span>            : ** column information about the requested layer. Rather than look in
<span class="lineNum">    3294 </span>            : ** system tables, we just run a zero-cost query and read out of the
<a name="3295"><span class="lineNum">    3295 </span>            : ** result header.</a>
<span class="lineNum">    3296 </span>            : */
<span class="lineNum">    3297 </span><span class="lineCov">          1 : int msPostGISLayerGetItems(layerObj *layer)</span>
<span class="lineNum">    3298 </span>            : {
<span class="lineNum">    3299 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    3300 </span>            :   msPostGISLayerInfo *layerinfo = NULL;
<span class="lineNum">    3301 </span>            :   static char *strSQLTemplate = &quot;select * from %s where false limit 0&quot;;
<span class="lineNum">    3302 </span>            :   PGresult *pgresult = NULL;
<span class="lineNum">    3303 </span>            :   char *col = NULL;
<span class="lineNum">    3304 </span>            :   char *sql = NULL;
<span class="lineNum">    3305 </span>            :   char *strFrom = NULL;
<span class="lineNum">    3306 </span>            :   char found_geom = 0;
<span class="lineNum">    3307 </span>            :   const char *value;
<span class="lineNum">    3308 </span>            :   int t, item_num;
<span class="lineNum">    3309 </span>            :   rectObj rect;
<span class="lineNum">    3310 </span>            : 
<span class="lineNum">    3311 </span>            :   /* A useless rectangle for our useless query */
<span class="lineNum">    3312 </span><span class="lineCov">          1 :   rect.minx = rect.miny = rect.maxx = rect.maxy = 0.0;</span>
<span class="lineNum">    3313 </span>            : 
<span class="lineNum">    3314 </span>            :   assert(layer != NULL);
<span class="lineNum">    3315 </span>            :   assert(layer-&gt;layerinfo != NULL);
<span class="lineNum">    3316 </span>            : 
<span class="lineNum">    3317 </span>            :   layerinfo = (msPostGISLayerInfo*) layer-&gt;layerinfo;
<span class="lineNum">    3318 </span>            : 
<span class="lineNum">    3319 </span>            :   assert(layerinfo-&gt;pgconn);
<span class="lineNum">    3320 </span>            : 
<span class="lineNum">    3321 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    3322 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerGetItems called.\n&quot;);</span>
<span class="lineNum">    3323 </span>            :   }
<span class="lineNum">    3324 </span>            : 
<span class="lineNum">    3325 </span>            :   /* Fill out layerinfo with our current DATA state. */
<span class="lineNum">    3326 </span><span class="lineCov">          1 :   if ( msPostGISParseData(layer) != MS_SUCCESS) {</span>
<span class="lineNum">    3327 </span>            :     return MS_FAILURE;
<span class="lineNum">    3328 </span>            :   }
<span class="lineNum">    3329 </span>            : 
<span class="lineNum">    3330 </span><span class="lineCov">          1 :   layerinfo = (msPostGISLayerInfo*) layer-&gt;layerinfo;</span>
<span class="lineNum">    3331 </span>            : 
<span class="lineNum">    3332 </span>            :   /* This allocates a fresh string, so remember to free it... */
<span class="lineNum">    3333 </span><span class="lineCov">          1 :   strFrom = msPostGISReplaceBoxToken(layer, &amp;rect, layerinfo-&gt;fromsource);</span>
<span class="lineNum">    3334 </span>            : 
<span class="lineNum">    3335 </span>            :   /*
<span class="lineNum">    3336 </span>            :   ** Both the &quot;table&quot; and &quot;(select ...) as sub&quot; cases can be handled with the
<span class="lineNum">    3337 </span>            :   ** same SQL.
<span class="lineNum">    3338 </span>            :   */
<span class="lineNum">    3339 </span><span class="lineCov">          1 :   sql = (char*) msSmallMalloc(strlen(strSQLTemplate) + strlen(strFrom));</span>
<span class="lineNum">    3340 </span><span class="lineCov">          1 :   sprintf(sql, strSQLTemplate, strFrom);</span>
<span class="lineNum">    3341 </span><span class="lineCov">          1 :   free(strFrom);</span>
<span class="lineNum">    3342 </span>            : 
<span class="lineNum">    3343 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    3344 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerGetItems executing SQL: %s\n&quot;, sql);</span>
<span class="lineNum">    3345 </span>            :   }
<span class="lineNum">    3346 </span>            : 
<span class="lineNum">    3347 </span><span class="lineCov">          1 :   pgresult = PQexecParams(layerinfo-&gt;pgconn, sql,0, NULL, NULL, NULL, NULL, 0);</span>
<span class="lineNum">    3348 </span>            : 
<span class="lineNum">    3349 </span><span class="lineCov">          1 :   if ( (!pgresult) || (PQresultStatus(pgresult) != PGRES_TUPLES_OK) ) {</span>
<span class="lineNum">    3350 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerGetItems(): Error (%s) executing SQL: %s\n&quot;, PQerrorMessage(layerinfo-&gt;pgconn), sql);</span>
<span class="lineNum">    3351 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR, &quot;Error executing SQL. Check server logs&quot;,&quot;msPostGISLayerGetItems()&quot;);</span>
<span class="lineNum">    3352 </span><span class="lineNoCov">          0 :     if (pgresult) {</span>
<span class="lineNum">    3353 </span><span class="lineNoCov">          0 :       PQclear(pgresult);</span>
<span class="lineNum">    3354 </span>            :     }
<span class="lineNum">    3355 </span><span class="lineNoCov">          0 :     free(sql);</span>
<span class="lineNum">    3356 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    3357 </span>            :   }
<span class="lineNum">    3358 </span>            : 
<span class="lineNum">    3359 </span><span class="lineCov">          1 :   free(sql);</span>
<span class="lineNum">    3360 </span>            : 
<span class="lineNum">    3361 </span><span class="lineCov">          1 :   layer-&gt;numitems = PQnfields(pgresult) - 1; /* dont include the geometry column (last entry)*/</span>
<span class="lineNum">    3362 </span><span class="lineCov">          1 :   layer-&gt;items = msSmallMalloc(sizeof(char*) * (layer-&gt;numitems + 1)); /* +1 in case there is a problem finding geometry column */</span>
<span class="lineNum">    3363 </span>            : 
<span class="lineNum">    3364 </span>            :   found_geom = 0; /* havent found the geom field */
<span class="lineNum">    3365 </span>            :   item_num = 0;
<span class="lineNum">    3366 </span>            : 
<span class="lineNum">    3367 </span><span class="lineCov">          1 :   for (t = 0; t &lt; PQnfields(pgresult); t++) {</span>
<span class="lineNum">    3368 </span><span class="lineCov">          1 :     col = PQfname(pgresult, t);</span>
<span class="lineNum">    3369 </span><span class="lineCov">          1 :     if ( strcmp(col, layerinfo-&gt;geomcolumn) != 0 ) {</span>
<span class="lineNum">    3370 </span>            :       /* this isnt the geometry column */
<span class="lineNum">    3371 </span><span class="lineCov">          1 :       layer-&gt;items[item_num] = msStrdup(col);</span>
<span class="lineNum">    3372 </span><span class="lineCov">          1 :       item_num++;</span>
<span class="lineNum">    3373 </span>            :     } else {
<span class="lineNum">    3374 </span>            :       found_geom = 1;
<span class="lineNum">    3375 </span>            :     }
<span class="lineNum">    3376 </span>            :   }
<span class="lineNum">    3377 </span>            : 
<span class="lineNum">    3378 </span>            :   /*
<span class="lineNum">    3379 </span>            :   ** consider populating the field definitions in metadata.
<span class="lineNum">    3380 </span>            :   */
<span class="lineNum">    3381 </span><span class="lineCov">          1 :   if((value = msOWSLookupMetadata(&amp;(layer-&gt;metadata), &quot;G&quot;, &quot;types&quot;)) != NULL</span>
<span class="lineNum">    3382 </span><span class="lineCov">          1 :       &amp;&amp; strcasecmp(value,&quot;auto&quot;) == 0 )</span>
<span class="lineNum">    3383 </span><span class="lineCov">          1 :     msPostGISPassThroughFieldDefinitions( layer, pgresult );</span>
<span class="lineNum">    3384 </span>            : 
<span class="lineNum">    3385 </span>            :   /*
<span class="lineNum">    3386 </span>            :   ** Cleanup
<span class="lineNum">    3387 </span>            :   */
<span class="lineNum">    3388 </span><span class="lineCov">          1 :   PQclear(pgresult);</span>
<span class="lineNum">    3389 </span>            : 
<span class="lineNum">    3390 </span><span class="lineCov">          1 :   if (!found_geom) {</span>
<span class="lineNum">    3391 </span><span class="lineNoCov">          0 :     msSetError(MS_QUERYERR, &quot;Tried to find the geometry column in the database, but couldn't find it.  Is it mis-capitalized? '%s'&quot;, &quot;msPostGISLayerGetItems()&quot;, layerinfo-&gt;geomcolumn);</span>
<span class="lineNum">    3392 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    3393 </span>            :   }
<span class="lineNum">    3394 </span>            : 
<span class="lineNum">    3395 </span><span class="lineCov">          1 :   return msPostGISLayerInitItemInfo(layer);</span>
<span class="lineNum">    3396 </span>            : #else
<span class="lineNum">    3397 </span>            :   msSetError( MS_MISCERR,
<span class="lineNum">    3398 </span>            :               &quot;PostGIS support is not available.&quot;,
<span class="lineNum">    3399 </span>            :               &quot;msPostGISLayerGetItems()&quot;);
<span class="lineNum">    3400 </span>            :   return MS_FAILURE;
<span class="lineNum">    3401 </span>            : #endif
<span class="lineNum">    3402 </span>            : }
<span class="lineNum">    3403 </span>            : 
<span class="lineNum">    3404 </span>            : /*
<span class="lineNum">    3405 </span>            : ** msPostGISLayerGetExtent()
<span class="lineNum">    3406 </span>            : **
<span class="lineNum">    3407 </span>            : ** Registered vtable-&gt;LayerGetExtent function. Query the database for
<a name="3408"><span class="lineNum">    3408 </span>            : ** the extent of the requested layer.</a>
<span class="lineNum">    3409 </span>            : */
<span class="lineNum">    3410 </span><span class="lineCov">          1 : int msPostGISLayerGetExtent(layerObj *layer, rectObj *extent)</span>
<span class="lineNum">    3411 </span>            : {
<span class="lineNum">    3412 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    3413 </span>            :   msPostGISLayerInfo *layerinfo = NULL;
<span class="lineNum">    3414 </span>            :   char *strSQL = NULL;
<span class="lineNum">    3415 </span>            :   char *strFilter1 = 0, *strFilter2 = 0;
<span class="lineNum">    3416 </span>            :   char *f_table_name;
<span class="lineNum">    3417 </span>            :   static char *sqlExtentTemplate = &quot;SELECT ST_Extent(%s) FROM %s&quot;;
<span class="lineNum">    3418 </span>            :   size_t buffer_len;
<span class="lineNum">    3419 </span>            :   size_t strFilterLength1 = 0, strFilterLength2 = 0;
<span class="lineNum">    3420 </span>            :   PGresult *pgresult = NULL;
<span class="lineNum">    3421 </span>            :   
<span class="lineNum">    3422 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    3423 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerGetExtent called.\n&quot;);</span>
<span class="lineNum">    3424 </span>            :   }
<span class="lineNum">    3425 </span>            : 
<span class="lineNum">    3426 </span>            :   assert( layer-&gt;layerinfo != NULL);
<span class="lineNum">    3427 </span>            : 
<span class="lineNum">    3428 </span><span class="lineCov">          1 :   layerinfo = (msPostGISLayerInfo *)layer-&gt;layerinfo;</span>
<span class="lineNum">    3429 </span>            : 
<span class="lineNum">    3430 </span><span class="lineCov">          1 :   if ( msPostGISParseData(layer) != MS_SUCCESS) {</span>
<span class="lineNum">    3431 </span>            :     return MS_FAILURE;
<span class="lineNum">    3432 </span>            :   }
<span class="lineNum">    3433 </span>            : 
<span class="lineNum">    3434 </span>            :   /* if we have !BOX! substitution then we use just the table name */
<span class="lineNum">    3435 </span><span class="lineCov">          1 :   if ( strstr(layerinfo-&gt;fromsource, BOXTOKEN) )</span>
<span class="lineNum">    3436 </span><span class="lineNoCov">          0 :     f_table_name = msPostGISFindTableName(layerinfo-&gt;fromsource);</span>
<span class="lineNum">    3437 </span>            :   else
<span class="lineNum">    3438 </span><span class="lineCov">          1 :     f_table_name = msStrdup(layerinfo-&gt;fromsource);</span>
<span class="lineNum">    3439 </span>            :   
<span class="lineNum">    3440 </span><span class="lineCov">          1 :   if ( !f_table_name ) {</span>
<span class="lineNum">    3441 </span><span class="lineNoCov">          0 :     msSetError(MS_MISCERR, &quot;Failed to get table name.&quot;, &quot;msPostGISLayerGetExtent()&quot;);</span>
<span class="lineNum">    3442 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    3443 </span>            :   }
<span class="lineNum">    3444 </span>            : 
<span class="lineNum">    3445 </span>            :   /* Handle a translated filter (RFC91). */
<span class="lineNum">    3446 </span><span class="lineCov">          1 :   if (layer-&gt;filter.native_string) {</span>
<span class="lineNum">    3447 </span>            :       static char *strFilterTemplate = &quot;(%s)&quot;;
<span class="lineNum">    3448 </span><span class="lineNoCov">          0 :       strFilter1 = (char *)msSmallMalloc(strlen(strFilterTemplate) + strlen(layer-&gt;filter.native_string) + 1);</span>
<span class="lineNum">    3449 </span><span class="lineNoCov">          0 :       sprintf(strFilter1, strFilterTemplate, layer-&gt;filter.native_string);</span>
<span class="lineNum">    3450 </span><span class="lineNoCov">          0 :       strFilterLength1 = strlen(strFilter1) + 7;</span>
<span class="lineNum">    3451 </span>            :   }
<span class="lineNum">    3452 </span>            : 
<span class="lineNum">    3453 </span>            :   /* Handle a native filter set as a PROCESSING option (#5001). */
<span class="lineNum">    3454 </span><span class="lineCov">          1 :   if (msLayerGetProcessingKey(layer, &quot;NATIVE_FILTER&quot;) != NULL) {</span>
<span class="lineNum">    3455 </span>            :       static char *strFilterTemplate = &quot;(%s)&quot;;
<span class="lineNum">    3456 </span><span class="lineNoCov">          0 :       char *native_filter = msLayerGetProcessingKey(layer, &quot;NATIVE_FILTER&quot;);</span>
<span class="lineNum">    3457 </span><span class="lineNoCov">          0 :       strFilter2 = (char *)msSmallMalloc(strlen(strFilterTemplate) + strlen(native_filter) + 1);</span>
<span class="lineNum">    3458 </span><span class="lineNoCov">          0 :       sprintf(strFilter2, strFilterTemplate, native_filter);</span>
<span class="lineNum">    3459 </span><span class="lineNoCov">          0 :       strFilterLength2 = strlen(strFilter2) + 7;</span>
<span class="lineNum">    3460 </span>            :   }
<span class="lineNum">    3461 </span>            : 
<span class="lineNum">    3462 </span><span class="lineCov">          1 :   buffer_len = strlen(layerinfo-&gt;geomcolumn) + strlen(f_table_name) + strlen(sqlExtentTemplate)</span>
<span class="lineNum">    3463 </span><span class="lineCov">          1 :       + strFilterLength1 + strFilterLength2;</span>
<span class="lineNum">    3464 </span><span class="lineCov">          1 :   strSQL = (char*)msSmallMalloc(buffer_len+1); /* add space for terminating NULL */</span>
<span class="lineNum">    3465 </span><span class="lineCov">          1 :   snprintf(strSQL, buffer_len, sqlExtentTemplate, layerinfo-&gt;geomcolumn, f_table_name);  </span>
<span class="lineNum">    3466 </span><span class="lineCov">          1 :   msFree(f_table_name);</span>
<span class="lineNum">    3467 </span>            : 
<span class="lineNum">    3468 </span><span class="lineCov">          1 :   if (strFilter1) {</span>
<span class="lineNum">    3469 </span><span class="lineNoCov">          0 :       strlcat(strSQL, &quot; where &quot;, buffer_len);</span>
<span class="lineNum">    3470 </span><span class="lineNoCov">          0 :       strlcat(strSQL, strFilter1, buffer_len);</span>
<span class="lineNum">    3471 </span><span class="lineNoCov">          0 :       msFree(strFilter1);</span>
<span class="lineNum">    3472 </span><span class="lineNoCov">          0 :       if (strFilter2) {</span>
<span class="lineNum">    3473 </span><span class="lineNoCov">          0 :           strlcat(strSQL, &quot; and &quot;, buffer_len);</span>
<span class="lineNum">    3474 </span><span class="lineNoCov">          0 :           strlcat(strSQL, strFilter2, buffer_len);</span>
<span class="lineNum">    3475 </span><span class="lineNoCov">          0 :           msFree(strFilter2);</span>
<span class="lineNum">    3476 </span>            :       }
<span class="lineNum">    3477 </span>            :   }
<span class="lineNum">    3478 </span><span class="lineCov">          1 :   else if (strFilter2) {</span>
<span class="lineNum">    3479 </span><span class="lineNoCov">          0 :       strlcat(strSQL, &quot; where &quot;, buffer_len);</span>
<span class="lineNum">    3480 </span><span class="lineNoCov">          0 :       strlcat(strSQL, strFilter2, buffer_len);</span>
<span class="lineNum">    3481 </span><span class="lineNoCov">          0 :       msFree(strFilter2);</span>
<span class="lineNum">    3482 </span>            :   }
<span class="lineNum">    3483 </span>            : 
<span class="lineNum">    3484 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    3485 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISLayerGetExtent executing SQL: %s\n&quot;, strSQL);</span>
<span class="lineNum">    3486 </span>            :   }
<span class="lineNum">    3487 </span>            : 
<span class="lineNum">    3488 </span>            :   /* executing the query */
<span class="lineNum">    3489 </span><span class="lineCov">          1 :   pgresult = PQexecParams(layerinfo-&gt;pgconn, strSQL,0, NULL, NULL, NULL, NULL, 0);</span>
<span class="lineNum">    3490 </span>            : 
<span class="lineNum">    3491 </span><span class="lineCov">          1 :   msFree(strSQL);</span>
<span class="lineNum">    3492 </span>            : 
<span class="lineNum">    3493 </span><span class="lineCov">          1 :   if ( (!pgresult) || (PQresultStatus(pgresult) != PGRES_TUPLES_OK) ) {</span>
<span class="lineNum">    3494 </span><span class="lineNoCov">          0 :     msDebug(&quot;Error executing SQL: (%s) in msPostGISLayerGetExtent()&quot;, PQerrorMessage(layerinfo-&gt;pgconn));</span>
<span class="lineNum">    3495 </span><span class="lineNoCov">          0 :     msSetError(MS_MISCERR, &quot;Error executing SQL. Check server logs.&quot;,&quot;msPostGISLayerGetExtent()&quot;);</span>
<span class="lineNum">    3496 </span><span class="lineNoCov">          0 :     if (pgresult)</span>
<span class="lineNum">    3497 </span><span class="lineNoCov">          0 :       PQclear(pgresult);</span>
<span class="lineNum">    3498 </span>            : 
<span class="lineNum">    3499 </span>            :     return MS_FAILURE;
<span class="lineNum">    3500 </span>            :   }
<span class="lineNum">    3501 </span>            : 
<span class="lineNum">    3502 </span>            :   /* process results */
<span class="lineNum">    3503 </span><span class="lineCov">          1 :   if (PQntuples(pgresult) &lt; 1) {</span>
<span class="lineNum">    3504 </span><span class="lineNoCov">          0 :     msSetError(MS_MISCERR, &quot;msPostGISLayerGetExtent: No results found.&quot;, </span>
<span class="lineNum">    3505 </span>            :         &quot;msPostGISLayerGetExtent()&quot;);
<span class="lineNum">    3506 </span><span class="lineNoCov">          0 :     PQclear(pgresult);</span>
<span class="lineNum">    3507 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    3508 </span>            :   }
<span class="lineNum">    3509 </span>            :   
<span class="lineNum">    3510 </span><span class="lineCov">          1 :   if (PQgetisnull(pgresult, 0, 0)) {</span>
<span class="lineNum">    3511 </span><span class="lineNoCov">          0 :     msSetError(MS_MISCERR, &quot;msPostGISLayerGetExtent: Null result returned.&quot;, </span>
<span class="lineNum">    3512 </span>            :         &quot;msPostGISLayerGetExtent()&quot;);
<span class="lineNum">    3513 </span><span class="lineNoCov">          0 :     PQclear(pgresult);</span>
<span class="lineNum">    3514 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    3515 </span>            :   }
<span class="lineNum">    3516 </span>            : 
<span class="lineNum">    3517 </span><span class="lineCov">          1 :   if (sscanf(PQgetvalue(pgresult, 0, 0), &quot;BOX(%lf %lf,%lf %lf)&quot;, </span>
<span class="lineNum">    3518 </span>            :          &amp;extent-&gt;minx, &amp;extent-&gt;miny, &amp;extent-&gt;maxx, &amp;extent-&gt;maxy) != 4) {
<span class="lineNum">    3519 </span><span class="lineNoCov">          0 :     msSetError(MS_MISCERR, &quot;Failed to process result data.&quot;, &quot;msPostGISLayerGetExtent()&quot;);</span>
<span class="lineNum">    3520 </span><span class="lineNoCov">          0 :     PQclear(pgresult);</span>
<span class="lineNum">    3521 </span><span class="lineNoCov">          0 :     return MS_FAILURE;</span>
<span class="lineNum">    3522 </span>            :   }
<span class="lineNum">    3523 </span>            : 
<span class="lineNum">    3524 </span>            :   /* cleanup */
<span class="lineNum">    3525 </span><span class="lineCov">          1 :   PQclear(pgresult);</span>
<span class="lineNum">    3526 </span>            : 
<span class="lineNum">    3527 </span><span class="lineCov">          1 :   return MS_SUCCESS;</span>
<span class="lineNum">    3528 </span>            : #else
<span class="lineNum">    3529 </span>            :   msSetError( MS_MISCERR, &quot;PostGIS support is not available.&quot;, &quot;msPostGISLayerGetExtent()&quot;);
<span class="lineNum">    3530 </span>            :   return MS_FAILURE;
<span class="lineNum">    3531 </span>            : #endif
<span class="lineNum">    3532 </span>            : }
<span class="lineNum">    3533 </span>            : 
<span class="lineNum">    3534 </span>            : /*
<span class="lineNum">    3535 </span>            : ** msPostGISLayerGetNumFeatures()
<span class="lineNum">    3536 </span>            : **
<span class="lineNum">    3537 </span>            : ** Registered vtable-&gt;LayerGetNumFeatures function. Query the database for
<a name="3538"><span class="lineNum">    3538 </span>            : ** the feature count of the requested layer.</a>
<span class="lineNum">    3539 </span>            : */
<span class="lineNum">    3540 </span><span class="lineNoCov">          0 : int msPostGISLayerGetNumFeatures(layerObj *layer)</span>
<span class="lineNum">    3541 </span>            : {
<span class="lineNum">    3542 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    3543 </span>            :     msPostGISLayerInfo *layerinfo = NULL;
<span class="lineNum">    3544 </span>            :     char *strSQL = NULL;
<span class="lineNum">    3545 </span>            :     char *strFilter1 = 0, *strFilter2 = 0;
<span class="lineNum">    3546 </span>            :     char *f_table_name;
<span class="lineNum">    3547 </span>            :     static char *sqlNumFeaturesTemplate = &quot;SELECT count(*) FROM %s&quot;;
<span class="lineNum">    3548 </span>            :     size_t buffer_len;
<span class="lineNum">    3549 </span>            :     size_t strFilterLength1 = 0, strFilterLength2 = 0;
<span class="lineNum">    3550 </span>            :     PGresult *pgresult = NULL;
<span class="lineNum">    3551 </span>            :     int result;
<span class="lineNum">    3552 </span>            :     char *tmp;
<span class="lineNum">    3553 </span>            : 
<span class="lineNum">    3554 </span><span class="lineNoCov">          0 :     if (layer-&gt;debug) {</span>
<span class="lineNum">    3555 </span><span class="lineNoCov">          0 :         msDebug(&quot;msPostGISLayerGetNumFeatures called.\n&quot;);</span>
<span class="lineNum">    3556 </span>            :     }
<span class="lineNum">    3557 </span>            : 
<span class="lineNum">    3558 </span>            :     assert(layer-&gt;layerinfo != NULL);
<span class="lineNum">    3559 </span>            : 
<span class="lineNum">    3560 </span><span class="lineNoCov">          0 :     layerinfo = (msPostGISLayerInfo *)layer-&gt;layerinfo;</span>
<span class="lineNum">    3561 </span>            : 
<span class="lineNum">    3562 </span><span class="lineNoCov">          0 :     if (msPostGISParseData(layer) != MS_SUCCESS) {</span>
<span class="lineNum">    3563 </span>            :         return -1;
<span class="lineNum">    3564 </span>            :     }
<span class="lineNum">    3565 </span>            : 
<span class="lineNum">    3566 </span>            :     /* if we have !BOX! substitution then we use just the table name */
<span class="lineNum">    3567 </span><span class="lineNoCov">          0 :     if (strstr(layerinfo-&gt;fromsource, BOXTOKEN))</span>
<span class="lineNum">    3568 </span><span class="lineNoCov">          0 :         f_table_name = msPostGISFindTableName(layerinfo-&gt;fromsource);</span>
<span class="lineNum">    3569 </span>            :     else
<span class="lineNum">    3570 </span><span class="lineNoCov">          0 :         f_table_name = msStrdup(layerinfo-&gt;fromsource);</span>
<span class="lineNum">    3571 </span>            : 
<span class="lineNum">    3572 </span><span class="lineNoCov">          0 :     if (!f_table_name) {</span>
<span class="lineNum">    3573 </span><span class="lineNoCov">          0 :         msSetError(MS_MISCERR, &quot;Failed to get table name.&quot;, &quot;msPostGISLayerGetExtent()&quot;);</span>
<span class="lineNum">    3574 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">    3575 </span>            :     }
<span class="lineNum">    3576 </span>            : 
<span class="lineNum">    3577 </span>            :     /* Handle a translated filter (RFC91). */
<span class="lineNum">    3578 </span><span class="lineNoCov">          0 :     if (layer-&gt;filter.native_string) {</span>
<span class="lineNum">    3579 </span>            :         static char *strFilterTemplate = &quot;(%s)&quot;;
<span class="lineNum">    3580 </span><span class="lineNoCov">          0 :         strFilter1 = (char *)msSmallMalloc(strlen(strFilterTemplate) + strlen(layer-&gt;filter.native_string) + 1);</span>
<span class="lineNum">    3581 </span><span class="lineNoCov">          0 :         sprintf(strFilter1, strFilterTemplate, layer-&gt;filter.native_string);</span>
<span class="lineNum">    3582 </span><span class="lineNoCov">          0 :         strFilterLength1 = strlen(strFilter1) + 7;</span>
<span class="lineNum">    3583 </span>            :     }
<span class="lineNum">    3584 </span>            : 
<span class="lineNum">    3585 </span>            :     /* Handle a native filter set as a PROCESSING option (#5001). */
<span class="lineNum">    3586 </span><span class="lineNoCov">          0 :     if (msLayerGetProcessingKey(layer, &quot;NATIVE_FILTER&quot;) != NULL) {</span>
<span class="lineNum">    3587 </span>            :         static char *strFilterTemplate = &quot;(%s)&quot;;
<span class="lineNum">    3588 </span><span class="lineNoCov">          0 :         char *native_filter = msLayerGetProcessingKey(layer, &quot;NATIVE_FILTER&quot;);</span>
<span class="lineNum">    3589 </span><span class="lineNoCov">          0 :         strFilter2 = (char *)msSmallMalloc(strlen(strFilterTemplate) + strlen(native_filter) + 1);</span>
<span class="lineNum">    3590 </span><span class="lineNoCov">          0 :         sprintf(strFilter2, strFilterTemplate, native_filter);</span>
<span class="lineNum">    3591 </span><span class="lineNoCov">          0 :         strFilterLength2 = strlen(strFilter2) + 7;</span>
<span class="lineNum">    3592 </span>            :     }
<span class="lineNum">    3593 </span>            : 
<span class="lineNum">    3594 </span><span class="lineNoCov">          0 :     buffer_len = strlen(f_table_name) + strlen(sqlNumFeaturesTemplate)</span>
<span class="lineNum">    3595 </span><span class="lineNoCov">          0 :         + strFilterLength1 + strFilterLength2;</span>
<span class="lineNum">    3596 </span><span class="lineNoCov">          0 :     strSQL = (char*)msSmallMalloc(buffer_len + 1); /* add space for terminating NULL */</span>
<span class="lineNum">    3597 </span><span class="lineNoCov">          0 :     snprintf(strSQL, buffer_len, sqlNumFeaturesTemplate, f_table_name);</span>
<span class="lineNum">    3598 </span><span class="lineNoCov">          0 :     msFree(f_table_name);</span>
<span class="lineNum">    3599 </span>            : 
<span class="lineNum">    3600 </span><span class="lineNoCov">          0 :     if (strFilter1) {</span>
<span class="lineNum">    3601 </span><span class="lineNoCov">          0 :         strlcat(strSQL, &quot; where &quot;, buffer_len);</span>
<span class="lineNum">    3602 </span><span class="lineNoCov">          0 :         strlcat(strSQL, strFilter1, buffer_len);</span>
<span class="lineNum">    3603 </span><span class="lineNoCov">          0 :         msFree(strFilter1);</span>
<span class="lineNum">    3604 </span><span class="lineNoCov">          0 :         if (strFilter2) {</span>
<span class="lineNum">    3605 </span><span class="lineNoCov">          0 :             strlcat(strSQL, &quot; and &quot;, buffer_len);</span>
<span class="lineNum">    3606 </span><span class="lineNoCov">          0 :             strlcat(strSQL, strFilter2, buffer_len);</span>
<span class="lineNum">    3607 </span><span class="lineNoCov">          0 :             msFree(strFilter2);</span>
<span class="lineNum">    3608 </span>            :         }
<span class="lineNum">    3609 </span>            :     }
<span class="lineNum">    3610 </span><span class="lineNoCov">          0 :     else if (strFilter2) {</span>
<span class="lineNum">    3611 </span><span class="lineNoCov">          0 :         strlcat(strSQL, &quot; where &quot;, buffer_len);</span>
<span class="lineNum">    3612 </span><span class="lineNoCov">          0 :         strlcat(strSQL, strFilter2, buffer_len);</span>
<span class="lineNum">    3613 </span><span class="lineNoCov">          0 :         msFree(strFilter2);</span>
<span class="lineNum">    3614 </span>            :     }
<span class="lineNum">    3615 </span>            : 
<span class="lineNum">    3616 </span><span class="lineNoCov">          0 :     if (layer-&gt;debug) {</span>
<span class="lineNum">    3617 </span><span class="lineNoCov">          0 :         msDebug(&quot;msPostGISLayerGetNumFeatures executing SQL: %s\n&quot;, strSQL);</span>
<span class="lineNum">    3618 </span>            :     }
<span class="lineNum">    3619 </span>            : 
<span class="lineNum">    3620 </span>            :     /* executing the query */
<span class="lineNum">    3621 </span><span class="lineNoCov">          0 :     pgresult = PQexecParams(layerinfo-&gt;pgconn, strSQL, 0, NULL, NULL, NULL, NULL, 0);</span>
<span class="lineNum">    3622 </span>            : 
<span class="lineNum">    3623 </span><span class="lineNoCov">          0 :     msFree(strSQL);</span>
<span class="lineNum">    3624 </span>            : 
<span class="lineNum">    3625 </span><span class="lineNoCov">          0 :     if ((!pgresult) || (PQresultStatus(pgresult) != PGRES_TUPLES_OK)) {</span>
<span class="lineNum">    3626 </span><span class="lineNoCov">          0 :         msDebug(&quot;Error executing SQL: (%s) in msPostGISLayerGetNumFeatures()&quot;, PQerrorMessage(layerinfo-&gt;pgconn));</span>
<span class="lineNum">    3627 </span><span class="lineNoCov">          0 :         msSetError(MS_MISCERR, &quot;Error executing SQL. Check server logs.&quot;, &quot;msPostGISLayerGetNumFeatures()&quot;);</span>
<span class="lineNum">    3628 </span><span class="lineNoCov">          0 :         if (pgresult)</span>
<span class="lineNum">    3629 </span><span class="lineNoCov">          0 :             PQclear(pgresult);</span>
<span class="lineNum">    3630 </span>            : 
<span class="lineNum">    3631 </span>            :         return -1;
<span class="lineNum">    3632 </span>            :     }
<span class="lineNum">    3633 </span>            : 
<span class="lineNum">    3634 </span>            :     /* process results */
<span class="lineNum">    3635 </span><span class="lineNoCov">          0 :     if (PQntuples(pgresult) &lt; 1) {</span>
<span class="lineNum">    3636 </span><span class="lineNoCov">          0 :         msSetError(MS_MISCERR, &quot;msPostGISLayerGetNumFeatures: No results found.&quot;,</span>
<span class="lineNum">    3637 </span>            :             &quot;msPostGISLayerGetNumFeatures()&quot;);
<span class="lineNum">    3638 </span><span class="lineNoCov">          0 :         PQclear(pgresult);</span>
<span class="lineNum">    3639 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">    3640 </span>            :     }
<span class="lineNum">    3641 </span>            : 
<span class="lineNum">    3642 </span><span class="lineNoCov">          0 :     if (PQgetisnull(pgresult, 0, 0)) {</span>
<span class="lineNum">    3643 </span><span class="lineNoCov">          0 :         msSetError(MS_MISCERR, &quot;msPostGISLayerGetNumFeatures: Null result returned.&quot;,</span>
<span class="lineNum">    3644 </span>            :             &quot;msPostGISLayerGetNumFeatures()&quot;);
<span class="lineNum">    3645 </span><span class="lineNoCov">          0 :         PQclear(pgresult);</span>
<span class="lineNum">    3646 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">    3647 </span>            :     }
<span class="lineNum">    3648 </span>            : 
<span class="lineNum">    3649 </span><span class="lineNoCov">          0 :     tmp = PQgetvalue(pgresult, 0, 0);</span>
<span class="lineNum">    3650 </span><span class="lineNoCov">          0 :     if (tmp) {</span>
<span class="lineNum">    3651 </span><span class="lineNoCov">          0 :         result = strtol(tmp, NULL, 10);</span>
<span class="lineNum">    3652 </span>            :     }
<span class="lineNum">    3653 </span>            :     else {
<span class="lineNum">    3654 </span>            :         result = 0;
<span class="lineNum">    3655 </span>            :     }
<span class="lineNum">    3656 </span>            : 
<span class="lineNum">    3657 </span>            :     /* cleanup */
<span class="lineNum">    3658 </span><span class="lineNoCov">          0 :     PQclear(pgresult);</span>
<span class="lineNum">    3659 </span>            : 
<span class="lineNum">    3660 </span><span class="lineNoCov">          0 :     return result;</span>
<span class="lineNum">    3661 </span>            : #else
<span class="lineNum">    3662 </span>            :     msSetError(MS_MISCERR, &quot;PostGIS support is not available.&quot;, &quot;msPostGISLayerGetNumFeatures()&quot;);
<span class="lineNum">    3663 </span>            :     return -1;
<span class="lineNum">    3664 </span>            : #endif
<span class="lineNum">    3665 </span>            : }
<span class="lineNum">    3666 </span>            : 
<span class="lineNum">    3667 </span>            : /*
<span class="lineNum">    3668 </span>            :  * make sure that the timestring is complete and acceptable
<span class="lineNum">    3669 </span>            :  * to the date_trunc function :
<span class="lineNum">    3670 </span>            :  * - if the resolution is year (2004) or month (2004-01),
<span class="lineNum">    3671 </span>            :  * a complete string for time would be 2004-01-01
<span class="lineNum">    3672 </span>            :  * - if the resolluion is hour or minute (2004-01-01 15), a
<a name="3673"><span class="lineNum">    3673 </span>            :  * complete time is 2004-01-01 15:00:00</a>
<span class="lineNum">    3674 </span>            :  */
<span class="lineNum">    3675 </span><span class="lineCov">          1 : int postgresTimeStampForTimeString(const char *timestring, char *dest, size_t destsize)</span>
<span class="lineNum">    3676 </span>            : {
<span class="lineNum">    3677 </span><span class="lineCov">          1 :   int nlength = strlen(timestring);</span>
<span class="lineNum">    3678 </span><span class="lineCov">          1 :   int timeresolution = msTimeGetResolution(timestring);</span>
<span class="lineNum">    3679 </span><span class="lineCov">          1 :   int bNoDate = (*timestring == 'T');</span>
<span class="lineNum">    3680 </span><span class="lineCov">          1 :   if (timeresolution &lt; 0)</span>
<span class="lineNum">    3681 </span>            :     return MS_FALSE;
<span class="lineNum">    3682 </span>            :  
<span class="lineNum">    3683 </span><span class="lineCov">          1 :   switch(timeresolution) {</span>
<span class="lineNum">    3684 </span>            :     case TIME_RESOLUTION_YEAR:
<span class="lineNum">    3685 </span><span class="lineCov">          1 :       if (timestring[nlength-1] != '-') {</span>
<span class="lineNum">    3686 </span>            :         snprintf(dest, destsize,&quot;date '%s-01-01'&quot;,timestring);
<span class="lineNum">    3687 </span>            :       } else {
<span class="lineNum">    3688 </span>            :         snprintf(dest, destsize,&quot;date '%s01-01'&quot;,timestring);
<span class="lineNum">    3689 </span>            :       }
<span class="lineNum">    3690 </span>            :       break;
<span class="lineNum">    3691 </span>            :     case TIME_RESOLUTION_MONTH:
<span class="lineNum">    3692 </span><span class="lineCov">          1 :       if (timestring[nlength-1] != '-') {</span>
<span class="lineNum">    3693 </span>            :         snprintf(dest, destsize,&quot;date '%s-01'&quot;,timestring);
<span class="lineNum">    3694 </span>            :       } else {
<span class="lineNum">    3695 </span>            :         snprintf(dest, destsize,&quot;date '%s01'&quot;,timestring);
<span class="lineNum">    3696 </span>            :       }
<span class="lineNum">    3697 </span>            :       break;
<span class="lineNum">    3698 </span>            :     case TIME_RESOLUTION_DAY:
<span class="lineNum">    3699 </span>            :       snprintf(dest, destsize,&quot;date '%s'&quot;,timestring);
<span class="lineNum">    3700 </span>            :       break;
<span class="lineNum">    3701 </span>            :     case TIME_RESOLUTION_HOUR:
<span class="lineNum">    3702 </span><span class="lineCov">          1 :       if (timestring[nlength-1] != ':') {</span>
<span class="lineNum">    3703 </span><span class="lineCov">          1 :         if(bNoDate)</span>
<span class="lineNum">    3704 </span>            :           snprintf(dest, destsize,&quot;time '%s:00:00'&quot;, timestring);
<span class="lineNum">    3705 </span>            :         else
<span class="lineNum">    3706 </span>            :           snprintf(dest, destsize,&quot;timestamp '%s:00:00'&quot;, timestring);
<span class="lineNum">    3707 </span>            :       } else {
<span class="lineNum">    3708 </span><span class="lineNoCov">          0 :         if(bNoDate)</span>
<span class="lineNum">    3709 </span>            :           snprintf(dest, destsize,&quot;time '%s00:00'&quot;, timestring);
<span class="lineNum">    3710 </span>            :         else
<span class="lineNum">    3711 </span>            :           snprintf(dest, destsize,&quot;timestamp '%s00:00'&quot;, timestring);
<span class="lineNum">    3712 </span>            :       }
<span class="lineNum">    3713 </span>            :       break;
<span class="lineNum">    3714 </span>            :     case TIME_RESOLUTION_MINUTE:
<span class="lineNum">    3715 </span><span class="lineCov">          1 :       if (timestring[nlength-1] != ':') {</span>
<span class="lineNum">    3716 </span><span class="lineCov">          1 :         if(bNoDate)</span>
<span class="lineNum">    3717 </span>            :           snprintf(dest, destsize,&quot;time '%s:00'&quot;, timestring);
<span class="lineNum">    3718 </span>            :         else
<span class="lineNum">    3719 </span>            :           snprintf(dest, destsize,&quot;timestamp '%s:00'&quot;, timestring);
<span class="lineNum">    3720 </span>            :       } else {
<span class="lineNum">    3721 </span><span class="lineNoCov">          0 :         if(bNoDate)</span>
<span class="lineNum">    3722 </span>            :           snprintf(dest, destsize,&quot;time '%s00'&quot;, timestring);
<span class="lineNum">    3723 </span>            :         else
<span class="lineNum">    3724 </span>            :           snprintf(dest, destsize,&quot;timestamp '%s00'&quot;, timestring);
<span class="lineNum">    3725 </span>            :       }
<span class="lineNum">    3726 </span>            :       break;
<span class="lineNum">    3727 </span>            :     case TIME_RESOLUTION_SECOND:
<span class="lineNum">    3728 </span><span class="lineCov">          1 :       if(bNoDate)</span>
<span class="lineNum">    3729 </span>            :          snprintf(dest, destsize,&quot;time '%s'&quot;, timestring);
<span class="lineNum">    3730 </span>            :       else
<span class="lineNum">    3731 </span>            :          snprintf(dest, destsize,&quot;timestamp '%s'&quot;, timestring);
<span class="lineNum">    3732 </span>            :       break;
<span class="lineNum">    3733 </span>            :     default:
<span class="lineNum">    3734 </span>            :       return MS_FAILURE;
<span class="lineNum">    3735 </span>            :   }
<span class="lineNum">    3736 </span>            :   return MS_SUCCESS;
<span class="lineNum">    3737 </span>            : 
<span class="lineNum">    3738 </span>            : }
<span class="lineNum">    3739 </span>            : 
<span class="lineNum">    3740 </span>            : /*
<span class="lineNum">    3741 </span>            :  * create a postgresql where clause for the given timestring, taking into account
<span class="lineNum">    3742 </span>            :  * the resolution (e.g. second, day, month...) of the given timestring
<span class="lineNum">    3743 </span>            :  * we apply the date_trunc function on the given timestring and not on the time
<span class="lineNum">    3744 </span>            :  * column in order for postgres to take advantage of an eventual index on the
<span class="lineNum">    3745 </span>            :  * time column
<span class="lineNum">    3746 </span>            :  *
<span class="lineNum">    3747 </span>            :  * the generated sql is
<span class="lineNum">    3748 </span>            :  *
<span class="lineNum">    3749 </span>            :  * (
<span class="lineNum">    3750 </span>            :  *    timecol &gt;= date_trunc(timestring,resolution)
<span class="lineNum">    3751 </span>            :  *      and
<span class="lineNum">    3752 </span>            :  *    timecol &lt; date_trunc(timestring,resolution) + interval '1 resolution'
<a name="3753"><span class="lineNum">    3753 </span>            :  * )</a>
<span class="lineNum">    3754 </span>            :  */
<span class="lineNum">    3755 </span><span class="lineCov">          1 : int createPostgresTimeCompareEquals(const char *timestring, char *dest, size_t destsize)</span>
<span class="lineNum">    3756 </span>            : {
<span class="lineNum">    3757 </span><span class="lineCov">          1 :   int timeresolution = msTimeGetResolution(timestring);</span>
<span class="lineNum">    3758 </span>            :   char timeStamp[100];
<span class="lineNum">    3759 </span>            :   char *interval;
<span class="lineNum">    3760 </span><span class="lineCov">          1 :   if (timeresolution &lt; 0) return MS_FALSE;</span>
<span class="lineNum">    3761 </span>            : 
<span class="lineNum">    3762 </span><span class="lineCov">          1 :   postgresTimeStampForTimeString(timestring,timeStamp,100);</span>
<span class="lineNum">    3763 </span>            : 
<span class="lineNum">    3764 </span><span class="lineCov">          1 :   switch(timeresolution) {</span>
<span class="lineNum">    3765 </span>            :     case TIME_RESOLUTION_YEAR:
<span class="lineNum">    3766 </span>            :       interval = &quot;year&quot;;
<span class="lineNum">    3767 </span>            :       break;
<span class="lineNum">    3768 </span>            :     case TIME_RESOLUTION_MONTH:
<span class="lineNum">    3769 </span>            :       interval = &quot;month&quot;;
<span class="lineNum">    3770 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3771 </span>            :     case TIME_RESOLUTION_DAY:
<span class="lineNum">    3772 </span>            :       interval = &quot;day&quot;;
<span class="lineNum">    3773 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3774 </span>            :     case TIME_RESOLUTION_HOUR:
<span class="lineNum">    3775 </span>            :       interval = &quot;hour&quot;;
<span class="lineNum">    3776 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3777 </span>            :     case TIME_RESOLUTION_MINUTE:
<span class="lineNum">    3778 </span>            :       interval = &quot;minute&quot;;
<span class="lineNum">    3779 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3780 </span>            :     case TIME_RESOLUTION_SECOND:
<span class="lineNum">    3781 </span>            :       interval = &quot;second&quot;;
<span class="lineNum">    3782 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3783 </span>            :     default:
<span class="lineNum">    3784 </span>            :       return MS_FAILURE;
<span class="lineNum">    3785 </span>            :   }
<span class="lineNum">    3786 </span>            :   snprintf(dest, destsize, &quot; between date_trunc('%s',%s) and date_trunc('%s',%s) + interval '1 %s' - interval '1 second'&quot;, interval, timeStamp, interval, timeStamp, interval);
<span class="lineNum">    3787 </span><span class="lineCov">          1 :   return MS_SUCCESS;</span>
<a name="3788"><span class="lineNum">    3788 </span>            : }</a>
<span class="lineNum">    3789 </span>            : 
<span class="lineNum">    3790 </span><span class="lineCov">          1 : int createPostgresTimeCompareGreaterThan(const char *timestring, char *dest, size_t destsize)</span>
<span class="lineNum">    3791 </span>            : {
<span class="lineNum">    3792 </span><span class="lineCov">          1 :   int timeresolution = msTimeGetResolution(timestring);</span>
<span class="lineNum">    3793 </span>            :   char timestamp[100];
<span class="lineNum">    3794 </span>            :   char *interval;
<span class="lineNum">    3795 </span><span class="lineCov">          1 :   if (timeresolution &lt; 0) return MS_FALSE;</span>
<span class="lineNum">    3796 </span>            :  
<span class="lineNum">    3797 </span><span class="lineCov">          1 :   postgresTimeStampForTimeString(timestring,timestamp,100);</span>
<span class="lineNum">    3798 </span>            : 
<span class="lineNum">    3799 </span><span class="lineCov">          1 :   switch(timeresolution) {</span>
<span class="lineNum">    3800 </span>            :   case TIME_RESOLUTION_YEAR:
<span class="lineNum">    3801 </span>            :     interval = &quot;year&quot;;
<span class="lineNum">    3802 </span>            :     break;
<span class="lineNum">    3803 </span>            :   case TIME_RESOLUTION_MONTH:
<span class="lineNum">    3804 </span>            :     interval = &quot;month&quot;;
<span class="lineNum">    3805 </span><span class="lineCov">          1 :     break;</span>
<span class="lineNum">    3806 </span>            :   case TIME_RESOLUTION_DAY:
<span class="lineNum">    3807 </span>            :     interval = &quot;day&quot;;
<span class="lineNum">    3808 </span><span class="lineCov">          1 :     break;</span>
<span class="lineNum">    3809 </span>            :   case TIME_RESOLUTION_HOUR:
<span class="lineNum">    3810 </span>            :     interval = &quot;hour&quot;;
<span class="lineNum">    3811 </span><span class="lineCov">          1 :     break;</span>
<span class="lineNum">    3812 </span>            :   case TIME_RESOLUTION_MINUTE:
<span class="lineNum">    3813 </span>            :     interval = &quot;minute&quot;;
<span class="lineNum">    3814 </span><span class="lineCov">          1 :     break;</span>
<span class="lineNum">    3815 </span>            :   case TIME_RESOLUTION_SECOND:
<span class="lineNum">    3816 </span>            :     interval = &quot;second&quot;;
<span class="lineNum">    3817 </span><span class="lineCov">          1 :     break;</span>
<span class="lineNum">    3818 </span>            :   default:
<span class="lineNum">    3819 </span>            :     return MS_FAILURE;
<span class="lineNum">    3820 </span>            :   }
<span class="lineNum">    3821 </span>            : 
<span class="lineNum">    3822 </span>            :   snprintf(dest, destsize,&quot;date_trunc('%s',%s)&quot;, interval, timestamp);
<span class="lineNum">    3823 </span><span class="lineCov">          1 :   return MS_SUCCESS;</span>
<span class="lineNum">    3824 </span>            : }
<span class="lineNum">    3825 </span>            : 
<span class="lineNum">    3826 </span>            : /*
<span class="lineNum">    3827 </span>            :  * create a postgresql where clause for the range given by the two input timestring,
<span class="lineNum">    3828 </span>            :  * taking into account the resolution (e.g. second, day, month...) of each of the
<span class="lineNum">    3829 </span>            :  * given timestrings (both timestrings can have different resolutions, although I don't
<span class="lineNum">    3830 </span>            :  * know if that's a valid TIME range
<span class="lineNum">    3831 </span>            :  * we apply the date_trunc function on the given timestrings and not on the time
<span class="lineNum">    3832 </span>            :  * column in order for postgres to take advantage of an eventual index on the
<span class="lineNum">    3833 </span>            :  * time column
<span class="lineNum">    3834 </span>            :  *
<span class="lineNum">    3835 </span>            :  * the generated sql is
<span class="lineNum">    3836 </span>            :  *
<span class="lineNum">    3837 </span>            :  * (
<span class="lineNum">    3838 </span>            :  *    timecol &gt;= date_trunc(mintimestring,minresolution)
<span class="lineNum">    3839 </span>            :  *      and
<span class="lineNum">    3840 </span>            :  *    timecol &lt; date_trunc(maxtimestring,maxresolution) + interval '1 maxresolution'
<a name="3841"><span class="lineNum">    3841 </span>            :  * )</a>
<span class="lineNum">    3842 </span>            :  */
<span class="lineNum">    3843 </span><span class="lineCov">          1 : int createPostgresTimeCompareLessThan(const char *timestring, char *dest, size_t destsize)</span>
<span class="lineNum">    3844 </span>            : {
<span class="lineNum">    3845 </span><span class="lineCov">          1 :   int timeresolution = msTimeGetResolution(timestring);</span>
<span class="lineNum">    3846 </span>            :   char timestamp[100];
<span class="lineNum">    3847 </span>            :   char *interval;
<span class="lineNum">    3848 </span><span class="lineCov">          1 :   if (timeresolution &lt; 0)return MS_FALSE;</span>
<span class="lineNum">    3849 </span>            : 
<span class="lineNum">    3850 </span><span class="lineCov">          1 :   postgresTimeStampForTimeString(timestring,timestamp,100);</span>
<span class="lineNum">    3851 </span>            : 
<span class="lineNum">    3852 </span><span class="lineCov">          1 :   switch(timeresolution) {</span>
<span class="lineNum">    3853 </span>            :     case TIME_RESOLUTION_YEAR:
<span class="lineNum">    3854 </span>            :       interval = &quot;year&quot;;
<span class="lineNum">    3855 </span>            :       break;
<span class="lineNum">    3856 </span>            :     case TIME_RESOLUTION_MONTH:
<span class="lineNum">    3857 </span>            :       interval = &quot;month&quot;;
<span class="lineNum">    3858 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3859 </span>            :     case TIME_RESOLUTION_DAY:
<span class="lineNum">    3860 </span>            :       interval = &quot;day&quot;;
<span class="lineNum">    3861 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3862 </span>            :     case TIME_RESOLUTION_HOUR:
<span class="lineNum">    3863 </span>            :       interval = &quot;hour&quot;;
<span class="lineNum">    3864 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3865 </span>            :     case TIME_RESOLUTION_MINUTE:
<span class="lineNum">    3866 </span>            :       interval = &quot;minute&quot;;
<span class="lineNum">    3867 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3868 </span>            :     case TIME_RESOLUTION_SECOND:
<span class="lineNum">    3869 </span>            :       interval = &quot;second&quot;;
<span class="lineNum">    3870 </span><span class="lineCov">          1 :       break;</span>
<span class="lineNum">    3871 </span>            :     default:
<span class="lineNum">    3872 </span>            :       return MS_FAILURE;
<span class="lineNum">    3873 </span>            :   }
<span class="lineNum">    3874 </span>            :   snprintf(dest, destsize,&quot;(date_trunc('%s',%s) + interval '1 %s' - interval '1 second')&quot;, interval, timestamp, interval);
<span class="lineNum">    3875 </span><span class="lineCov">          1 :   return MS_SUCCESS;</span>
<a name="3876"><span class="lineNum">    3876 </span>            : }</a>
<span class="lineNum">    3877 </span>            : 
<span class="lineNum">    3878 </span><span class="lineCov">          1 : char *msPostGISEscapeSQLParam(layerObj *layer, const char *pszString)</span>
<span class="lineNum">    3879 </span>            : {
<span class="lineNum">    3880 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    3881 </span>            :   msPostGISLayerInfo *layerinfo = NULL;
<span class="lineNum">    3882 </span>            :   int nError;
<span class="lineNum">    3883 </span>            :   size_t nSrcLen;
<span class="lineNum">    3884 </span>            :   char* pszEscapedStr =NULL;
<span class="lineNum">    3885 </span>            : 
<span class="lineNum">    3886 </span><span class="lineCov">          1 :   if (layer &amp;&amp; pszString) {</span>
<span class="lineNum">    3887 </span><span class="lineCov">          1 :     if(!msPostGISLayerIsOpen(layer))</span>
<span class="lineNum">    3888 </span><span class="lineNoCov">          0 :       msPostGISLayerOpen(layer);</span>
<span class="lineNum">    3889 </span>            : 
<span class="lineNum">    3890 </span>            :     assert(layer-&gt;layerinfo != NULL);
<span class="lineNum">    3891 </span>            : 
<span class="lineNum">    3892 </span><span class="lineCov">          1 :     layerinfo = (msPostGISLayerInfo *) layer-&gt;layerinfo;</span>
<span class="lineNum">    3893 </span><span class="lineCov">          1 :     nSrcLen = strlen(pszString);</span>
<span class="lineNum">    3894 </span><span class="lineCov">          1 :     pszEscapedStr = (char*) msSmallMalloc( 2 * nSrcLen + 1);</span>
<span class="lineNum">    3895 </span><span class="lineCov">          1 :     PQescapeStringConn (layerinfo-&gt;pgconn, pszEscapedStr, pszString, nSrcLen, &amp;nError);</span>
<span class="lineNum">    3896 </span><span class="lineCov">          1 :     if (nError != 0) {</span>
<span class="lineNum">    3897 </span><span class="lineNoCov">          0 :       free(pszEscapedStr);</span>
<span class="lineNum">    3898 </span>            :       pszEscapedStr = NULL;
<span class="lineNum">    3899 </span>            :     }
<span class="lineNum">    3900 </span>            :   }
<span class="lineNum">    3901 </span><span class="lineCov">          1 :   return pszEscapedStr;</span>
<span class="lineNum">    3902 </span>            : #else
<span class="lineNum">    3903 </span>            :   msSetError( MS_MISCERR,
<span class="lineNum">    3904 </span>            :               &quot;PostGIS support is not available.&quot;,
<span class="lineNum">    3905 </span>            :               &quot;msPostGISEscapeSQLParam()&quot;);
<span class="lineNum">    3906 </span>            :   return NULL;
<span class="lineNum">    3907 </span>            : #endif
<a name="3908"><span class="lineNum">    3908 </span>            : }</a>
<span class="lineNum">    3909 </span>            : 
<span class="lineNum">    3910 </span><span class="lineCov">          1 : void msPostGISEnablePaging(layerObj *layer, int value)</span>
<span class="lineNum">    3911 </span>            : {
<span class="lineNum">    3912 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    3913 </span>            :   msPostGISLayerInfo *layerinfo = NULL;
<span class="lineNum">    3914 </span>            : 
<span class="lineNum">    3915 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    3916 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISEnablePaging called.\n&quot;);</span>
<span class="lineNum">    3917 </span>            :   }
<span class="lineNum">    3918 </span>            : 
<span class="lineNum">    3919 </span><span class="lineCov">          1 :   if(!msPostGISLayerIsOpen(layer))</span>
<span class="lineNum">    3920 </span><span class="lineNoCov">          0 :     msPostGISLayerOpen(layer);</span>
<span class="lineNum">    3921 </span>            : 
<span class="lineNum">    3922 </span>            :   assert( layer-&gt;layerinfo != NULL);
<span class="lineNum">    3923 </span>            : 
<span class="lineNum">    3924 </span><span class="lineCov">          1 :   layerinfo = (msPostGISLayerInfo *)layer-&gt;layerinfo;</span>
<span class="lineNum">    3925 </span><span class="lineCov">          1 :   layerinfo-&gt;paging = value;</span>
<span class="lineNum">    3926 </span>            : 
<span class="lineNum">    3927 </span>            : #else
<span class="lineNum">    3928 </span>            :   msSetError( MS_MISCERR,
<span class="lineNum">    3929 </span>            :               &quot;PostGIS support is not available.&quot;,
<span class="lineNum">    3930 </span>            :               &quot;msPostGISEnablePaging()&quot;);
<span class="lineNum">    3931 </span>            : #endif
<span class="lineNum">    3932 </span><span class="lineCov">          1 :   return;</span>
<a name="3933"><span class="lineNum">    3933 </span>            : }</a>
<span class="lineNum">    3934 </span>            : 
<span class="lineNum">    3935 </span><span class="lineCov">          1 : int msPostGISGetPaging(layerObj *layer)</span>
<span class="lineNum">    3936 </span>            : {
<span class="lineNum">    3937 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    3938 </span>            :   msPostGISLayerInfo *layerinfo = NULL;
<span class="lineNum">    3939 </span>            : 
<span class="lineNum">    3940 </span><span class="lineCov">          1 :   if (layer-&gt;debug) {</span>
<span class="lineNum">    3941 </span><span class="lineNoCov">          0 :     msDebug(&quot;msPostGISGetPaging called.\n&quot;);</span>
<span class="lineNum">    3942 </span>            :   }
<span class="lineNum">    3943 </span>            : 
<span class="lineNum">    3944 </span><span class="lineCov">          1 :   if(!msPostGISLayerIsOpen(layer))</span>
<span class="lineNum">    3945 </span>            :     return MS_TRUE;
<span class="lineNum">    3946 </span>            : 
<span class="lineNum">    3947 </span>            :   assert( layer-&gt;layerinfo != NULL);
<span class="lineNum">    3948 </span>            : 
<span class="lineNum">    3949 </span><span class="lineCov">          1 :   layerinfo = (msPostGISLayerInfo *)layer-&gt;layerinfo;</span>
<span class="lineNum">    3950 </span><span class="lineCov">          1 :   return layerinfo-&gt;paging;</span>
<span class="lineNum">    3951 </span>            : #else
<span class="lineNum">    3952 </span>            :   msSetError( MS_MISCERR,
<span class="lineNum">    3953 </span>            :               &quot;PostGIS support is not available.&quot;,
<span class="lineNum">    3954 </span>            :               &quot;msPostGISEnablePaging()&quot;);
<span class="lineNum">    3955 </span>            :   return MS_FAILURE;
<span class="lineNum">    3956 </span>            : #endif
<span class="lineNum">    3957 </span>            : }
<span class="lineNum">    3958 </span>            : 
<span class="lineNum">    3959 </span>            : /*
<a name="3960"><span class="lineNum">    3960 </span>            : ** Look ahead to find the next node of a specific type.</a>
<span class="lineNum">    3961 </span>            : */
<span class="lineNum">    3962 </span><span class="lineNoCov">          0 : tokenListNodeObjPtr findNextTokenByType(tokenListNodeObjPtr node, int type) {</span>
<span class="lineNum">    3963 </span><span class="lineNoCov">          0 :   while (node != NULL) {</span>
<span class="lineNum">    3964 </span><span class="lineNoCov">          0 :     if(node-&gt;token == type) return node;</span>
<span class="lineNum">    3965 </span><span class="lineNoCov">          0 :     node = node-&gt;next; /* keep looking */</span>
<span class="lineNum">    3966 </span>            :   }
<span class="lineNum">    3967 </span>            : 
<span class="lineNum">    3968 </span>            :   return NULL; /* not found */
<span class="lineNum">    3969 </span>            : }
<span class="lineNum">    3970 </span>            : 
<span class="lineNum">    3971 </span>            : /*
<span class="lineNum">    3972 </span>            : ** msPostGISLayerTranslateFilter()
<span class="lineNum">    3973 </span>            : **
<a name="3974"><span class="lineNum">    3974 </span>            : ** Registered vtable-&gt;LayerTranslateFilter function.</a>
<span class="lineNum">    3975 </span>            : */
<span class="lineNum">    3976 </span><span class="lineCov">          1 : int msPostGISLayerTranslateFilter(layerObj *layer, expressionObj *filter, char *filteritem)</span>
<span class="lineNum">    3977 </span>            : {
<span class="lineNum">    3978 </span>            : #ifdef USE_POSTGIS
<span class="lineNum">    3979 </span>            :   tokenListNodeObjPtr node = NULL;
<span class="lineNum">    3980 </span>            : 
<span class="lineNum">    3981 </span>            :   char *snippet = NULL;
<span class="lineNum">    3982 </span>            :   char *native_string = NULL;
<span class="lineNum">    3983 </span>            :   char *strtmpl = NULL;
<span class="lineNum">    3984 </span>            :   char *stresc = NULL;
<span class="lineNum">    3985 </span>            : 
<span class="lineNum">    3986 </span>            :   int comparisonToken = -1;
<span class="lineNum">    3987 </span>            :   int bindingToken = -1;
<span class="lineNum">    3988 </span>            : 
<span class="lineNum">    3989 </span><span class="lineCov">          1 :   msPostGISLayerInfo *layerinfo = layer-&gt;layerinfo;</span>
<span class="lineNum">    3990 </span>            : 
<span class="lineNum">    3991 </span><span class="lineCov">          1 :   if(!filter-&gt;string) return MS_SUCCESS; /* not an error, just nothing to do */</span>
<span class="lineNum">    3992 </span>            : 
<span class="lineNum">    3993 </span>            :   // fprintf(stderr, &quot;input: %s, %s, %d\n&quot;, filter-&gt;string, filteritem, filter-&gt;type);
<span class="lineNum">    3994 </span>            : 
<span class="lineNum">    3995 </span>            :   /*
<span class="lineNum">    3996 </span>            :   ** FILTERs use MapServer syntax *only* (#5001).
<span class="lineNum">    3997 </span>            :   */
<span class="lineNum">    3998 </span><span class="lineCov">          1 :   if(filter-&gt;type == MS_STRING &amp;&amp; filter-&gt;string &amp;&amp; filteritem) { /* item/value pair - add escaping */</span>
<span class="lineNum">    3999 </span>            : 
<span class="lineNum">    4000 </span><span class="lineCov">          1 :     stresc = msLayerEscapePropertyName(layer, filteritem);</span>
<span class="lineNum">    4001 </span><span class="lineCov">          1 :     if(filter-&gt;flags &amp; MS_EXP_INSENSITIVE) {</span>
<span class="lineNum">    4002 </span><span class="lineCov">          1 :       native_string = msStringConcatenate(native_string, &quot;upper(&quot;);</span>
<span class="lineNum">    4003 </span><span class="lineCov">          1 :       native_string = msStringConcatenate(native_string, stresc);</span>
<span class="lineNum">    4004 </span><span class="lineCov">          1 :       native_string = msStringConcatenate(native_string, &quot;::text) = upper(&quot;);</span>
<span class="lineNum">    4005 </span>            :     } else {
<span class="lineNum">    4006 </span><span class="lineCov">          1 :       native_string = msStringConcatenate(native_string, stresc);</span>
<span class="lineNum">    4007 </span><span class="lineCov">          1 :       native_string = msStringConcatenate(native_string, &quot;::text = &quot;);</span>
<span class="lineNum">    4008 </span>            :     }
<span class="lineNum">    4009 </span><span class="lineCov">          1 :     msFree(stresc);</span>
<span class="lineNum">    4010 </span>            : 
<span class="lineNum">    4011 </span>            :     strtmpl = &quot;'%s'&quot;;  /* don't have a type for the righthand literal so assume it's a string and we quote */
<span class="lineNum">    4012 </span><span class="lineCov">          1 :     stresc = msPostGISEscapeSQLParam(layer, filter-&gt;string);    </span>
<span class="lineNum">    4013 </span><span class="lineCov">          1 :     snippet = (char *) msSmallMalloc(strlen(strtmpl) + strlen(stresc));</span>
<span class="lineNum">    4014 </span>            :     sprintf(snippet, strtmpl, stresc);
<span class="lineNum">    4015 </span><span class="lineCov">          1 :     native_string = msStringConcatenate(native_string, snippet);</span>
<span class="lineNum">    4016 </span><span class="lineCov">          1 :     msFree(snippet);</span>
<span class="lineNum">    4017 </span><span class="lineCov">          1 :     msFree(stresc);</span>
<span class="lineNum">    4018 </span>            : 
<span class="lineNum">    4019 </span><span class="lineCov">          1 :     if(filter-&gt;flags &amp; MS_EXP_INSENSITIVE) native_string = msStringConcatenate(native_string, &quot;)&quot;);</span>
<span class="lineNum">    4020 </span><span class="lineCov">          1 :   } else if(filter-&gt;type == MS_REGEX &amp;&amp; filter-&gt;string &amp;&amp; filteritem) { /* item/regex pair  - add escaping */</span>
<span class="lineNum">    4021 </span>            : 
<span class="lineNum">    4022 </span><span class="lineCov">          1 :     stresc = msLayerEscapePropertyName(layer, filteritem);</span>
<span class="lineNum">    4023 </span><span class="lineCov">          1 :     native_string = msStringConcatenate(native_string, stresc);</span>
<span class="lineNum">    4024 </span><span class="lineCov">          1 :     if(filter-&gt;flags &amp; MS_EXP_INSENSITIVE) {</span>
<span class="lineNum">    4025 </span><span class="lineCov">          1 :       native_string = msStringConcatenate(native_string, &quot;::text ~* &quot;);</span>
<span class="lineNum">    4026 </span>            :     } else {
<span class="lineNum">    4027 </span><span class="lineCov">          1 :       native_string = msStringConcatenate(native_string, &quot;::text ~ &quot;);</span>
<span class="lineNum">    4028 </span>            :     }
<span class="lineNum">    4029 </span><span class="lineCov">          1 :     msFree(stresc);</span>
<span class="lineNum">    4030 </span>            : 
<span class="lineNum">    4031 </span>            :     strtmpl = &quot;'%s'&quot;;
<span class="lineNum">    4032 </span><span class="lineCov">          1 :     stresc = msPostGISEscapeSQLParam(layer, filter-&gt;string);</span>
<span class="lineNum">    4033 </span><span class="lineCov">          1 :     snippet = (char *) msSmallMalloc(strlen(strtmpl) + strlen(stresc));</span>
<span class="lineNum">    4034 </span>            :     sprintf(snippet, strtmpl, stresc);
<span class="lineNum">    4035 </span><span class="lineCov">          1 :     native_string = msStringConcatenate(native_string, snippet);</span>
<span class="lineNum">    4036 </span><span class="lineCov">          1 :     msFree(snippet);</span>
<span class="lineNum">    4037 </span><span class="lineCov">          1 :     msFree(stresc);</span>
<span class="lineNum">    4038 </span><span class="lineCov">          1 :   } else if(filter-&gt;type == MS_EXPRESSION) {</span>
<span class="lineNum">    4039 </span><span class="lineCov">          1 :     if(msPostGISParseData(layer) != MS_SUCCESS) return MS_FAILURE;</span>
<span class="lineNum">    4040 </span>            : 
<span class="lineNum">    4041 </span><span class="lineCov">          1 :     if(layer-&gt;debug &gt;= 2) msDebug(&quot;msPostGISLayerTranslateFilter. String: %s.\n&quot;, filter-&gt;string);</span>
<span class="lineNum">    4042 </span><span class="lineCov">          1 :     if(!filter-&gt;tokens) return MS_SUCCESS;</span>
<span class="lineNum">    4043 </span><span class="lineCov">          1 :     if(layer-&gt;debug &gt;= 2) msDebug(&quot;msPostGISLayerTranslateFilter. There are tokens to process... \n&quot;);</span>
<span class="lineNum">    4044 </span>            : 
<span class="lineNum">    4045 </span><span class="lineCov">          1 :     node = filter-&gt;tokens;</span>
<span class="lineNum">    4046 </span><span class="lineCov">          1 :     while (node != NULL) {</span>
<span class="lineNum">    4047 </span>            : 
<span class="lineNum">    4048 </span>            :       /*
<span class="lineNum">    4049 </span>            :       ** Do any token caching/tracking here, easier to have it in one place.
<span class="lineNum">    4050 </span>            :       */
<span class="lineNum">    4051 </span><span class="lineCov">          1 :       if(node-&gt;token == MS_TOKEN_BINDING_TIME) {</span>
<span class="lineNum">    4052 </span>            :         bindingToken = node-&gt;token;
<span class="lineNum">    4053 </span><span class="lineCov">          1 :       } else if(node-&gt;token == MS_TOKEN_COMPARISON_EQ || node-&gt;token == MS_TOKEN_COMPARISON_NE ||</span>
<span class="lineNum">    4054 </span><span class="lineCov">          1 :          node-&gt;token == MS_TOKEN_COMPARISON_GT || node-&gt;token == MS_TOKEN_COMPARISON_GE ||</span>
<span class="lineNum">    4055 </span><span class="lineCov">          1 :          node-&gt;token == MS_TOKEN_COMPARISON_LT || node-&gt;token == MS_TOKEN_COMPARISON_LE ||</span>
<span class="lineNum">    4056 </span>            :          node-&gt;token == MS_TOKEN_COMPARISON_IN) {
<span class="lineNum">    4057 </span>            :         comparisonToken = node-&gt;token;
<span class="lineNum">    4058 </span>            :       }
<span class="lineNum">    4059 </span>            : 
<span class="lineNum">    4060 </span><span class="lineCov">          1 :       switch(node-&gt;token) {</span>
<span class="lineNum">    4061 </span>            : 
<span class="lineNum">    4062 </span>            :         /* literal tokens */
<span class="lineNum">    4063 </span>            :         case MS_TOKEN_LITERAL_BOOLEAN:
<span class="lineNum">    4064 </span><span class="lineCov">          1 :           if(node-&gt;tokenval.dblval == MS_TRUE)</span>
<span class="lineNum">    4065 </span><span class="lineCov">          1 :             native_string = msStringConcatenate(native_string, &quot;TRUE&quot;);</span>
<span class="lineNum">    4066 </span>            :           else
<span class="lineNum">    4067 </span><span class="lineNoCov">          0 :             native_string = msStringConcatenate(native_string, &quot;FALSE&quot;);</span>
<span class="lineNum">    4068 </span>            :           break;
<span class="lineNum">    4069 </span>            :         case MS_TOKEN_LITERAL_NUMBER:
<span class="lineNum">    4070 </span><span class="lineCov">          1 :           snippet = (char *) msSmallMalloc(32);</span>
<span class="lineNum">    4071 </span><span class="lineCov">          1 :           if( node-&gt;tokenval.dblval &gt;= INT_MIN &amp;&amp;</span>
<span class="lineNum">    4072 </span><span class="lineCov">          1 :               node-&gt;tokenval.dblval &lt;= INT_MAX &amp;&amp;</span>
<span class="lineNum">    4073 </span><span class="lineCov">          1 :               node-&gt;tokenval.dblval == (int)node-&gt;tokenval.dblval )</span>
<span class="lineNum">    4074 </span>            :               sprintf(snippet, &quot;%d&quot;, (int)node-&gt;tokenval.dblval);
<span class="lineNum">    4075 </span>            :           else
<span class="lineNum">    4076 </span>            :               sprintf(snippet, &quot;%.18g&quot;, node-&gt;tokenval.dblval);
<span class="lineNum">    4077 </span><span class="lineCov">          1 :           native_string = msStringConcatenate(native_string, snippet);</span>
<span class="lineNum">    4078 </span><span class="lineCov">          1 :           msFree(snippet);</span>
<span class="lineNum">    4079 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">    4080 </span>            :         case MS_TOKEN_LITERAL_STRING:
<span class="lineNum">    4081 </span>            : 
<span class="lineNum">    4082 </span><span class="lineCov">          1 :           if(comparisonToken == MS_TOKEN_COMPARISON_IN) { /* issue 5490 */</span>
<span class="lineNum">    4083 </span>            :             char **strings=NULL;
<span class="lineNum">    4084 </span><span class="lineCov">          1 :             int i, nstrings=0;</span>
<span class="lineNum">    4085 </span>            : 
<span class="lineNum">    4086 </span><span class="lineCov">          1 :       strings = msStringSplit(node-&gt;tokenval.strval, ',', &amp;nstrings);</span>
<span class="lineNum">    4087 </span><span class="lineCov">          1 :             if(nstrings &gt; 0) {</span>
<span class="lineNum">    4088 </span><span class="lineCov">          1 :         native_string = msStringConcatenate(native_string, &quot;(&quot;);</span>
<span class="lineNum">    4089 </span><span class="lineCov">          1 :               for(i=0; i&lt;nstrings; i++) {</span>
<span class="lineNum">    4090 </span><span class="lineCov">          1 :                 if(i != 0) native_string = msStringConcatenate(native_string, &quot;,&quot;);</span>
<span class="lineNum">    4091 </span>            :                 strtmpl = &quot;'%s'&quot;;
<span class="lineNum">    4092 </span><span class="lineCov">          1 :     stresc = msPostGISEscapeSQLParam(layer, strings[i]);</span>
<span class="lineNum">    4093 </span><span class="lineCov">          1 :     snippet = (char *) msSmallMalloc(strlen(strtmpl) + strlen(stresc));</span>
<span class="lineNum">    4094 </span>            :     sprintf(snippet, strtmpl, stresc);
<span class="lineNum">    4095 </span><span class="lineCov">          1 :     native_string = msStringConcatenate(native_string, snippet);</span>
<span class="lineNum">    4096 </span><span class="lineCov">          1 :     msFree(snippet);</span>
<span class="lineNum">    4097 </span><span class="lineCov">          1 :     msFree(stresc);</span>
<span class="lineNum">    4098 </span>            :               }
<span class="lineNum">    4099 </span><span class="lineCov">          1 :               native_string = msStringConcatenate(native_string, &quot;)&quot;);</span>
<span class="lineNum">    4100 </span>            :             }
<span class="lineNum">    4101 </span>            : 
<span class="lineNum">    4102 </span><span class="lineCov">          1 :             msFreeCharArray(strings, nstrings);</span>
<span class="lineNum">    4103 </span>            :           } else {
<span class="lineNum">    4104 </span>            :             strtmpl = &quot;'%s'&quot;;
<span class="lineNum">    4105 </span><span class="lineCov">          1 :             stresc = msPostGISEscapeSQLParam(layer, node-&gt;tokenval.strval);</span>
<span class="lineNum">    4106 </span><span class="lineCov">          1 :             snippet = (char *) msSmallMalloc(strlen(strtmpl) + strlen(stresc));</span>
<span class="lineNum">    4107 </span>            :             sprintf(snippet, strtmpl, stresc);
<span class="lineNum">    4108 </span><span class="lineCov">          1 :             native_string = msStringConcatenate(native_string, snippet);</span>
<span class="lineNum">    4109 </span><span class="lineCov">          1 :             msFree(snippet);</span>
<span class="lineNum">    4110 </span><span class="lineCov">          1 :             msFree(stresc);</span>
<span class="lineNum">    4111 </span>            :           }
<span class="lineNum">    4112 </span>            : 
<span class="lineNum">    4113 </span>            :           break;
<span class="lineNum">    4114 </span>            :         case MS_TOKEN_LITERAL_TIME: {
<span class="lineNum">    4115 </span><span class="lineCov">          1 :     snippet = (char *) msSmallMalloc(512);</span>
<span class="lineNum">    4116 </span>            : 
<span class="lineNum">    4117 </span><span class="lineCov">          1 :           if(comparisonToken == MS_TOKEN_COMPARISON_EQ) { // TODO: support !=</span>
<span class="lineNum">    4118 </span><span class="lineCov">          1 :             createPostgresTimeCompareEquals(node-&gt;tokensrc, snippet, 512);</span>
<span class="lineNum">    4119 </span><span class="lineCov">          1 :           } else if(comparisonToken == MS_TOKEN_COMPARISON_GT || comparisonToken == MS_TOKEN_COMPARISON_GE) {</span>
<span class="lineNum">    4120 </span><span class="lineCov">          1 :             createPostgresTimeCompareGreaterThan(node-&gt;tokensrc, snippet, 512);</span>
<span class="lineNum">    4121 </span><span class="lineCov">          1 :           } else if(comparisonToken == MS_TOKEN_COMPARISON_LT || comparisonToken == MS_TOKEN_COMPARISON_LE) {</span>
<span class="lineNum">    4122 </span><span class="lineCov">          1 :             createPostgresTimeCompareLessThan(node-&gt;tokensrc, snippet, 512);</span>
<span class="lineNum">    4123 </span>            :           } else {
<span class="lineNum">    4124 </span>            :             goto cleanup;
<span class="lineNum">    4125 </span>            :           }
<span class="lineNum">    4126 </span>            : 
<span class="lineNum">    4127 </span>            :           comparisonToken = -1; bindingToken = -1; /* reset */
<span class="lineNum">    4128 </span><span class="lineCov">          1 :           native_string = msStringConcatenate(native_string, snippet);</span>
<span class="lineNum">    4129 </span><span class="lineCov">          1 :           msFree(snippet);</span>
<span class="lineNum">    4130 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">    4131 </span>            :     }
<span class="lineNum">    4132 </span>            :         case MS_TOKEN_LITERAL_SHAPE:
<span class="lineNum">    4133 </span>            :         {
<span class="lineNum">    4134 </span><span class="lineCov">          1 :           char* wkt = msShapeToWKT(node-&gt;tokenval.shpval);</span>
<span class="lineNum">    4135 </span><span class="lineCov">          1 :           native_string = msStringConcatenate(native_string, &quot;ST_GeomFromText('&quot;);</span>
<span class="lineNum">    4136 </span><span class="lineCov">          1 :           native_string = msStringConcatenate(native_string, wkt);</span>
<span class="lineNum">    4137 </span><span class="lineCov">          1 :           msFree(wkt);</span>
<span class="lineNum">    4138 </span><span class="lineCov">          1 :           native_string = msStringConcatenate(native_string, &quot;'&quot;);</span>
<span class="lineNum">    4139 </span><span class="lineCov">          1 :           if(layerinfo-&gt;srid &amp;&amp; strcmp(layerinfo-&gt;srid, &quot;&quot;) != 0) {</span>
<span class="lineNum">    4140 </span><span class="lineCov">          1 :             native_string = msStringConcatenate(native_string, &quot;,&quot;);</span>
<span class="lineNum">    4141 </span><span class="lineCov">          1 :             native_string = msStringConcatenate(native_string, layerinfo-&gt;srid);</span>
<span class="lineNum">    4142 </span>            :           }
<span class="lineNum">    4143 </span><span class="lineCov">          1 :           native_string = msStringConcatenate(native_string, &quot;)&quot;);</span>
<span class="lineNum">    4144 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">    4145 </span>            :         }
<span class="lineNum">    4146 </span>            : 
<span class="lineNum">    4147 </span>            :   /* data binding tokens */
<span class="lineNum">    4148 </span>            :         case MS_TOKEN_BINDING_TIME:
<span class="lineNum">    4149 </span>            :         case MS_TOKEN_BINDING_DOUBLE:
<span class="lineNum">    4150 </span>            :         case MS_TOKEN_BINDING_INTEGER:
<span class="lineNum">    4151 </span>            :         case MS_TOKEN_BINDING_STRING:
<span class="lineNum">    4152 </span><span class="lineCov">          1 :           if(node-&gt;token == MS_TOKEN_BINDING_STRING || node-&gt;next-&gt;token == MS_TOKEN_COMPARISON_RE || node-&gt;next-&gt;token == MS_TOKEN_COMPARISON_IRE)</span>
<span class="lineNum">    4153 </span>            :             strtmpl = &quot;%s::text&quot;; /* explicit cast necessary for certain operators */
<span class="lineNum">    4154 </span>            :           else
<span class="lineNum">    4155 </span>            :             strtmpl = &quot;%s&quot;;
<span class="lineNum">    4156 </span><span class="lineCov">          1 :           stresc = msLayerEscapePropertyName(layer, node-&gt;tokenval.bindval.item);</span>
<span class="lineNum">    4157 </span><span class="lineCov">          1 :           snippet = (char *) msSmallMalloc(strlen(strtmpl) + strlen(stresc));</span>
<span class="lineNum">    4158 </span>            :           sprintf(snippet, strtmpl, stresc);
<span class="lineNum">    4159 </span><span class="lineCov">          1 :           native_string = msStringConcatenate(native_string, snippet);</span>
<span class="lineNum">    4160 </span><span class="lineCov">          1 :           msFree(snippet);</span>
<span class="lineNum">    4161 </span><span class="lineCov">          1 :           msFree(stresc);       </span>
<span class="lineNum">    4162 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">    4163 </span>            :         case MS_TOKEN_BINDING_SHAPE:
<span class="lineNum">    4164 </span><span class="lineCov">          1 :           native_string = msStringConcatenate(native_string, layerinfo-&gt;geomcolumn);</span>
<span class="lineNum">    4165 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">    4166 </span>            :         case MS_TOKEN_BINDING_MAP_CELLSIZE:
<span class="lineNum">    4167 </span>            :           strtmpl = &quot;%lf&quot;;
<span class="lineNum">    4168 </span><span class="lineNoCov">          0 :           snippet = (char *) msSmallMalloc(strlen(strtmpl) + 16);</span>
<span class="lineNum">    4169 </span><span class="lineNoCov">          0 :           sprintf(snippet, strtmpl, layer-&gt;map-&gt;cellsize);</span>
<span class="lineNum">    4170 </span><span class="lineNoCov">          0 :           native_string = msStringConcatenate(native_string, snippet);</span>
<span class="lineNum">    4171 </span><span class="lineNoCov">          0 :           msFree(snippet);</span>
<span class="lineNum">    4172 </span><span class="lineNoCov">          0 :     break;</span>
<span class="lineNum">    4173 </span>            : 
<span class="lineNum">    4174 </span>            :   /* spatial comparison tokens */
<span class="lineNum">    4175 </span>            :         case MS_TOKEN_COMPARISON_INTERSECTS:
<span class="lineNum">    4176 </span>            :         case MS_TOKEN_COMPARISON_DISJOINT:
<span class="lineNum">    4177 </span>            :         case MS_TOKEN_COMPARISON_TOUCHES:
<span class="lineNum">    4178 </span>            :         case MS_TOKEN_COMPARISON_OVERLAPS:
<span class="lineNum">    4179 </span>            :         case MS_TOKEN_COMPARISON_CROSSES:
<span class="lineNum">    4180 </span>            :         case MS_TOKEN_COMPARISON_WITHIN:
<span class="lineNum">    4181 </span>            :         case MS_TOKEN_COMPARISON_CONTAINS:
<span class="lineNum">    4182 </span>            :         case MS_TOKEN_COMPARISON_EQUALS:
<span class="lineNum">    4183 </span>            :         case MS_TOKEN_COMPARISON_DWITHIN:
<span class="lineNum">    4184 </span><span class="lineCov">          1 :           if(node-&gt;next-&gt;token != '(') goto cleanup;</span>
<span class="lineNum">    4185 </span><span class="lineCov">          1 :           native_string = msStringConcatenate(native_string, &quot;st_&quot;);</span>
<span class="lineNum">    4186 </span><span class="lineCov">          1 :           native_string = msStringConcatenate(native_string, msExpressionTokenToString(node-&gt;token));</span>
<span class="lineNum">    4187 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">    4188 </span>            : 
<span class="lineNum">    4189 </span>            :   /* functions */
<span class="lineNum">    4190 </span>            :         case MS_TOKEN_FUNCTION_LENGTH:
<span class="lineNum">    4191 </span>            :         case MS_TOKEN_FUNCTION_AREA:
<span class="lineNum">    4192 </span>            :         case MS_TOKEN_FUNCTION_BUFFER:
<span class="lineNum">    4193 </span>            :         case MS_TOKEN_FUNCTION_DIFFERENCE:
<span class="lineNum">    4194 </span><span class="lineNoCov">          0 :           native_string = msStringConcatenate(native_string, &quot;st_&quot;);</span>
<span class="lineNum">    4195 </span><span class="lineNoCov">          0 :           native_string = msStringConcatenate(native_string, msExpressionTokenToString(node-&gt;token));</span>
<span class="lineNum">    4196 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    4197 </span>            : 
<span class="lineNum">    4198 </span>            :   /* unsupported tokens */ 
<span class="lineNum">    4199 </span>            :   case MS_TOKEN_COMPARISON_IEQ:
<span class="lineNum">    4200 </span>            :         case MS_TOKEN_COMPARISON_BEYOND:
<span class="lineNum">    4201 </span>            :   case MS_TOKEN_FUNCTION_TOSTRING:
<span class="lineNum">    4202 </span>            :   case MS_TOKEN_FUNCTION_ROUND:
<span class="lineNum">    4203 </span>            :   case MS_TOKEN_FUNCTION_SIMPLIFY:
<span class="lineNum">    4204 </span>            :         case MS_TOKEN_FUNCTION_SIMPLIFYPT:        
<span class="lineNum">    4205 </span>            :         case MS_TOKEN_FUNCTION_GENERALIZE:
<span class="lineNum">    4206 </span>            :           goto cleanup;
<span class="lineNum">    4207 </span>            :           break;
<span class="lineNum">    4208 </span>            : 
<span class="lineNum">    4209 </span>            :         default:
<span class="lineNum">    4210 </span>            :           /* by default accept the general token to string conversion */
<span class="lineNum">    4211 </span>            : 
<span class="lineNum">    4212 </span><span class="lineCov">          1 :           if(node-&gt;token == MS_TOKEN_COMPARISON_EQ &amp;&amp; node-&gt;next != NULL &amp;&amp; node-&gt;next-&gt;token == MS_TOKEN_LITERAL_TIME) break; /* skip, handled with the next token */</span>
<span class="lineNum">    4213 </span><span class="lineCov">          1 :           if(bindingToken == MS_TOKEN_BINDING_TIME &amp;&amp; (node-&gt;token == MS_TOKEN_COMPARISON_EQ || node-&gt;token == MS_TOKEN_COMPARISON_NE)) break; /* skip, handled elsewhere */</span>
<span class="lineNum">    4214 </span><span class="lineCov">          1 :           if(node-&gt;token == MS_TOKEN_COMPARISON_EQ &amp;&amp; node-&gt;next != NULL &amp;&amp; node-&gt;next-&gt;token == MS_TOKEN_LITERAL_STRING &amp;&amp;</span>
<span class="lineNum">    4215 </span><span class="lineCov">          1 :              strcmp(node-&gt;next-&gt;tokenval.strval, &quot;_MAPSERVER_NULL_&quot;) == 0 )</span>
<span class="lineNum">    4216 </span>            :           {
<span class="lineNum">    4217 </span><span class="lineCov">          1 :               native_string = msStringConcatenate(native_string, &quot; IS NULL&quot;);</span>
<span class="lineNum">    4218 </span><span class="lineCov">          1 :               node = node-&gt;next;</span>
<span class="lineNum">    4219 </span><span class="lineCov">          1 :               break;</span>
<span class="lineNum">    4220 </span>            :           }
<span class="lineNum">    4221 </span>            : 
<span class="lineNum">    4222 </span><span class="lineCov">          1 :           native_string = msStringConcatenate(native_string, msExpressionTokenToString(node-&gt;token));</span>
<span class="lineNum">    4223 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">    4224 </span>            :         }
<span class="lineNum">    4225 </span>            : 
<span class="lineNum">    4226 </span><span class="lineCov">          1 :       node = node-&gt;next;</span>
<span class="lineNum">    4227 </span>            :     }
<span class="lineNum">    4228 </span>            :   }
<span class="lineNum">    4229 </span>            : 
<span class="lineNum">    4230 </span><span class="lineCov">          1 :   filter-&gt;native_string = msStrdup(native_string);    </span>
<span class="lineNum">    4231 </span><span class="lineCov">          1 :   msFree(native_string);</span>
<span class="lineNum">    4232 </span>            : 
<span class="lineNum">    4233 </span>            :   // fprintf(stderr, &quot;output: %s\n&quot;, filter-&gt;native_string); 
<span class="lineNum">    4234 </span>            : 
<span class="lineNum">    4235 </span><span class="lineCov">          1 :   return MS_SUCCESS;</span>
<span class="lineNum">    4236 </span>            : 
<span class="lineNum">    4237 </span>            : cleanup:
<span class="lineNum">    4238 </span><span class="lineCov">          1 :   msSetError(MS_MISCERR, &quot;Translation to native SQL failed.&quot;, &quot;msPostGISLayerTranslateFilter()&quot;);</span>
<span class="lineNum">    4239 </span><span class="lineCov">          1 :   msFree(native_string);</span>
<span class="lineNum">    4240 </span><span class="lineCov">          1 :   return MS_FAILURE;</span>
<span class="lineNum">    4241 </span>            : #else
<span class="lineNum">    4242 </span>            :   msSetError(MS_MISCERR, &quot;PostGIS support is not available.&quot;, &quot;msPostGISLayerTranslateFilter()&quot;);
<span class="lineNum">    4243 </span>            :   return MS_FAILURE;
<span class="lineNum">    4244 </span>            : #endif
<a name="4245"><span class="lineNum">    4245 </span>            : }</a>
<span class="lineNum">    4246 </span>            : 
<span class="lineNum">    4247 </span><span class="lineCov">          1 : int msPostGISLayerInitializeVirtualTable(layerObj *layer)</span>
<span class="lineNum">    4248 </span>            : {
<span class="lineNum">    4249 </span>            :   assert(layer != NULL);
<span class="lineNum">    4250 </span>            :   assert(layer-&gt;vtable != NULL);
<span class="lineNum">    4251 </span>            : 
<span class="lineNum">    4252 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerTranslateFilter = msPostGISLayerTranslateFilter;</span>
<span class="lineNum">    4253 </span>            : 
<span class="lineNum">    4254 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerInitItemInfo = msPostGISLayerInitItemInfo;</span>
<span class="lineNum">    4255 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerFreeItemInfo = msPostGISLayerFreeItemInfo;</span>
<span class="lineNum">    4256 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerOpen = msPostGISLayerOpen;</span>
<span class="lineNum">    4257 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerIsOpen = msPostGISLayerIsOpen;</span>
<span class="lineNum">    4258 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerWhichShapes = msPostGISLayerWhichShapes;</span>
<span class="lineNum">    4259 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerNextShape = msPostGISLayerNextShape;</span>
<span class="lineNum">    4260 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerGetShape = msPostGISLayerGetShape;</span>
<span class="lineNum">    4261 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerGetShapeCount = msPostGISLayerGetShapeCount;</span>
<span class="lineNum">    4262 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerClose = msPostGISLayerClose;</span>
<span class="lineNum">    4263 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerGetItems = msPostGISLayerGetItems;</span>
<span class="lineNum">    4264 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerGetExtent = msPostGISLayerGetExtent;</span>
<span class="lineNum">    4265 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerApplyFilterToLayer = msLayerApplyCondSQLFilterToLayer;</span>
<span class="lineNum">    4266 </span>            :   /* layer-&gt;vtable-&gt;LayerGetAutoStyle, not supported for this layer */
<span class="lineNum">    4267 </span>            :   /* layer-&gt;vtable-&gt;LayerCloseConnection = msPostGISLayerClose; */
<span class="lineNum">    4268 </span>            :   // layer-&gt;vtable-&gt;LayerSetTimeFilter = msPostGISLayerSetTimeFilter;
<span class="lineNum">    4269 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerSetTimeFilter = msLayerMakeBackticsTimeFilter;</span>
<span class="lineNum">    4270 </span>            :   /* layer-&gt;vtable-&gt;LayerCreateItems, use default */
<span class="lineNum">    4271 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerGetNumFeatures = msPostGISLayerGetNumFeatures;</span>
<span class="lineNum">    4272 </span>            : 
<span class="lineNum">    4273 </span>            :   /* layer-&gt;vtable-&gt;LayerGetAutoProjection, use defaut*/
<span class="lineNum">    4274 </span>            : 
<span class="lineNum">    4275 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerEscapeSQLParam = msPostGISEscapeSQLParam;</span>
<span class="lineNum">    4276 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerEnablePaging = msPostGISEnablePaging;</span>
<span class="lineNum">    4277 </span><span class="lineCov">          1 :   layer-&gt;vtable-&gt;LayerGetPaging = msPostGISGetPaging;</span>
<span class="lineNum">    4278 </span>            : 
<span class="lineNum">    4279 </span><span class="lineCov">          1 :   return MS_SUCCESS;</span>
<span class="lineNum">    4280 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.10</a></td></tr>
  </table>
  <br>

</body>
</html>

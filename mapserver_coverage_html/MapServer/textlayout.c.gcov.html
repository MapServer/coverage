<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - mapserver.info - MapServer/textlayout.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">MapServer</a> - textlayout.c<span style="font-size: 80%;"> (source / <a href="textlayout.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">mapserver.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">273</td>
            <td class="headerCovTableEntry">349</td>
            <td class="headerCovTableEntryMed">78.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2020-12-07 18:08:37</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntryHi">90.0 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /******************************************************************************</a>
<span class="lineNum">       2 </span>            :  *
<span class="lineNum">       3 </span>            :  * Project:  MapServer
<span class="lineNum">       4 </span>            :  * Purpose:  Text Layout functions, eventually using Harfbuzz and Fribidi/ICU
<span class="lineNum">       5 </span>            :  * Author:   Thomas Bonfort and the MapServer team.
<span class="lineNum">       6 </span>            :  *
<span class="lineNum">       7 </span>            :  ******************************************************************************
<span class="lineNum">       8 </span>            :  * Copyright (c) 1996-2013 Regents of the University of Minnesota.
<span class="lineNum">       9 </span>            :  *
<span class="lineNum">      10 </span>            :  * Permission is hereby granted, free of charge, to any person obtaining a
<span class="lineNum">      11 </span>            :  * copy of this software and associated documentation files (the &quot;Software&quot;),
<span class="lineNum">      12 </span>            :  * to deal in the Software without restriction, including without limitation
<span class="lineNum">      13 </span>            :  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
<span class="lineNum">      14 </span>            :  * and/or sell copies of the Software, and to permit persons to whom the
<span class="lineNum">      15 </span>            :  * Software is furnished to do so, subject to the following conditions:
<span class="lineNum">      16 </span>            :  *
<span class="lineNum">      17 </span>            :  * The above copyright notice and this permission notice shall be included in
<span class="lineNum">      18 </span>            :  * all copies of this Software or works derived from this Software.
<span class="lineNum">      19 </span>            :  *
<span class="lineNum">      20 </span>            :  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
<span class="lineNum">      21 </span>            :  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<span class="lineNum">      22 </span>            :  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
<span class="lineNum">      23 </span>            :  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
<span class="lineNum">      24 </span>            :  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
<span class="lineNum">      25 </span>            :  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
<span class="lineNum">      26 </span>            :  * DEALINGS IN THE SOFTWARE.
<span class="lineNum">      27 </span>            :  *****************************************************************************/
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : #include &lt;float.h&gt;
<span class="lineNum">      31 </span>            : #include &quot;mapserver.h&quot;
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : #ifdef USE_ICONV
<span class="lineNum">      34 </span>            : #include &lt;iconv.h&gt;
<span class="lineNum">      35 </span>            : #include &lt;wchar.h&gt;
<span class="lineNum">      36 </span>            : #endif
<span class="lineNum">      37 </span>            : #include &quot;fontcache.h&quot;
<span class="lineNum">      38 </span>            : #include FT_ADVANCES_H
<span class="lineNum">      39 </span>            : #include FT_TYPES_H
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            : typedef struct{
<span class="lineNum">      42 </span>            :   unsigned int *unicodes;
<span class="lineNum">      43 </span>            :   unsigned int *codepoints;
<span class="lineNum">      44 </span>            : #ifdef USE_FRIBIDI
<span class="lineNum">      45 </span>            :   FriBidiCharType *ctypes;
<span class="lineNum">      46 </span>            :   FriBidiLevel *bidi_levels;
<span class="lineNum">      47 </span>            : #endif
<span class="lineNum">      48 </span>            : #ifdef USE_HARFBUZZ
<span class="lineNum">      49 </span>            :   hb_script_t *scripts;
<span class="lineNum">      50 </span>            : #endif
<span class="lineNum">      51 </span>            : } TextInfo;
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            : typedef struct {
<span class="lineNum">      54 </span>            :   int offset; /* offset in TextInfo entries where the current run is starting */
<span class="lineNum">      55 </span>            :   int length; /* number of unicode glyphs in this run */
<span class="lineNum">      56 </span>            : #ifdef USE_FRIBIDI
<span class="lineNum">      57 </span>            :   FriBidiLevel rtl; /* bidi embedding level of run: -1 to skip shaping, otherwise if pair:ltr, odd:rtl */
<span class="lineNum">      58 </span>            :   hb_script_t script; /* script: latin, arabic, thai, etc... */
<span class="lineNum">      59 </span>            : #endif
<span class="lineNum">      60 </span>            :   int line_number;
<span class="lineNum">      61 </span>            :   face_element *face; /* font face to use for this run */
<span class="lineNum">      62 </span>            : } text_run;
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            : #ifdef USE_HARFBUZZ
<span class="lineNum">      65 </span>            : struct _ms_hb_user_data {
<span class="lineNum">      66 </span>            :   text_run *run;
<span class="lineNum">      67 </span>            :   TextInfo *info;
<span class="lineNum">      68 </span>            :   int glyph_size;
<span class="lineNum">      69 </span>            : };
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : const char *_ms_script_prefix_en = &quot;en:&quot;;
<span class="lineNum">      72 </span>            : const char *_ms_script_prefix_ar = &quot;ar:&quot;;
<span class="lineNum">      73 </span>            : const char *_ms_script_prefix_cn = &quot;cn:&quot;;
<span class="lineNum">      74 </span>            : const char *_ms_script_prefix_hy = &quot;hy:&quot;;
<span class="lineNum">      75 </span>            : const char *_ms_script_prefix_bn = &quot;bn:&quot;;
<span class="lineNum">      76 </span>            : const char *_ms_script_prefix_iu = &quot;iu&quot;;
<span class="lineNum">      77 </span>            : const char *_ms_script_prefix_chr= &quot;chr:&quot;;
<span class="lineNum">      78 </span>            : const char *_ms_script_prefix_cop= &quot;cop:&quot;;
<span class="lineNum">      79 </span>            : const char *_ms_script_prefix_ru = &quot;ru:&quot;;
<span class="lineNum">      80 </span>            : const char *_ms_script_prefix_hi = &quot;hi:&quot;;
<span class="lineNum">      81 </span>            : const char *_ms_script_prefix_ka = &quot;ka:&quot;;
<span class="lineNum">      82 </span>            : const char *_ms_script_prefix_el = &quot;el:&quot;;
<span class="lineNum">      83 </span>            : const char *_ms_script_prefix_gu = &quot;gu:&quot;;
<span class="lineNum">      84 </span>            : const char *_ms_script_prefix_pa = &quot;pa:&quot;;
<span class="lineNum">      85 </span>            : const char *_ms_script_prefix_ko = &quot;ko:&quot;;
<span class="lineNum">      86 </span>            : const char *_ms_script_prefix_he = &quot;he:&quot;;
<span class="lineNum">      87 </span>            : const char *_ms_script_prefix_ja = &quot;ja:&quot;;
<span class="lineNum">      88 </span>            : const char *_ms_script_prefix_kn = &quot;kn:&quot;;
<span class="lineNum">      89 </span>            : const char *_ms_script_prefix_lo = &quot;lo:&quot;;
<span class="lineNum">      90 </span>            : const char *_ms_script_prefix_ml = &quot;ml:&quot;;
<span class="lineNum">      91 </span>            : const char *_ms_script_prefix_mn = &quot;mn:&quot;;
<span class="lineNum">      92 </span>            : const char *_ms_script_prefix_or = &quot;or:&quot;;
<span class="lineNum">      93 </span>            : const char *_ms_script_prefix_syr= &quot;syr:&quot;;
<span class="lineNum">      94 </span>            : const char *_ms_script_prefix_ta = &quot;ta:&quot;;
<span class="lineNum">      95 </span>            : const char *_ms_script_prefix_te = &quot;te:&quot;;
<span class="lineNum">      96 </span>            : const char *_ms_script_prefix_th = &quot;th:&quot;;
<span class="lineNum">      97 </span>            : const char *_ms_script_prefix_bo = &quot;bo:&quot;;
<span class="lineNum">      98 </span>            : const char *_ms_script_prefix_am = &quot;am:&quot;;
<span class="lineNum">      99 </span>            : const char *_ms_script_prefix_km = &quot;km:&quot;;
<span class="lineNum">     100 </span>            : const char *_ms_script_prefix_my = &quot;my:&quot;;
<span class="lineNum">     101 </span>            : const char *_ms_script_prefix_si = &quot;si:&quot;;
<span class="lineNum">     102 </span>            : const char *_ms_script_prefix_dv = &quot;dv:&quot;;
<span class="lineNum">     103 </span>            : const char *_ms_script_prefix_bku= &quot;bku:&quot;;
<span class="lineNum">     104 </span>            : const char *_ms_script_prefix_hnn= &quot;hnn:&quot;;
<span class="lineNum">     105 </span>            : const char *_ms_script_prefix_tl = &quot;tl:&quot;;
<span class="lineNum">     106 </span>            : const char *_ms_script_prefix_tbw= &quot;tbw:&quot;;
<span class="lineNum">     107 </span>            : const char *_ms_script_prefix_uga= &quot;uga:&quot;;
<span class="lineNum">     108 </span>            : const char *_ms_script_prefix_bug= &quot;bug:&quot;;
<span class="lineNum">     109 </span>            : const char *_ms_script_prefix_peo= &quot;peo:&quot;;
<span class="lineNum">     110 </span>            : const char *_ms_script_prefix_syl= &quot;syl:&quot;;
<a name="111"><span class="lineNum">     111 </span>            : const char *_ms_script_prefix_nko= &quot;nko:&quot;;</a>
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span><span class="lineCov">          1 : const char* prefix_from_script(hb_script_t script) {</span>
<span class="lineNum">     114 </span><span class="lineCov">          1 :   switch(script) {</span>
<span class="lineNum">     115 </span><span class="lineCov">          1 :   case HB_SCRIPT_LATIN:               return _ms_script_prefix_en;</span>
<span class="lineNum">     116 </span><span class="lineCov">          1 :   case HB_SCRIPT_ARABIC:              return _ms_script_prefix_ar;</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_HAN:                 return _ms_script_prefix_cn;</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_ARMENIAN:            return _ms_script_prefix_hy;</span>
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_BENGALI:             return _ms_script_prefix_bn;</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_CANADIAN_ABORIGINAL: return _ms_script_prefix_iu;</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_CHEROKEE:            return _ms_script_prefix_chr;</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_COPTIC:              return _ms_script_prefix_cop;</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_CYRILLIC:            return _ms_script_prefix_ru;</span>
<span class="lineNum">     124 </span><span class="lineCov">          1 :   case HB_SCRIPT_DEVANAGARI:          return _ms_script_prefix_hi;</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_GEORGIAN:            return _ms_script_prefix_ka;</span>
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_GREEK:               return _ms_script_prefix_el;</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_GUJARATI:            return _ms_script_prefix_gu;</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_GURMUKHI:            return _ms_script_prefix_pa;</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_HANGUL:              return _ms_script_prefix_ko;</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_HEBREW:              return _ms_script_prefix_he;</span>
<span class="lineNum">     131 </span><span class="lineCov">          1 :   case HB_SCRIPT_HIRAGANA:            return _ms_script_prefix_ja;</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_KANNADA:             return _ms_script_prefix_kn;</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_KATAKANA:            return _ms_script_prefix_ja;</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_LAO:                 return _ms_script_prefix_lo;</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_MALAYALAM:           return _ms_script_prefix_ml;</span>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_MONGOLIAN:           return _ms_script_prefix_mn;</span>
<span class="lineNum">     137 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_ORIYA:               return _ms_script_prefix_or;</span>
<span class="lineNum">     138 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_SYRIAC:              return _ms_script_prefix_syr;</span>
<span class="lineNum">     139 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_TAMIL:               return _ms_script_prefix_ta;</span>
<span class="lineNum">     140 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_TELUGU:              return _ms_script_prefix_te;</span>
<span class="lineNum">     141 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_THAI:                return _ms_script_prefix_th;</span>
<span class="lineNum">     142 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_TIBETAN:             return _ms_script_prefix_bo;</span>
<span class="lineNum">     143 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_ETHIOPIC:            return _ms_script_prefix_am;</span>
<span class="lineNum">     144 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_KHMER:               return _ms_script_prefix_km;</span>
<span class="lineNum">     145 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_MYANMAR:             return _ms_script_prefix_my;</span>
<span class="lineNum">     146 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_SINHALA:             return _ms_script_prefix_si;</span>
<span class="lineNum">     147 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_THAANA:              return _ms_script_prefix_dv;</span>
<span class="lineNum">     148 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_BUHID:               return _ms_script_prefix_bku;</span>
<span class="lineNum">     149 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_HANUNOO:             return _ms_script_prefix_hnn;</span>
<span class="lineNum">     150 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_TAGALOG:             return _ms_script_prefix_tl;</span>
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_TAGBANWA:            return _ms_script_prefix_tbw;</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_UGARITIC:            return _ms_script_prefix_uga;</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_BUGINESE:            return _ms_script_prefix_bug;</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_OLD_PERSIAN:         return _ms_script_prefix_peo;</span>
<span class="lineNum">     155 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_SYLOTI_NAGRI:        return _ms_script_prefix_syl;</span>
<span class="lineNum">     156 </span><span class="lineNoCov">          0 :   case HB_SCRIPT_NKO:                 return _ms_script_prefix_nko;</span>
<span class="lineNum">     157 </span>            :   default:
<span class="lineNum">     158 </span>            :     return NULL;
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            :   }
<span class="lineNum">     161 </span>            : }
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : hb_feature_t hbfeatures[2] = {
<span class="lineNum">     164 </span>            :     {HB_TAG('v','e','r','t'),0,0,INT_MAX},
<span class="lineNum">     165 </span>            :     {HB_TAG('k','e','r','n'),0,0,INT_MAX}
<a name="166"><span class="lineNum">     166 </span>            : };</a>
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span><span class="lineCov">          1 : static hb_bool_t _ms_get_glyph_func (hb_font_t *font, void *font_data,</span>
<span class="lineNum">     169 </span>            :     hb_codepoint_t unicode, hb_codepoint_t variation_selector, hb_codepoint_t *glyph,
<span class="lineNum">     170 </span>            :     void *user_data)
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : {
<span class="lineNum">     173 </span>            :   /* first check our run, as we have probably already computed this */
<span class="lineNum">     174 </span>            :   int i;
<span class="lineNum">     175 </span>            :   struct _ms_hb_user_data *ud = font_data;
<span class="lineNum">     176 </span><span class="lineCov">          1 :   unsigned int *unicodes = ud-&gt;info-&gt;unicodes + ud-&gt;run-&gt;offset;</span>
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span><span class="lineCov">          1 :   for(i=0; i&lt;ud-&gt;run-&gt;length; i++) {</span>
<span class="lineNum">     179 </span><span class="lineCov">          1 :     if(unicodes[i] == unicode) {</span>
<span class="lineNum">     180 </span><span class="lineCov">          1 :       *glyph = *(ud-&gt;info-&gt;codepoints + ud-&gt;run-&gt;offset + i);</span>
<span class="lineNum">     181 </span><span class="lineCov">          1 :       return *glyph != 0;</span>
<span class="lineNum">     182 </span>            :     }
<span class="lineNum">     183 </span>            :   }
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            :   {
<span class="lineNum">     186 </span><span class="lineCov">          1 :     FT_Face ft_face = ud-&gt;run-&gt;face-&gt;face;</span>
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            : #ifdef HAVE_FT_FACE_GETCHARVARIANTINDEX
<span class="lineNum">     189 </span>            :     if ((variation_selector)) {
<span class="lineNum">     190 </span>            :       *glyph = FT_Face_GetCharVariantIndex (ft_face, unicode, variation_selector);
<span class="lineNum">     191 </span>            :       return *glyph != 0;
<span class="lineNum">     192 </span>            :     }
<span class="lineNum">     193 </span>            : #endif
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span><span class="lineCov">          1 :     *glyph = FT_Get_Char_Index (ft_face, unicode);</span>
<span class="lineNum">     196 </span><span class="lineCov">          1 :     return *glyph != 0;</span>
<span class="lineNum">     197 </span>            :   }
<a name="198"><span class="lineNum">     198 </span>            : }</a>
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span><span class="lineCov">          1 : static hb_position_t _ms_get_glyph_h_advance_func (hb_font_t *font, void *font_data,</span>
<span class="lineNum">     201 </span>            :          hb_codepoint_t glyph, void *user_data)
<span class="lineNum">     202 </span>            : {
<span class="lineNum">     203 </span>            :   struct _ms_hb_user_data *ud = font_data;
<span class="lineNum">     204 </span><span class="lineCov">          1 :   glyph_element *glyphc = msGetGlyphByIndex(ud-&gt;run-&gt;face,ud-&gt;glyph_size,glyph);</span>
<span class="lineNum">     205 </span><span class="lineCov">          1 :   if(!glyphc)</span>
<span class="lineNum">     206 </span>            :     return 0;
<span class="lineNum">     207 </span><span class="lineCov">          1 :   return glyphc-&gt;metrics.advance * 64;</span>
<a name="208"><span class="lineNum">     208 </span>            : }</a>
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span><span class="lineNoCov">          0 : static hb_position_t _ms_get_glyph_v_advance_func (hb_font_t *font, void *font_data,</span>
<span class="lineNum">     211 </span>            :     hb_codepoint_t glyph, void *user_data)
<span class="lineNum">     212 </span>            : {
<span class="lineNum">     213 </span><span class="lineNoCov">          0 :   return 0; /* we don't support vertical layouts */</span>
<span class="lineNum">     214 </span>            : }
<a name="215"><span class="lineNum">     215 </span>            : #endif</a>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span><span class="lineCov">          1 : int WARN_UNUSED check_single_font(fontSetObj *fontset, char *fontkey, text_run *run, TextInfo *glyphs, int ignore_missing) {</span>
<span class="lineNum">     218 </span>            :   int i;
<span class="lineNum">     219 </span>            :   face_element *fcache = NULL;
<span class="lineNum">     220 </span><span class="lineCov">          1 :   if(fontset &amp;&amp; fontkey) {</span>
<span class="lineNum">     221 </span><span class="lineCov">          1 :     char *fontkey2 = strchr(fontkey,':'); /* try skipping prefix */</span>
<span class="lineNum">     222 </span><span class="lineCov">          1 :     if(fontkey2) {</span>
<span class="lineNum">     223 </span><span class="lineCov">          1 :       fcache = msGetFontFace(fontkey2+1, fontset);</span>
<span class="lineNum">     224 </span>            :     }
<span class="lineNum">     225 </span>            :   }
<span class="lineNum">     226 </span><span class="lineCov">          1 :   if(!fcache)</span>
<span class="lineNum">     227 </span><span class="lineCov">          1 :     fcache = msGetFontFace(fontkey, fontset);</span>
<span class="lineNum">     228 </span><span class="lineCov">          1 :   run-&gt;face = fcache;</span>
<span class="lineNum">     229 </span><span class="lineCov">          1 :   if(UNLIKELY(!fcache)) return MS_FAILURE;</span>
<span class="lineNum">     230 </span><span class="lineCov">          1 :   for(i=0; i&lt;run-&gt;length; i++) {</span>
<span class="lineNum">     231 </span><span class="lineCov">          1 :     int codepoint = msGetGlyphIndex(fcache, glyphs-&gt;unicodes[run-&gt;offset+i]);</span>
<span class="lineNum">     232 </span><span class="lineCov">          1 :     if(codepoint || ignore_missing)</span>
<span class="lineNum">     233 </span><span class="lineCov">          1 :       glyphs-&gt;codepoints[run-&gt;offset+i] = codepoint;</span>
<span class="lineNum">     234 </span>            :     else
<span class="lineNum">     235 </span>            :       return MS_FAILURE;
<span class="lineNum">     236 </span>            :   }
<span class="lineNum">     237 </span>            :   return MS_SUCCESS;
<a name="238"><span class="lineNum">     238 </span>            : }</a>
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span><span class="lineCov">          1 : int WARN_UNUSED get_face_for_run(fontSetObj *fontset, char *fontlist, text_run *run, TextInfo *glyphs) {</span>
<span class="lineNum">     241 </span>            :   char *startfont, *endfont;
<span class="lineNum">     242 </span>            :   int ok;
<span class="lineNum">     243 </span>            : #if defined(USE_HARFBUZZ) &amp;&amp; defined(USE_FRIBIDI)
<span class="lineNum">     244 </span>            :   const char *prefix = NULL;
<span class="lineNum">     245 </span>            : #endif
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span><span class="lineCov">          1 :   if(!fontset || !fontlist) {</span>
<span class="lineNum">     248 </span><span class="lineCov">          1 :     ok = check_single_font(fontset,fontlist,run,glyphs,0);</span>
<span class="lineNum">     249 </span><span class="lineCov">          1 :     return MS_SUCCESS;</span>
<span class="lineNum">     250 </span>            :   }
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            : #if defined(USE_HARFBUZZ) &amp;&amp; defined(USE_FRIBIDI)
<span class="lineNum">     253 </span><span class="lineCov">          1 :   if(run-&gt;rtl &gt;= 0) {</span>
<span class="lineNum">     254 </span><span class="lineCov">          1 :     prefix = prefix_from_script(run-&gt;script);</span>
<span class="lineNum">     255 </span>            :   } else {
<span class="lineNum">     256 </span><span class="lineCov">          1 :     prefix = _ms_script_prefix_en;</span>
<span class="lineNum">     257 </span>            :   }
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span><span class="lineCov">          1 :   if(prefix) {</span>
<span class="lineNum">     260 </span>            :     /* we'll first look for a font who's prefixed by the current script prefix, e.g, given the
<span class="lineNum">     261 </span>            :      * fontlist &quot;arial,ar:arialuni,cn:cjk&quot; check the &quot;cjk&quot; font first for HAN scripts
<span class="lineNum">     262 </span>            :      */
<span class="lineNum">     263 </span><span class="lineCov">          1 :     int prefixlen = strlen(prefix);</span>
<span class="lineNum">     264 </span>            :     startfont = fontlist;
<span class="lineNum">     265 </span>            :     for(;;) {
<span class="lineNum">     266 </span><span class="lineCov">          1 :       if(!*startfont) break;</span>
<span class="lineNum">     267 </span><span class="lineCov">          1 :       endfont = strchr(startfont,',');</span>
<span class="lineNum">     268 </span><span class="lineCov">          1 :       if(!strncmp(startfont,prefix,prefixlen)) {</span>
<span class="lineNum">     269 </span><span class="lineCov">          1 :         startfont += strlen(prefix);</span>
<span class="lineNum">     270 </span><span class="lineCov">          1 :         if(endfont) *endfont = 0;</span>
<span class="lineNum">     271 </span><span class="lineCov">          1 :         ok = check_single_font(fontset,startfont,run,glyphs,0);</span>
<span class="lineNum">     272 </span><span class="lineCov">          1 :         if(endfont) {</span>
<span class="lineNum">     273 </span><span class="lineCov">          1 :           *endfont = ',';</span>
<span class="lineNum">     274 </span><span class="lineCov">          1 :           if(ok == MS_SUCCESS) return MS_SUCCESS;</span>
<span class="lineNum">     275 </span>            :           startfont = endfont+1; /* go to next font in list */
<span class="lineNum">     276 </span>            :         } else {
<span class="lineNum">     277 </span><span class="lineNoCov">          0 :           if(ok == MS_SUCCESS) return MS_SUCCESS;</span>
<span class="lineNum">     278 </span>            :           break;
<span class="lineNum">     279 </span>            :         }
<span class="lineNum">     280 </span>            :       }
<span class="lineNum">     281 </span><span class="lineCov">          1 :       if(endfont)</span>
<span class="lineNum">     282 </span><span class="lineCov">          1 :        startfont = endfont+1;</span>
<span class="lineNum">     283 </span>            :       else break;
<span class="lineNum">     284 </span>            :     }
<span class="lineNum">     285 </span>            :   }
<span class="lineNum">     286 </span>            : #endif
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :   /* no prefix, or prefix search didn't return satisfying result */
<span class="lineNum">     289 </span>            :   startfont = fontlist;
<span class="lineNum">     290 </span>            :   for(;;) {
<span class="lineNum">     291 </span><span class="lineCov">          1 :     if(!*startfont) break;</span>
<span class="lineNum">     292 </span><span class="lineCov">          1 :     endfont = strchr(startfont,',');</span>
<span class="lineNum">     293 </span><span class="lineCov">          1 :     if(endfont) *endfont = 0;</span>
<span class="lineNum">     294 </span><span class="lineCov">          1 :     ok = check_single_font(fontset,startfont,run,glyphs,!endfont); /* ignore failing glyphs if we're using the last font in the list */</span>
<span class="lineNum">     295 </span><span class="lineCov">          1 :     if(endfont) {</span>
<span class="lineNum">     296 </span><span class="lineCov">          1 :       *endfont = ',';</span>
<span class="lineNum">     297 </span><span class="lineCov">          1 :       if(ok == MS_SUCCESS) return MS_SUCCESS;</span>
<span class="lineNum">     298 </span><span class="lineCov">          1 :       startfont = endfont+1; /* go to next font in list */</span>
<span class="lineNum">     299 </span>            :     } else {
<span class="lineNum">     300 </span><span class="lineCov">          1 :       if(ok == MS_SUCCESS) return MS_SUCCESS;</span>
<span class="lineNum">     301 </span>            :       break;
<span class="lineNum">     302 </span>            :     }
<span class="lineNum">     303 </span>            :   }
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            :   return MS_FAILURE;
<span class="lineNum">     306 </span>            : }
<a name="307"><span class="lineNum">     307 </span>            : </a>
<span class="lineNum">     308 </span>            : #ifdef USE_HARFBUZZ
<span class="lineNum">     309 </span><span class="lineCov">          1 : hb_font_t* get_hb_font(struct _ms_hb_user_data *font_data) {</span>
<span class="lineNum">     310 </span><span class="lineCov">          1 :   face_element *fcache = font_data-&gt;run-&gt;face;</span>
<span class="lineNum">     311 </span><span class="lineCov">          1 :   hb_font_element *hbf = fcache-&gt;hbfont;</span>
<span class="lineNum">     312 </span><span class="lineCov">          1 :   FT_Face face = fcache-&gt;face;</span>
<span class="lineNum">     313 </span><span class="lineCov">          1 :   int reqsize = MS_NINT(font_data-&gt;glyph_size *96.0 / 72.0);</span>
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span><span class="lineCov">          1 :   if(reqsize != fcache-&gt;face-&gt;size-&gt;metrics.x_ppem) {</span>
<span class="lineNum">     316 </span><span class="lineCov">          1 :     FT_Set_Pixel_Sizes(face,0,reqsize);</span>
<span class="lineNum">     317 </span>            :   }
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span><span class="lineCov">          1 :   if(!hbf) {</span>
<span class="lineNum">     320 </span><span class="lineCov">          1 :     hbf = msSmallMalloc(sizeof(hb_font_element));</span>
<span class="lineNum">     321 </span><span class="lineCov">          1 :     hbf-&gt;hbparentfont = hb_ft_font_create(face,NULL);</span>
<span class="lineNum">     322 </span><span class="lineCov">          1 :     hbf-&gt;hbfont = hb_font_create_sub_font(hbf-&gt;hbparentfont);</span>
<span class="lineNum">     323 </span><span class="lineCov">          1 :     hbf-&gt;funcs = hb_font_funcs_create();</span>
<span class="lineNum">     324 </span><span class="lineCov">          1 :     hb_font_funcs_set_glyph_h_advance_func(hbf-&gt;funcs, _ms_get_glyph_h_advance_func, NULL, NULL);</span>
<span class="lineNum">     325 </span><span class="lineCov">          1 :     hb_font_funcs_set_glyph_func(hbf-&gt;funcs, _ms_get_glyph_func, NULL, NULL);</span>
<span class="lineNum">     326 </span><span class="lineCov">          1 :     hb_font_funcs_set_glyph_v_advance_func(hbf-&gt;funcs, _ms_get_glyph_v_advance_func, NULL, NULL);</span>
<span class="lineNum">     327 </span><span class="lineCov">          1 :     hbf-&gt;cursize = reqsize;</span>
<span class="lineNum">     328 </span><span class="lineCov">          1 :     fcache-&gt;hbfont = hbf;</span>
<span class="lineNum">     329 </span><span class="lineCov">          1 :     hb_font_set_funcs(hbf-&gt;hbfont, hbf-&gt;funcs, font_data, NULL);</span>
<span class="lineNum">     330 </span>            :   } else {
<span class="lineNum">     331 </span><span class="lineCov">          1 :     if(hbf-&gt;cursize != reqsize) {</span>
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :       hb_font_set_scale (hbf-&gt;hbparentfont,</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :           ((uint64_t) face-&gt;size-&gt;metrics.x_scale * (uint64_t) face-&gt;units_per_EM) &gt;&gt; 16,</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 :           ((uint64_t) face-&gt;size-&gt;metrics.y_scale * (uint64_t) face-&gt;units_per_EM) &gt;&gt; 16);</span>
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :       hb_font_set_ppem (hbf-&gt;hbparentfont, face-&gt;size-&gt;metrics.x_ppem, face-&gt;size-&gt;metrics.y_ppem);</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :       hbf-&gt;cursize = reqsize;</span>
<span class="lineNum">     337 </span>            :     }
<span class="lineNum">     338 </span>            :   }
<span class="lineNum">     339 </span><span class="lineCov">          1 :   hb_font_set_funcs_data(hbf-&gt;hbfont,font_data,NULL);</span>
<span class="lineNum">     340 </span><span class="lineCov">          1 :   return hbf-&gt;hbfont;</span>
<span class="lineNum">     341 </span>            : }
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            : /*
<span class="lineNum">     344 </span>            :  *  Return non-zero (true) if the given unicode array contains
<a name="345"><span class="lineNum">     345 </span>            :  *  only ASCII and ISO Latin-1 characters, otherwise return zero.</a>
<span class="lineNum">     346 </span>            :  */
<span class="lineNum">     347 </span><span class="lineCov">          1 : int unicode_is_latin1(const unsigned int *unicode, long nglyphs)</span>
<span class="lineNum">     348 </span>            : {
<span class="lineNum">     349 </span>            :   long i;
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span><span class="lineCov">          1 :   for (i=0; i &lt; nglyphs; i++) {</span>
<span class="lineNum">     352 </span><span class="lineCov">          1 :     if(unicode[i] &lt; 0x2B0) continue;</span>
<span class="lineNum">     353 </span>            :     return 0;
<span class="lineNum">     354 </span>            :   }
<span class="lineNum">     355 </span>            :   return 1;
<a name="356"><span class="lineNum">     356 </span>            : }</a>
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span><span class="lineCov">          1 : void get_scripts(unsigned int *cp, int len, hb_script_t *scripts) {</span>
<span class="lineNum">     359 </span>            :   int i;
<span class="lineNum">     360 </span>            :   int backwards_scan = 0;
<span class="lineNum">     361 </span><span class="lineCov">          1 :   hb_unicode_funcs_t *ufuncs = hb_unicode_funcs_get_default();</span>
<span class="lineNum">     362 </span>            :   hb_script_t last_script = HB_SCRIPT_UNKNOWN;
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            :   // determine script (forward scan)
<span class="lineNum">     365 </span><span class="lineCov">          1 :   for (i = 0; i &lt; len; i++) {</span>
<span class="lineNum">     366 </span><span class="lineCov">          1 :     scripts[i] = hb_unicode_script(ufuncs, cp[i]);</span>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            :     // common/inherit codepoints inherit script from context
<span class="lineNum">     369 </span><span class="lineCov">          1 :     if (scripts[i] == HB_SCRIPT_COMMON ||</span>
<span class="lineNum">     370 </span>            :         scripts[i] == HB_SCRIPT_INHERITED) {
<span class="lineNum">     371 </span>            :       // unknown is not a valid context
<span class="lineNum">     372 </span><span class="lineCov">          1 :       if (last_script != HB_SCRIPT_UNKNOWN)</span>
<span class="lineNum">     373 </span><span class="lineCov">          1 :         scripts[i] = last_script;</span>
<span class="lineNum">     374 </span>            :       else
<span class="lineNum">     375 </span>            :         // do a backwards scan to check if next codepoint
<span class="lineNum">     376 </span>            :         // contains a valid script for context
<span class="lineNum">     377 </span>            :         backwards_scan = 1;
<span class="lineNum">     378 </span>            :     } else {
<span class="lineNum">     379 </span>            :       last_script = scripts[i];
<span class="lineNum">     380 </span>            :     }
<span class="lineNum">     381 </span>            :   }
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :   // determine script (backwards scan, if needed)
<span class="lineNum">     384 </span>            :   last_script = HB_SCRIPT_UNKNOWN;
<span class="lineNum">     385 </span><span class="lineCov">          1 :   for (i = len - 1; i &gt;= 0 &amp;&amp; backwards_scan; i--) {</span>
<span class="lineNum">     386 </span>            :     // common/inherit codepoints inherit script from context
<span class="lineNum">     387 </span><span class="lineCov">          1 :     if (scripts[i] == HB_SCRIPT_COMMON ||</span>
<span class="lineNum">     388 </span>            :         scripts[i] == HB_SCRIPT_INHERITED) {
<span class="lineNum">     389 </span>            :       // unknown script is not a valid context
<span class="lineNum">     390 </span><span class="lineCov">          1 :       if (last_script != HB_SCRIPT_UNKNOWN)</span>
<span class="lineNum">     391 </span><span class="lineCov">          1 :         scripts[i] = last_script;</span>
<span class="lineNum">     392 </span>            :     } else {
<span class="lineNum">     393 </span>            :       last_script = scripts[i];
<span class="lineNum">     394 </span>            :     }
<span class="lineNum">     395 </span>            :   }
<span class="lineNum">     396 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     397 </span>            : #endif
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            : /* returns 1 if this is a codepoint we should skip. only checks \r for now */
<span class="lineNum">     400 </span>            : static int skip_unicode(unsigned int unicode) {
<span class="lineNum">     401 </span><span class="lineCov">          1 :   switch(unicode) {</span>
<span class="lineNum">     402 </span>            :   case '\r':
<span class="lineNum">     403 </span>            :     return 1;
<span class="lineNum">     404 </span>            :     break;
<span class="lineNum">     405 </span>            :   default:
<span class="lineNum">     406 </span>            :     return 0;
<span class="lineNum">     407 </span>            :   }
<span class="lineNum">     408 </span>            : }
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            : #define MS_RTL_LTR 0
<span class="lineNum">     411 </span>            : #define MS_RTL_RTL 1
<span class="lineNum">     412 </span>            : #define MS_RTL_MIXED 2
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            : struct line_desc{
<span class="lineNum">     415 </span>            :   int length;
<span class="lineNum">     416 </span>            :   int rtl;
<a name="417"><span class="lineNum">     417 </span>            : } ;</a>
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span><span class="lineCov">          1 : int msLayoutTextSymbol(mapObj *map, textSymbolObj *ts, textPathObj *tgret) {</span>
<span class="lineNum">     420 </span>            : #define STATIC_GLYPHS 100
<span class="lineNum">     421 </span>            : #define STATIC_LINES 10
<span class="lineNum">     422 </span>            :   text_run static_runs[STATIC_GLYPHS];
<span class="lineNum">     423 </span>            :   int i,nruns, start, ret=MS_SUCCESS;
<span class="lineNum">     424 </span>            :   size_t text_num_bytes;
<span class="lineNum">     425 </span>            :   char *inp;
<span class="lineNum">     426 </span>            :   unsigned int static_unicodes[STATIC_GLYPHS];
<span class="lineNum">     427 </span>            :   unsigned int static_codepoints[STATIC_GLYPHS];
<span class="lineNum">     428 </span>            : #ifdef USE_FRIBIDI
<span class="lineNum">     429 </span>            :   FriBidiCharType static_ctypes[STATIC_GLYPHS];
<span class="lineNum">     430 </span>            :   FriBidiLevel static_bidi_levels[STATIC_GLYPHS];
<span class="lineNum">     431 </span>            : #endif
<span class="lineNum">     432 </span>            : #ifdef USE_HARFBUZZ
<span class="lineNum">     433 </span>            :   hb_script_t static_scripts[STATIC_GLYPHS];
<span class="lineNum">     434 </span>            :   hb_buffer_t *buf = NULL;
<span class="lineNum">     435 </span>            : #endif
<span class="lineNum">     436 </span>            :   struct line_desc static_line_descs[STATIC_LINES];
<span class="lineNum">     437 </span>            :   int alloc_glyphs = 0;
<span class="lineNum">     438 </span>            :   struct line_desc *line_descs = NULL;
<span class="lineNum">     439 </span>            :   text_run *runs;
<span class="lineNum">     440 </span>            :   double oldpeny=3455,peny,penx=0; /*oldpeny is set to an unreasonable default initial value */
<span class="lineNum">     441 </span>            :   fontSetObj *fontset = NULL;
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span>            :   TextInfo glyphs;
<span class="lineNum">     444 </span>            :   int num_glyphs = 0;
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            :   assert(ts-&gt;annotext &amp;&amp; *ts-&gt;annotext); /* ensure we have at least one character/glyph to treat */
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span><span class="lineCov">          1 :   if(map) fontset = &amp;map-&gt;fontset;</span>
<span class="lineNum">     449 </span>            :   /* go through iconv beforehand, so we know we're handling utf8 */
<span class="lineNum">     450 </span>            : #ifdef USE_ICONV
<span class="lineNum">     451 </span><span class="lineCov">          1 :   if(ts-&gt;label-&gt;encoding &amp;&amp; strcasecmp(ts-&gt;label-&gt;encoding,&quot;UTF-8&quot;)) {</span>
<span class="lineNum">     452 </span>            :     iconv_t cd;
<span class="lineNum">     453 </span>            :     size_t len, iconv_status,bufleft;
<span class="lineNum">     454 </span>            :     char *encoded_text,*outp;
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :     len = strlen(ts-&gt;annotext);</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :     bufleft = len*6;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :     encoded_text = msSmallMalloc(bufleft+1);</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :     cd = iconv_open(&quot;UTF-8&quot;, ts-&gt;label-&gt;encoding);</span>
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :     if(cd == (iconv_t)-1) {</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :       msSetError(MS_IDENTERR, &quot;Encoding not supported by libiconv (%s).&quot;,</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :                &quot;msGetEncodedString()&quot;, ts-&gt;label-&gt;encoding);</span>
<span class="lineNum">     463 </span><span class="lineNoCov">          0 :       return MS_FAILURE;</span>
<span class="lineNum">     464 </span>            :     }
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :     inp = ts-&gt;annotext;</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :     outp = encoded_text;</span>
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     while(len&gt;0) {</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :       iconv_status = iconv(cd, &amp;inp, &amp;len, &amp;outp, &amp;bufleft);</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :       if(iconv_status == -1) {</span>
<span class="lineNum">     472 </span>            :         break;
<span class="lineNum">     473 </span>            :       }
<span class="lineNum">     474 </span>            :     }
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :     text_num_bytes = outp - encoded_text;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :     encoded_text[text_num_bytes] = 0;</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :     free(ts-&gt;annotext);</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :     ts-&gt;annotext = encoded_text;</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :     iconv_close(cd);</span>
<span class="lineNum">     481 </span>            :   } else
<span class="lineNum">     482 </span>            : #endif
<span class="lineNum">     483 </span>            :   {
<span class="lineNum">     484 </span><span class="lineCov">          1 :     text_num_bytes = strlen(ts-&gt;annotext);</span>
<span class="lineNum">     485 </span>            :   }
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span><span class="lineCov">          1 :   if( text_num_bytes == 0 )</span>
<span class="lineNum">     488 </span>            :       return 0;
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span><span class="lineCov">          1 :   if(text_num_bytes &gt; STATIC_GLYPHS) {</span>
<span class="lineNum">     491 </span>            : #ifdef USE_FRIBIDI
<span class="lineNum">     492 </span><span class="lineCov">          1 :     glyphs.bidi_levels = msSmallMalloc(text_num_bytes * sizeof(FriBidiLevel));</span>
<span class="lineNum">     493 </span><span class="lineCov">          1 :     glyphs.ctypes = msSmallMalloc(text_num_bytes * sizeof(FriBidiCharType));</span>
<span class="lineNum">     494 </span>            : #endif
<span class="lineNum">     495 </span><span class="lineCov">          1 :     glyphs.unicodes = msSmallMalloc(text_num_bytes * sizeof(unsigned int));</span>
<span class="lineNum">     496 </span><span class="lineCov">          1 :     glyphs.codepoints = msSmallMalloc(text_num_bytes * sizeof(unsigned int));</span>
<span class="lineNum">     497 </span>            : #ifdef USE_HARFBUZZ
<span class="lineNum">     498 </span><span class="lineCov">          1 :     glyphs.scripts = msSmallMalloc(text_num_bytes * sizeof(hb_script_t));</span>
<span class="lineNum">     499 </span>            : #endif
<span class="lineNum">     500 </span><span class="lineCov">          1 :     runs = msSmallMalloc(text_num_bytes * sizeof(text_run));</span>
<span class="lineNum">     501 </span>            :   } else {
<span class="lineNum">     502 </span>            : #ifdef USE_FRIBIDI
<span class="lineNum">     503 </span><span class="lineCov">          1 :     glyphs.bidi_levels = static_bidi_levels;</span>
<span class="lineNum">     504 </span><span class="lineCov">          1 :     glyphs.ctypes = static_ctypes;</span>
<span class="lineNum">     505 </span>            : #endif
<span class="lineNum">     506 </span><span class="lineCov">          1 :     glyphs.unicodes = static_unicodes;</span>
<span class="lineNum">     507 </span><span class="lineCov">          1 :     glyphs.codepoints = static_codepoints;</span>
<span class="lineNum">     508 </span>            : #ifdef USE_HARFBUZZ
<span class="lineNum">     509 </span><span class="lineCov">          1 :     glyphs.scripts = static_scripts;</span>
<span class="lineNum">     510 </span>            : #endif
<span class="lineNum">     511 </span>            :     runs = static_runs;
<span class="lineNum">     512 </span>            :   }
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            :   /* populate the unicode entries once and for all */
<span class="lineNum">     515 </span><span class="lineCov">          1 :   inp = ts-&gt;annotext;</span>
<span class="lineNum">     516 </span><span class="lineCov">          1 :   while(*inp) {</span>
<span class="lineNum">     517 </span>            :     unsigned int unicode;
<span class="lineNum">     518 </span><span class="lineCov">          1 :     inp += msUTF8ToUniChar(inp, &amp;unicode);</span>
<span class="lineNum">     519 </span><span class="lineCov">          1 :     if(!skip_unicode(unicode)){</span>
<span class="lineNum">     520 </span><span class="lineCov">          1 :       glyphs.unicodes[num_glyphs++] = unicode;</span>
<span class="lineNum">     521 </span>            :     }
<span class="lineNum">     522 </span>            :   }
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span><span class="lineCov">          1 :   if(ts-&gt;label-&gt;wrap || ts-&gt;label-&gt;maxlength &gt; 0) {</span>
<span class="lineNum">     525 </span><span class="lineCov">          1 :     if(ts-&gt;label-&gt;wrap &amp;&amp; ts-&gt;label-&gt;maxlength == 0) {</span>
<span class="lineNum">     526 </span><span class="lineCov">          1 :       for(i=0;i&lt;num_glyphs;i++) {</span>
<span class="lineNum">     527 </span>            :         /* replace all occurences of the wrap character with a newline */
<span class="lineNum">     528 </span><span class="lineCov">          1 :         if(glyphs.unicodes[i]== ts-&gt;label-&gt;wrap)</span>
<span class="lineNum">     529 </span><span class="lineCov">          1 :           glyphs.unicodes[i]= '\n';</span>
<span class="lineNum">     530 </span>            :       }
<span class="lineNum">     531 </span>            :     } else {
<span class="lineNum">     532 </span>            :       assert(ts-&gt;label-&gt;maxlength &gt; 0);
<span class="lineNum">     533 </span><span class="lineCov">          1 :       if(num_glyphs &gt; ts-&gt;label-&gt;maxlength) {</span>
<span class="lineNum">     534 </span>            :         int num_cur_glyph_on_line = 0; /*count for the number of glyphs on the current line*/
<span class="lineNum">     535 </span><span class="lineCov">          1 :         for(i=0; i&lt;num_glyphs; i++) {</span>
<span class="lineNum">     536 </span>            :           /* wrap at wrap character or at ZERO WIDTH SPACE (unicode 0x200b), if
<span class="lineNum">     537 </span>            :            * current line is too long */
<span class="lineNum">     538 </span><span class="lineCov">          1 :           if((glyphs.unicodes[i] == ts-&gt;label-&gt;wrap || glyphs.unicodes[i] == 0x200b)</span>
<span class="lineNum">     539 </span><span class="lineCov">          1 :               &amp;&amp; num_cur_glyph_on_line &gt;= ts-&gt;label-&gt;maxlength) {</span>
<span class="lineNum">     540 </span><span class="lineCov">          1 :             glyphs.unicodes[i]= '\n';</span>
<span class="lineNum">     541 </span><span class="lineCov">          1 :             num_cur_glyph_on_line = 0;</span>
<span class="lineNum">     542 </span>            :           } else {
<span class="lineNum">     543 </span><span class="lineCov">          1 :             num_cur_glyph_on_line++;</span>
<span class="lineNum">     544 </span>            :           }
<span class="lineNum">     545 </span>            :         }
<span class="lineNum">     546 </span>            :       }
<span class="lineNum">     547 </span>            :     }
<span class="lineNum">     548 </span>            :     /*
<span class="lineNum">     549 </span>            :      * TODO RFC98: RFC40 negative label-&gt;wrap. This is left out for the moment as it requires
<span class="lineNum">     550 </span>            :      * handling a realloc and imho is never used and is an overly-complex use-case.
<span class="lineNum">     551 </span>            :      */
<span class="lineNum">     552 </span>            :   }
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            :   /* split our text into runs (one for each line) */
<span class="lineNum">     555 </span>            :   nruns = 0;
<span class="lineNum">     556 </span>            :   start = 0;
<span class="lineNum">     557 </span><span class="lineCov">          1 :   runs[0].offset = 0;</span>
<span class="lineNum">     558 </span><span class="lineCov">          1 :   runs[0].line_number = 0;</span>
<span class="lineNum">     559 </span><span class="lineCov">          1 :   for(i=0; i&lt;num_glyphs; i++) {</span>
<span class="lineNum">     560 </span><span class="lineCov">          1 :     if(glyphs.unicodes[i]!= '\n') continue;</span>
<span class="lineNum">     561 </span><span class="lineCov">          1 :     runs[nruns].length = i - start; /* length of current line (without \n) */</span>
<span class="lineNum">     562 </span><span class="lineCov">          1 :     start = i+1; /* start of next line */</span>
<span class="lineNum">     563 </span><span class="lineCov">          1 :     runs[nruns+1].line_number = runs[nruns].line_number+1;</span>
<span class="lineNum">     564 </span><span class="lineCov">          1 :     runs[nruns+1].offset = start;</span>
<span class="lineNum">     565 </span><span class="lineCov">          1 :     nruns++;</span>
<span class="lineNum">     566 </span>            :   }
<span class="lineNum">     567 </span>            :   /* unless the last glyph was a \n, we need to &quot;close&quot; the last run */
<span class="lineNum">     568 </span><span class="lineCov">          1 :   if(glyphs.unicodes[num_glyphs-1]!= '\n') {</span>
<span class="lineNum">     569 </span><span class="lineCov">          1 :     runs[nruns].length = num_glyphs - start;</span>
<span class="lineNum">     570 </span><span class="lineCov">          1 :     nruns++;</span>
<span class="lineNum">     571 </span>            :   }
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span><span class="lineCov">          1 :   if(runs[nruns-1].line_number+1 &gt; STATIC_LINES) {</span>
<span class="lineNum">     574 </span><span class="lineCov">          1 :     line_descs = msSmallMalloc((runs[nruns-1].line_number + 1)*sizeof(struct line_desc));</span>
<span class="lineNum">     575 </span>            :   } else {
<span class="lineNum">     576 </span>            :     line_descs = static_line_descs;
<span class="lineNum">     577 </span>            :   }
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span>            : #ifdef USE_FRIBIDI
<span class="lineNum">     580 </span><span class="lineCov">          1 :   for(i=0;i&lt;nruns;i++) {</span>
<span class="lineNum">     581 </span>            :     /* check the run (at this stage, one run per line), decide if we need to go through bidi and/or shaping */
<span class="lineNum">     582 </span><span class="lineCov">          1 :     if(unicode_is_latin1(glyphs.unicodes + runs[i].offset, runs[i].length)) {</span>
<span class="lineNum">     583 </span><span class="lineCov">          1 :       runs[i].rtl = -1;</span>
<span class="lineNum">     584 </span><span class="lineCov">          1 :       line_descs[i].rtl = MS_RTL_LTR;</span>
<span class="lineNum">     585 </span>            :     } else {
<span class="lineNum">     586 </span><span class="lineCov">          1 :       runs[i].rtl = 0;</span>
<span class="lineNum">     587 </span>            :     }
<span class="lineNum">     588 </span>            :   }
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span><span class="lineCov">          1 :   for(i=0; i&lt;nruns; i++) {</span>
<span class="lineNum">     591 </span>            :     /* split the text into bidi runs */
<span class="lineNum">     592 </span><span class="lineCov">          1 :     if(runs[i].rtl &gt;= 0) {</span>
<span class="lineNum">     593 </span>            :       int j, cur_run_start, original_num_glyphs, original_offset;
<span class="lineNum">     594 </span>            :       FriBidiLevel prevlevel;
<span class="lineNum">     595 </span><span class="lineCov">          1 :       FriBidiParType dir = FRIBIDI_PAR_LTR;</span>
<span class="lineNum">     596 </span><span class="lineCov">          1 :       original_offset = cur_run_start = runs[i].offset;</span>
<span class="lineNum">     597 </span><span class="lineCov">          1 :       original_num_glyphs = runs[i].length;</span>
<span class="lineNum">     598 </span><span class="lineCov">          1 :       fribidi_get_bidi_types(glyphs.unicodes + original_offset, runs[i].length, glyphs.ctypes + original_offset);</span>
<span class="lineNum">     599 </span><span class="lineCov">          1 :       fribidi_get_par_embedding_levels(glyphs.ctypes + original_offset, runs[i].length, &amp;dir, glyphs.bidi_levels + runs[i].offset);</span>
<span class="lineNum">     600 </span>            :       /* if we have different embedding levels, create a run for each one */
<span class="lineNum">     601 </span><span class="lineCov">          1 :       runs[i].rtl = prevlevel = glyphs.bidi_levels[original_offset];</span>
<span class="lineNum">     602 </span><span class="lineCov">          1 :       line_descs[runs[i].line_number].rtl = (prevlevel%2) ? MS_RTL_RTL:MS_RTL_LTR;</span>
<span class="lineNum">     603 </span><span class="lineCov">          1 :       for(j=1; j&lt;original_num_glyphs; j++) {</span>
<span class="lineNum">     604 </span><span class="lineCov">          1 :         if(glyphs.bidi_levels[original_offset+j] != prevlevel) {</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :           line_descs[runs[i].line_number].rtl = MS_RTL_MIXED;</span>
<span class="lineNum">     606 </span>            :           /* create a new run for the different embedding level */
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :           nruns++;</span>
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            :           /* first move remaining runs */
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :           memmove(runs+i+2,runs+i+1,(nruns-i-2)*sizeof(text_run));</span>
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :           i++;</span>
<span class="lineNum">     613 </span>            :           /* new run inherints line number */
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :           runs[i].line_number = runs[i-1].line_number;</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :           runs[i].offset = original_offset + j;</span>
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :           runs[i].length = (runs[i-1].offset + runs[i-1].length) - runs[i].offset;</span>
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :           runs[i-1].length = runs[i].offset - runs[i-1].offset;</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span>            :           /* new run starts at current postition */
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :           runs[i].rtl = prevlevel = glyphs.bidi_levels[original_offset+j];</span>
<span class="lineNum">     622 </span>            :         }
<span class="lineNum">     623 </span>            :       }
<span class="lineNum">     624 </span>            :     }
<span class="lineNum">     625 </span>            :   }
<span class="lineNum">     626 </span>            : #else
<span class="lineNum">     627 </span>            :   for(i=0;i&lt;nruns;i++) {
<span class="lineNum">     628 </span>            :     line_descs[i].rtl = MS_RTL_LTR;
<span class="lineNum">     629 </span>            :   }
<span class="lineNum">     630 </span>            : #endif
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            : #ifdef USE_FRIBIDI
<span class="lineNum">     633 </span>            :   /* determine the scripts of each run, and split again into runs with identical script */
<span class="lineNum">     634 </span><span class="lineCov">          1 :   for(i=0; i&lt;nruns; i++) {</span>
<span class="lineNum">     635 </span><span class="lineCov">          1 :     if(runs[i].rtl == -1) {</span>
<span class="lineNum">     636 </span><span class="lineCov">          1 :       runs[i].script = HB_SCRIPT_LATIN;</span>
<span class="lineNum">     637 </span><span class="lineCov">          1 :       continue; /* skip runs we have determined we are latin (no shaping needed) */</span>
<span class="lineNum">     638 </span>            :     } else {
<span class="lineNum">     639 </span>            :       int j, cur_run_start, original_num_glyphs, original_offset;
<span class="lineNum">     640 </span>            :       hb_script_t prevscript;
<span class="lineNum">     641 </span><span class="lineCov">          1 :       original_offset = cur_run_start = runs[i].offset;</span>
<span class="lineNum">     642 </span><span class="lineCov">          1 :       original_num_glyphs = runs[i].length;</span>
<span class="lineNum">     643 </span><span class="lineCov">          1 :       get_scripts(glyphs.unicodes + original_offset, runs[i].length, glyphs.scripts + original_offset);</span>
<span class="lineNum">     644 </span>            :       /* if we have different scripts, create a run for each one */
<span class="lineNum">     645 </span><span class="lineCov">          1 :       runs[i].script = prevscript = glyphs.scripts[original_offset];</span>
<span class="lineNum">     646 </span><span class="lineCov">          1 :       for(j=1; j&lt;original_num_glyphs; j++) {</span>
<span class="lineNum">     647 </span><span class="lineCov">          1 :         if(glyphs.scripts[original_offset+j] != prevscript) {</span>
<span class="lineNum">     648 </span>            :           /* create a new run for the different embedding level */
<span class="lineNum">     649 </span><span class="lineCov">          1 :           nruns++;</span>
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            :           /* first move remaining runs */
<span class="lineNum">     652 </span><span class="lineCov">          1 :           memmove(runs+i+2,runs+i+1,(nruns-i-2)*sizeof(text_run));</span>
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span><span class="lineCov">          1 :           i++;</span>
<span class="lineNum">     655 </span>            :           /* new run inherints line number and rtl*/
<span class="lineNum">     656 </span><span class="lineCov">          1 :           runs[i].line_number = runs[i-1].line_number;</span>
<span class="lineNum">     657 </span><span class="lineCov">          1 :           runs[i].rtl = runs[i-1].rtl;</span>
<span class="lineNum">     658 </span><span class="lineCov">          1 :           runs[i].offset = original_offset + j;</span>
<span class="lineNum">     659 </span><span class="lineCov">          1 :           runs[i].length = (runs[i-1].offset + runs[i-1].length) - runs[i].offset;</span>
<span class="lineNum">     660 </span><span class="lineCov">          1 :           runs[i-1].length = runs[i].offset - runs[i-1].offset;</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span><span class="lineCov">          1 :           runs[i].script = prevscript = glyphs.scripts[original_offset+j];</span>
<span class="lineNum">     664 </span>            :         }
<span class="lineNum">     665 </span>            :       }
<span class="lineNum">     666 </span>            :     }
<span class="lineNum">     667 </span>            :   }
<span class="lineNum">     668 </span>            : #endif
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span><span class="lineCov">          1 :   for(i=0; i&lt;nruns; i++) {</span>
<span class="lineNum">     671 </span><span class="lineCov">          1 :     ret = get_face_for_run(fontset, ts-&gt;label-&gt;font, runs+i, &amp;glyphs);</span>
<span class="lineNum">     672 </span><span class="lineCov">          1 :     if(UNLIKELY(ret == MS_FAILURE))</span>
<span class="lineNum">     673 </span>            :       goto cleanup;
<span class="lineNum">     674 </span>            :   }
<span class="lineNum">     675 </span>            : 
<span class="lineNum">     676 </span>            :   /*
<span class="lineNum">     677 </span>            :    * determine the font face to use for a given run. No splitting needed here for
<span class="lineNum">     678 </span>            :    * now, as we suppose that the decomposition of each run into individual bidi
<span class="lineNum">     679 </span>            :    * direction and script level is sufficient to ensure that a given run can be
<span class="lineNum">     680 </span>            :    * represented by a single font (i.e. there's no need to look into multiple fonts
<span class="lineNum">     681 </span>            :    * to find the glyphs of the run)
<span class="lineNum">     682 </span>            :    */
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            : 
<span class="lineNum">     685 </span><span class="lineCov">          1 :   tgret-&gt;numlines = runs[nruns-1].line_number + 1;</span>
<span class="lineNum">     686 </span><span class="lineCov">          1 :   tgret-&gt;bounds.bbox.minx = 0;</span>
<span class="lineNum">     687 </span><span class="lineCov">          1 :   tgret-&gt;bounds.bbox.miny = FLT_MAX;</span>
<span class="lineNum">     688 </span><span class="lineCov">          1 :   tgret-&gt;bounds.bbox.maxx = tgret-&gt;bounds.bbox.maxy = -FLT_MAX;</span>
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span><span class="lineCov">          1 :   for(i=0;i&lt;nruns;i++) {</span>
<span class="lineNum">     692 </span>            :     unsigned int glyph_count,j;
<span class="lineNum">     693 </span><span class="lineCov">          1 :     if(!runs[i].face) continue;</span>
<span class="lineNum">     694 </span><span class="lineCov">          1 :     peny = (1 - tgret-&gt;numlines + runs[i].line_number) * tgret-&gt;line_height;</span>
<span class="lineNum">     695 </span><span class="lineCov">          1 :     if(peny != oldpeny) {</span>
<span class="lineNum">     696 </span><span class="lineCov">          1 :       if(i&gt;0) line_descs[runs[i-1].line_number].length = penx;</span>
<span class="lineNum">     697 </span><span class="lineCov">          1 :       if(penx &gt; tgret-&gt;bounds.bbox.maxx)</span>
<span class="lineNum">     698 </span><span class="lineCov">          1 :         tgret-&gt;bounds.bbox.maxx = penx;</span>
<span class="lineNum">     699 </span>            :       oldpeny = peny;
<span class="lineNum">     700 </span>            :       penx = 0;
<span class="lineNum">     701 </span>            :     }
<span class="lineNum">     702 </span>            : #if defined(USE_HARFBUZZ) &amp;&amp; defined(USE_FRIBIDI)
<span class="lineNum">     703 </span><span class="lineCov">          1 :     if(runs[i].rtl == -1 || runs[i].script == HB_SCRIPT_LATIN || runs[i].script == HB_SCRIPT_COMMON)</span>
<span class="lineNum">     704 </span>            : #endif
<span class="lineNum">     705 </span>            :     {
<span class="lineNum">     706 </span>            :       /* use our basic shaper */
<span class="lineNum">     707 </span><span class="lineCov">          1 :       unsigned int *codepoint = glyphs.codepoints + runs[i].offset;</span>
<span class="lineNum">     708 </span><span class="lineCov">          1 :       alloc_glyphs += runs[i].length;</span>
<span class="lineNum">     709 </span><span class="lineCov">          1 :       tgret-&gt;glyphs = msSmallRealloc(tgret-&gt;glyphs, alloc_glyphs * sizeof(glyphObj));</span>
<span class="lineNum">     710 </span><span class="lineCov">          1 :       for(j=0;j&lt;runs[i].length;j++) {</span>
<span class="lineNum">     711 </span><span class="lineCov">          1 :         glyphObj *g = &amp;tgret-&gt;glyphs[tgret-&gt;numglyphs + j];</span>
<span class="lineNum">     712 </span><span class="lineCov">          1 :         g-&gt;glyph = msGetGlyphByIndex(runs[i].face,tgret-&gt;glyph_size, *codepoint);</span>
<span class="lineNum">     713 </span><span class="lineCov">          1 :         g-&gt;face = runs[i].face;</span>
<span class="lineNum">     714 </span><span class="lineCov">          1 :         codepoint++;</span>
<span class="lineNum">     715 </span><span class="lineCov">          1 :         g-&gt;pnt.x = penx;</span>
<span class="lineNum">     716 </span><span class="lineCov">          1 :         g-&gt;pnt.y = peny;</span>
<span class="lineNum">     717 </span><span class="lineCov">          1 :         g-&gt;rot = 0.0;</span>
<span class="lineNum">     718 </span><span class="lineCov">          1 :         penx += g-&gt;glyph-&gt;metrics.advance;</span>
<span class="lineNum">     719 </span><span class="lineCov">          1 :         if(runs[i].line_number == 0 &amp;&amp; peny - g-&gt;glyph-&gt;metrics.maxy &lt; tgret-&gt;bounds.bbox.miny) /*compute minimal y, only for the first line */</span>
<span class="lineNum">     720 </span><span class="lineCov">          1 :           tgret-&gt;bounds.bbox.miny = peny - g-&gt;glyph-&gt;metrics.maxy;</span>
<span class="lineNum">     721 </span><span class="lineCov">          1 :         if(peny - g-&gt;glyph-&gt;metrics.miny &gt; tgret-&gt;bounds.bbox.maxy)</span>
<span class="lineNum">     722 </span><span class="lineCov">          1 :           tgret-&gt;bounds.bbox.maxy = peny - g-&gt;glyph-&gt;metrics.miny;</span>
<span class="lineNum">     723 </span>            :       }
<span class="lineNum">     724 </span>            : #if defined(USE_HARFBUZZ) &amp;&amp; defined(USE_FRIBIDI)
<span class="lineNum">     725 </span>            :     } else {
<span class="lineNum">     726 </span>            :       struct _ms_hb_user_data user_data;
<span class="lineNum">     727 </span>            :       hb_font_t *font;
<span class="lineNum">     728 </span>            :       hb_glyph_info_t *glyph_info;
<span class="lineNum">     729 </span>            :       hb_glyph_position_t *glyph_pos;
<span class="lineNum">     730 </span><span class="lineCov">          1 :       if(!buf) {</span>
<span class="lineNum">     731 </span><span class="lineCov">          1 :         buf = hb_buffer_create();</span>
<span class="lineNum">     732 </span>            :       }
<span class="lineNum">     733 </span><span class="lineCov">          1 :       user_data.info = &amp;glyphs;</span>
<span class="lineNum">     734 </span><span class="lineCov">          1 :       user_data.run = runs + i;</span>
<span class="lineNum">     735 </span><span class="lineCov">          1 :       user_data.glyph_size = tgret-&gt;glyph_size;</span>
<span class="lineNum">     736 </span><span class="lineCov">          1 :       hb_buffer_clear_contents(buf);</span>
<span class="lineNum">     737 </span><span class="lineCov">          1 :       hb_buffer_set_script (buf, runs[i].script);</span>
<span class="lineNum">     738 </span><span class="lineCov">          1 :       font = get_hb_font(&amp;user_data);</span>
<span class="lineNum">     739 </span><span class="lineCov">          1 :       hb_buffer_set_direction(buf, (runs[i].rtl%2) ? HB_DIRECTION_RTL :HB_DIRECTION_LTR);</span>
<span class="lineNum">     740 </span><span class="lineCov">          1 :       hb_buffer_add_utf32(buf,glyphs.unicodes + runs[i].offset, runs[i].length, 0, runs[i].length);</span>
<span class="lineNum">     741 </span><span class="lineCov">          1 :       hb_shape(font,buf,hbfeatures,2);</span>
<span class="lineNum">     742 </span><span class="lineCov">          1 :       glyph_info = hb_buffer_get_glyph_infos(buf, &amp;glyph_count);</span>
<span class="lineNum">     743 </span><span class="lineCov">          1 :       glyph_pos = hb_buffer_get_glyph_positions(buf, &amp;glyph_count);</span>
<span class="lineNum">     744 </span><span class="lineCov">          1 :       alloc_glyphs += glyph_count;</span>
<span class="lineNum">     745 </span><span class="lineCov">          1 :       tgret-&gt;glyphs = msSmallRealloc(tgret-&gt;glyphs, alloc_glyphs * sizeof(glyphObj));</span>
<span class="lineNum">     746 </span><span class="lineCov">          1 :       for(j=0;j&lt;glyph_count;j++) {</span>
<span class="lineNum">     747 </span><span class="lineCov">          1 :         glyphObj *g = &amp;tgret-&gt;glyphs[tgret-&gt;numglyphs + j];</span>
<span class="lineNum">     748 </span><span class="lineCov">          1 :         g-&gt;glyph = msGetGlyphByIndex(runs[i].face,tgret-&gt;glyph_size,glyph_info[j].codepoint);</span>
<span class="lineNum">     749 </span><span class="lineCov">          1 :         g-&gt;face = runs[i].face;</span>
<span class="lineNum">     750 </span><span class="lineCov">          1 :         g-&gt;pnt.x = penx + glyph_pos[j].x_offset/64;</span>
<span class="lineNum">     751 </span><span class="lineCov">          1 :         g-&gt;pnt.y = peny - glyph_pos[j].y_offset/64;</span>
<span class="lineNum">     752 </span><span class="lineCov">          1 :         g-&gt;rot = 0;</span>
<span class="lineNum">     753 </span><span class="lineCov">          1 :         penx += glyph_pos[j].x_advance/64.0;</span>
<span class="lineNum">     754 </span>            :         /* peny -= glyph_pos[j].y_advance/64; // we don't do vertical layouts */
<span class="lineNum">     755 </span><span class="lineCov">          1 :         if(runs[i].line_number == 0 &amp;&amp; peny - g-&gt;glyph-&gt;metrics.maxy &lt; tgret-&gt;bounds.bbox.miny) /*compute minimal y, only for the first line */</span>
<span class="lineNum">     756 </span><span class="lineCov">          1 :           tgret-&gt;bounds.bbox.miny = peny - g-&gt;glyph-&gt;metrics.maxy;</span>
<span class="lineNum">     757 </span><span class="lineCov">          1 :         if(peny - g-&gt;glyph-&gt;metrics.miny &gt; tgret-&gt;bounds.bbox.maxy)</span>
<span class="lineNum">     758 </span><span class="lineCov">          1 :           tgret-&gt;bounds.bbox.maxy = peny - g-&gt;glyph-&gt;metrics.miny;</span>
<span class="lineNum">     759 </span>            :       }
<span class="lineNum">     760 </span>            : #endif
<span class="lineNum">     761 </span>            :     }
<span class="lineNum">     762 </span><span class="lineCov">          1 :     tgret-&gt;numglyphs = alloc_glyphs;</span>
<span class="lineNum">     763 </span><span class="lineCov">          1 :     line_descs[runs[nruns-1].line_number].length = penx;</span>
<span class="lineNum">     764 </span><span class="lineCov">          1 :     if(penx &gt; tgret-&gt;bounds.bbox.maxx)</span>
<span class="lineNum">     765 </span><span class="lineCov">          1 :       tgret-&gt;bounds.bbox.maxx = penx;</span>
<span class="lineNum">     766 </span>            :   }
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span>            : #ifdef USE_HARFBUZZ
<span class="lineNum">     769 </span><span class="lineCov">          1 :   if(buf) {</span>
<span class="lineNum">     770 </span><span class="lineCov">          1 :     hb_buffer_destroy(buf);</span>
<span class="lineNum">     771 </span>            :   }
<span class="lineNum">     772 </span>            : #endif
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span><span class="lineCov">          1 :   if(tgret-&gt;numlines &gt; 1) {</span>
<span class="lineNum">     775 </span>            :     int max_line_length = 0;
<span class="lineNum">     776 </span>            :     int line = -1;
<span class="lineNum">     777 </span>            :     double cur_line_offset = 0;
<span class="lineNum">     778 </span>            :     int prev_default_align = MS_ALIGN_LEFT; /* if we have mixed rtl status, use the alignment of the previous
<span class="lineNum">     779 </span>            :                                                line. this defaults to left-alignment if the first line is mixed */
<span class="lineNum">     780 </span>            :     int cur_default_align = 0;
<span class="lineNum">     781 </span><span class="lineCov">          1 :     for(i=0; i&lt;tgret-&gt;numlines; i++) {</span>
<span class="lineNum">     782 </span><span class="lineCov">          1 :       if(line_descs[i].length &gt; max_line_length) {</span>
<span class="lineNum">     783 </span>            :         max_line_length = line_descs[i].length;
<span class="lineNum">     784 </span>            :       }
<span class="lineNum">     785 </span>            :     }
<span class="lineNum">     786 </span>            :     oldpeny = 3455;
<span class="lineNum">     787 </span><span class="lineCov">          1 :     for(i=0; i&lt;alloc_glyphs; i++) {</span>
<span class="lineNum">     788 </span><span class="lineCov">          1 :       if(tgret-&gt;glyphs[i].pnt.y != oldpeny) {</span>
<span class="lineNum">     789 </span>            :         oldpeny = tgret-&gt;glyphs[i].pnt.y;
<span class="lineNum">     790 </span><span class="lineCov">          1 :         line++;</span>
<span class="lineNum">     791 </span>            :         /* compute offset to apply to coming line */
<span class="lineNum">     792 </span><span class="lineCov">          1 :         switch(ts-&gt;label-&gt;align) {</span>
<span class="lineNum">     793 </span><span class="lineCov">          1 :         case MS_ALIGN_CENTER:</span>
<span class="lineNum">     794 </span><span class="lineCov">          1 :           cur_line_offset = (max_line_length - line_descs[line].length)/2.0;</span>
<span class="lineNum">     795 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">     796 </span><span class="lineCov">          1 :         case MS_ALIGN_RIGHT:</span>
<span class="lineNum">     797 </span><span class="lineCov">          1 :           cur_line_offset = (max_line_length - line_descs[line].length);</span>
<span class="lineNum">     798 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">     799 </span>            :         case MS_ALIGN_LEFT:
<span class="lineNum">     800 </span>            :           cur_line_offset = 0;
<span class="lineNum">     801 </span>            :           break;
<span class="lineNum">     802 </span><span class="lineCov">          1 :         case MS_ALIGN_DEFAULT:</span>
<span class="lineNum">     803 </span>            :         default:
<span class="lineNum">     804 </span><span class="lineCov">          1 :           switch(line_descs[line].rtl) {</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :           case MS_RTL_MIXED:</span>
<span class="lineNum">     806 </span>            :             cur_default_align = prev_default_align;
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">     808 </span>            :           case MS_RTL_RTL:
<span class="lineNum">     809 </span>            :             cur_default_align = prev_default_align = MS_RTL_RTL;
<span class="lineNum">     810 </span>            :             break;
<span class="lineNum">     811 </span>            :           case MS_RTL_LTR:
<span class="lineNum">     812 </span>            :             cur_default_align = prev_default_align = MS_RTL_LTR;
<span class="lineNum">     813 </span>            :             break;
<span class="lineNum">     814 </span>            :           }
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :           switch(cur_default_align) {</span>
<span class="lineNum">     816 </span><span class="lineCov">          1 :           case MS_RTL_RTL:</span>
<span class="lineNum">     817 </span>            :             /* align to the right */
<span class="lineNum">     818 </span><span class="lineCov">          1 :             cur_line_offset = (max_line_length - line_descs[line].length);</span>
<span class="lineNum">     819 </span><span class="lineCov">          1 :             break;</span>
<span class="lineNum">     820 </span>            :           case MS_RTL_LTR:
<span class="lineNum">     821 </span>            :             cur_line_offset = 0;
<span class="lineNum">     822 </span>            :             break;
<span class="lineNum">     823 </span>            :           }
<span class="lineNum">     824 </span>            :         }
<span class="lineNum">     825 </span>            :       }
<span class="lineNum">     826 </span><span class="lineCov">          1 :       tgret-&gt;glyphs[i].pnt.x += cur_line_offset;</span>
<span class="lineNum">     827 </span>            :     }
<span class="lineNum">     828 </span>            :   }
<span class="lineNum">     829 </span>            :   /*
<span class="lineNum">     830 </span>            :    * msDebug(&quot;bounds for %s: %f %f %f %f\n&quot;,ts-&gt;annotext,tgret-&gt;bounds.bbox.minx,tgret-&gt;bounds.bbox.miny,tgret-&gt;bounds.bbox.maxx,tgret-&gt;bounds.bbox.maxy);
<span class="lineNum">     831 </span>            :    */
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span><span class="lineCov">          1 : cleanup:</span>
<span class="lineNum">     834 </span><span class="lineCov">          1 :   if(line_descs != static_line_descs) free(line_descs);</span>
<span class="lineNum">     835 </span><span class="lineCov">          1 :   if(glyphs.codepoints != static_codepoints) {</span>
<span class="lineNum">     836 </span>            : #ifdef USE_FRIBIDI
<span class="lineNum">     837 </span><span class="lineCov">          1 :     free(glyphs.bidi_levels);</span>
<span class="lineNum">     838 </span><span class="lineCov">          1 :     free(glyphs.ctypes);</span>
<span class="lineNum">     839 </span>            : #endif
<span class="lineNum">     840 </span><span class="lineCov">          1 :     free(glyphs.codepoints);</span>
<span class="lineNum">     841 </span>            : #ifdef USE_HARFBUZZ
<span class="lineNum">     842 </span><span class="lineCov">          1 :     free(glyphs.scripts);</span>
<span class="lineNum">     843 </span>            : #endif
<span class="lineNum">     844 </span><span class="lineCov">          1 :     free(glyphs.unicodes);</span>
<span class="lineNum">     845 </span><span class="lineCov">          1 :     free(runs);</span>
<span class="lineNum">     846 </span>            :   }
<span class="lineNum">     847 </span>            :   return ret;
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
